<!DOCTYPE html>
<html lang="ca"> <!-- Idioma por defecto CA -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Space Conquest v23.6.12</title>
    <!-- Import Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@400;700&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <!-- Soporte básico para CJK fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP&family=Noto+Sans+SC&display=swap" rel="stylesheet">
    <style>
        /* CSS Styles (sin cambios) */
        body{margin:0;overflow:hidden;background-color:#020208;display:flex;justify-content:center;align-items:center;height:100vh;font-family:'Exo 2', 'Noto Sans JP', 'Noto Sans SC', sans-serif;flex-direction:column;color:#eee}
        canvas{display:block;background-color:#03030A;touch-action:none;max-width:100%;cursor:default}
        canvas.panning{cursor:grab}
        canvas.panning.grabbing{cursor:grabbing}
        canvas.interacting-node{cursor:crosshair}
        canvas.box-selecting{cursor:crosshair}
        #gameContainer{position:relative;width:100%;height:100%;display:none;justify-content:center;align-items:center}
        #controls{position:absolute;top:5px;left:5px;right:5px;background-color:rgba(10,10,25,0.85);padding:8px 12px;border-radius:5px;color:#fff;font-size:13px;display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap;z-index:10;pointer-events:none;border:1px solid rgba(100,120,150,0.5);box-shadow:0 2px 5px rgba(0,0,0,0.3)}
        #controls>*{pointer-events:auto}
        #menuButton{padding:5px 12px;margin-right:15px;font-size:13px;font-family:'Orbitron', 'Noto Sans JP', 'Noto Sans SC', sans-serif;cursor:pointer;border:none;background-color:#6c757d;color:#fff;border-radius:4px;transition:background-color .2s ease}
        #menuButton:hover{background-color:#8a9198}
        #message{line-height:1.3;margin-right:10px;flex-grow:1;font-size:14px;text-align:center}
        #percentageButtons{display:flex;align-items:center;white-space:nowrap}
        #percentageButtons span{margin-right:8px;font-size:14px}
        #percentageButtons button{padding:5px 10px;margin-left:4px;font-size:13px;font-family:'Orbitron', sans-serif;cursor:pointer;border:none;background-color:#444;color:#fff;border-radius:4px;transition:background-color .2s ease}
        #percentageButtons button:hover{background-color:#666}
        #percentageButtons button.active{background-color:#007bff;font-weight:700;box-shadow:0 0 5px rgba(0,123,255,0.7)}
        #gameOverMessage{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);background-color:rgba(10,10,25,0.9);color:#fff;padding:35px 50px;border-radius:10px;text-align:center;font-size:24px;display:none;z-index:20;cursor:pointer;border:1px solid rgba(100,120,150,0.6);box-shadow:0 5px 15px rgba(0,0,0,0.5)}
        #gameOverMessage h2{margin-top:0;font-size:32px;margin-bottom:20px;font-family:'Orbitron', 'Noto Sans JP', 'Noto Sans SC', sans-serif;color:#00aaff;text-shadow:1px 1px 3px rgba(0,0,0,0.5)}
        #gameOverMessage p{font-size:18px;margin-bottom:0}
        #startScreen{background-color:#040410;color:#eee;display:flex;flex-direction:column;justify-content:center;align-items:center;z-index:30;text-align:center;padding:20px;box-sizing:border-box;width:100vw;height:100vh;font-family:'Exo 2', 'Noto Sans JP', 'Noto Sans SC', sans-serif}
        #startScreen h1{margin-top:0;margin-bottom:10px;color:#00aaff;font-size:clamp(2.2em,9vw,4em);font-family:'Orbitron', sans-serif;text-shadow:2px 2px 5px rgba(0,120,180,0.7)}
        #startScreen .version{font-size:clamp(0.8em,2.2vw,1em);color:#bbb;margin-bottom:25px}
        #startScreen .author{margin-bottom:30px;font-size:clamp(0.9em,3vw,1.1em);color:#ccc}
        #startScreen .author a{color:#6cf;text-decoration:none}
        #startScreen .author a:hover{text-decoration:underline;color:#8df}
        #startScreen .settings{background-color:rgba(20,20,40,0.7);padding:25px;border-radius:8px;margin-bottom:35px;max-width:420px;width:90%;border:1px solid rgba(100,120,150,0.4)}
        #startScreen .setting-item{margin-bottom:18px;display:flex;justify-content:space-between;align-items:center;flex-wrap:wrap}
        #startScreen label{margin-right:10px;text-align:left;flex-basis:calc(60% - 10px);margin-bottom:5px;font-size:clamp(0.95em,2.6vw,1.05em)}
        #startScreen input[type=number],#startScreen select{width:75px;padding:9px;border-radius:4px;border:1px solid #667;background-color:#2a2a3a;color:#eee;text-align:center;flex-basis:calc(35% - 10px);font-size:clamp(0.9em,2.5vw,1em);-moz-appearance:textfield;box-sizing:border-box}
        #startScreen select{text-align-last:center;padding-right:15px;appearance:none;-webkit-appearance:none;-moz-appearance:none;background:#2a2a3a url('data:image/svg+xml;utf8,<svg fill="white" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>') no-repeat right 5px center;background-size:18px 18px}
        #startScreen select#languageSelect { width: auto; flex-basis: calc(35% - 10px); }
        #startScreen input[type=number]::-webkit-inner-spin-button,#startScreen input[type=number]::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}
        #startScreen .setting-item.sound-toggle { justify-content: center; }
        #startScreen .setting-item.sound-toggle label { flex-basis: auto; margin-right: 10px; }
        #startScreen .setting-item.sound-toggle input[type="checkbox"] { width: auto; flex-basis: auto; }
        #startButton{padding:14px 40px;font-size:clamp(1.1em,4.5vw,1.4em);cursor:pointer;background-color:#08c;color:#fff;border:none;border-radius:5px;transition:background-color .2s ease,transform .1s ease;text-shadow:1px 1px 3px rgba(0,0,0,0.6);font-family:'Orbitron', 'Noto Sans JP', 'Noto Sans SC', sans-serif;box-shadow:0 3px 6px rgba(0,0,0,0.4)}
        #startButton:hover{background-color:#0af;transform:translateY(-1px)}
        #startButton:active{transform:translateY(0)}
        #startButton:disabled { background-color: #555; cursor: not-allowed; }
        #introVideoContainer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #000; z-index: 100; display: none; }
        #introVideo { width: 100%; height: 100%; object-fit: cover; }
    </style>
</head>
<body>
    <!-- Start Screen -->
    <div id="startScreen">
        <h1>Space Conquest</h1>
        <div class="version">v23.6.12</div>
        <p class="author" id="authorText">per <a href="https://www.linkedin.com/in/oriol-badia" target="_blank" rel="noopener noreferrer">Oriol Badia Campanera</a></p>
        <div class="settings">
            <div class="setting-item"> <label for="languageSelect" id="languageLabel">Idioma:</label> <select id="languageSelect"> <option value="ca" selected>Català</option> <option value="es">Español</option> <option value="en">English</option> <option value="ja">日本語</option> <option value="zh">中文</option> </select> </div>
             <div class="setting-item"> <label for="numNodesInput" id="neutralNodesLabel">Nodes Neutrals (4-100):</label> <input type="number" id="numNodesInput" value="20" min="4" max="100"> </div>
            <div class="setting-item"> <label for="numEnemiesInput" id="enemiesLabel">Enemics IA (1-5):</label> <input type="number" id="numEnemiesInput" value="1" min="1" max="5"> </div>
            <div class="setting-item"> <label for="aiDifficultySelect" id="aiLevelLabel">Nivell IA:</label> <select id="aiDifficultySelect"> <option value="basic" id="aiLevelBasic">Bàsica</option> <option value="normal" id="aiLevelNormal" selected>Normal</option> <option value="expert" id="aiLevelExpert">Experta</option> </select> </div>
            <div class="setting-item sound-toggle"> <label for="soundCheckbox" id="musicLabel">Música ambient:</label> <input type="checkbox" id="soundCheckbox" checked> </div>
        </div>
        <button id="startButton" disabled>Carregant Recursos...</button>
    </div>

    <!-- Contenedor del Vídeo de Intro -->
    <div id="introVideoContainer"> <video id="introVideo" preload="auto" playsinline> <source src="http://urysoft.github.io/ai.html.games/general/assets/videos/Interstellar.mp4" type="video/mp4"> Tu navegador no soporta el elemento de vídeo. </video> </div>

    <!-- Game Container -->
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="controls">
            <button id="menuButton">Menu</button>
            <div id="message">...</div>
            <div id="percentageButtons"> <span id="sendLabel">Enviar:</span> <button data-percent="0.25">25%</button> <button data-percent="0.50" class="active">50%</button> <button data-percent="0.75">75%</button> <button data-percent="1.00">100%</button> </div>
        </div>
        <div id="gameOverMessage"> <h2 id="gameOverTitle"></h2> <p id="restartPrompt">Toca per reiniciar.</p> </div>
    </div>

    <!-- Audio Elements -->
    <audio id="ambientAudio1" src="http://urysoft.github.io/ai.html.games/general/assets/sounds/nothing.mp3" preload="auto"></audio>
    <audio id="ambientAudio2" src="http://urysoft.github.io/ai.html.games/general/assets/sounds/cyberpunk.mp3" preload="auto"></audio>
    <audio id="laserSound" src="http://urysoft.github.io/ai.html.games/general/assets/sounds/blaster2.mp3" preload="auto"></audio>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Elementos del DOM ---
            const canvas = document.getElementById('gameCanvas');
            if (!canvas) { console.error("¡Error Fatal! No se encontró el elemento canvas con ID 'gameCanvas'."); return; }
            const ctx = canvas.getContext('2d');
            const messageDiv = document.getElementById('message'); const percentageButtonsContainer = document.getElementById('percentageButtons'); const gameOverMessageDiv = document.getElementById('gameOverMessage'); const gameOverTitle = document.getElementById('gameOverTitle'); const startScreenDiv = document.getElementById('startScreen'); const numNodesInput = document.getElementById('numNodesInput'); const numEnemiesInput = document.getElementById('numEnemiesInput'); const startButton = document.getElementById('startButton'); const gameContainer = document.getElementById('gameContainer'); const menuButton = document.getElementById('menuButton'); const aiDifficultySelect = document.getElementById('aiDifficultySelect'); const soundCheckbox = document.getElementById('soundCheckbox'); const ambientAudio1 = document.getElementById('ambientAudio1'); const ambientAudio2 = document.getElementById('ambientAudio2'); const laserSound = document.getElementById('laserSound');
            const languageSelect = document.getElementById('languageSelect'); const languageLabel = document.getElementById('languageLabel'); const neutralNodesLabel = document.getElementById('neutralNodesLabel'); const enemiesLabel = document.getElementById('enemiesLabel'); const aiLevelLabel = document.getElementById('aiLevelLabel'); const aiLevelBasic = document.getElementById('aiLevelBasic'); const aiLevelNormal = document.getElementById('aiLevelNormal'); const aiLevelExpert = document.getElementById('aiLevelExpert'); const musicLabel = document.getElementById('musicLabel'); const authorText = document.getElementById('authorText'); const sendLabel = document.getElementById('sendLabel'); const restartPrompt = document.getElementById('restartPrompt');
            const introVideoContainer = document.getElementById('introVideoContainer'); const introVideo = document.getElementById('introVideo');

            // --- Configuración Global ---
            const PLAYER = 1; const NEUTRAL = 0;
            const PLAYER_COLOR = 'rgba(0, 150, 255, 1)'; const AI_COLORS = ['rgba(255, 50, 50, 1)','rgba(50, 200, 50, 1)','rgba(255, 150, 0, 1)','rgba(200, 0, 200, 1)','rgba(255, 255, 50, 1)']; const NEUTRAL_COLOR = 'rgba(120, 120, 120, 1)'; const SELECTED_COLOR = 'rgba(255, 255, 0, 0.9)'; const ATTACK_INDICATOR_COLOR = 'rgba(255, 0, 0, 1)'; const BOX_SELECT_COLOR = 'rgba(0, 150, 255, 0.4)'; const TRAIL_COLOR_ALPHA = '0.3';
            const UNIT_RADIUS = 2.8; const NODE_RADIUS_BASE = 35; const NODE_RADIUS_PER_UNIT = 0.02; const NODE_RADIUS_PER_LEVEL = 2.5; const MAX_NODE_LEVEL = 5; const UNIT_CAPACITY_PER_LEVEL = 100; const GENERATION_INTERVAL = 1050; const UNIT_SPEED = 1.7; let AI_ACTION_INTERVAL = 950; let AI_UPGRADE_CHANCE = 0.25;
            const SELECTION_LINE_WIDTH = 4.0; const POINTER_MARKER_RADIUS = 7; const ATTACK_INDICATOR_DURATION = 1500; const ATTACK_INDICATOR_BLINK_RATE = 200; const SATELLITE_COST = 50; const MAX_SATELLITES_PER_NODE = 5; const SATELLITE_ORBIT_RADIUS_BASE = 18; const SATELLITE_ORBIT_SPEED = 0.025; const SATELLITE_RADIUS = 4.5;
            const SATELLITE_RANGE = 200; const SATELLITE_FIRE_RATE_BASE = 1000; const SATELLITE_LASER_DURATION = 90;
            const TRAIL_SPAWN_INTERVAL = 100; const TRAIL_PARTICLE_RADIUS_MIN = 0.7; const TRAIL_PARTICLE_RADIUS_MAX = 1.3; const TRAIL_PARTICLE_LIFE_MIN = 350; const TRAIL_PARTICLE_LIFE_MAX = 650;
            const EXPLOSION_PARTICLE_COUNT = 6; const UNIT_TRAIL_MIN_ZOOM = 0.35; const SHADOW_MIN_ZOOM = 0.4; const AURA_CIRCLE_MIN_ZOOM = 0.3; const AURA_BLUR_FACTOR = 1.8; const AURA_ALPHA = '0.9';
            const WORLD_WIDTH = 6000; const WORLD_HEIGHT = 4000; const MIN_NODE_DISTANCE = 100;
            const INITIAL_CAMERA_ZOOM = 1.0; let NUM_NEUTRAL_NODES_SETTING = 20; let NUM_ENEMIES_SETTING = 1; let aiDifficultySetting = "normal"; let cameraX = 0; let cameraY = 0; let cameraZoom = INITIAL_CAMERA_ZOOM; let minZoomToFitWorld = 0.1; const ABSOLUTE_MIN_ZOOM = 0.05; const MAX_ZOOM = 2.5;
            const NUM_STARS = 3000; const MINIMAP_ENABLED = true; const MINIMAP_WIDTH = 180; const MINIMAP_HEIGHT = (MINIMAP_WIDTH / WORLD_WIDTH) * WORLD_HEIGHT; const MINIMAP_MARGIN = 12; const MINIMAP_NODE_SIZE = 3.0; const MINIMAP_CAMERA_COLOR = 'rgba(255, 255, 255, 0.7)';
            const UNIT_COLLISION_DIST_SQ = (UNIT_RADIUS * 1.6) * (UNIT_RADIUS * 1.6); const GRID_CELL_SIZE = SATELLITE_RANGE * 1.5;
            const DOUBLE_TAP_DELAY = 300; const TAP_DURATION_THRESHOLD = 250; const TAP_MOVEMENT_THRESHOLD = 10; const DRAG_THRESHOLD_FOR_ACTION = 15; const TOUCH_SEARCH_RADIUS_WORLD = 80;
            const PLANET_IMAGE_COUNT = 13; const planetImageURLs = []; const planetImages = []; const PLANET_IMAGE_PATH = "http://urysoft.github.io/ai.html.games/general/assets/images/";
            for (let i = 1; i <= PLANET_IMAGE_COUNT; i++) { planetImageURLs.push(`${PLANET_IMAGE_PATH}planeta${i}.png`); }

            // --- Estado del Juego ---
            let stars = []; let nodes = []; let units = []; let selectedNodes = []; let particles = []; let activeLasers = []; let activeNodeButtons = [];
            let currentSendPercentage = 0.50; let lastGenerationTime = 0; let lastAiActionTime = 0; let animationFrameId;
            let gameRunning = false; let spatialGrid; let soundEnabled = true; let imagesLoaded = false; let loadedImageCount = 0;
            let currentAmbientTrack = null; let firstInteractionDone = false;
            let currentLanguage = 'ca'; // Idioma por defecto CA
            let ambientPointerScreenPos = { x: null, y: null };
            let interaction = { pointers: new Map(), lastTapTime: 0, lastTappedNodeForDoubleTap: null, isInteractingNode: false, isPanning: false, isPinching: false, isBoxSelecting: false, pinchInitialDistance: 0, currentPointerScreenPos: { x: null, y: null }, boxStartScreenX: 0, boxStartScreenY: 0 };

            // --- Textos de Traducción (i18n) ---
            const translations = { /* ... (igual que antes) ... */
                ca: { languageLabel: "Idioma:", neutralNodesLabel: "Nodes Neutrals (4-100):", enemiesLabel: "Enemics IA (1-5):", aiLevelLabel: "Nivell IA:", aiLevelBasic: "Bàsica", aiLevelNormal: "Normal", aiLevelExpert: "Experta", musicLabel: "Música ambient:", authorText: "per", loading: "Carregant Recursos...", startGame: "Iniciar Joc", menuButton: "Menu", sendLabel: "Enviar:", messageTapDrag: "Toca/Arrossega Node", messageSending: "Enviar", messageNode: "Node", messageNodes: "Nodes", messageUnits: "U", messageLvl: "L", messageUpgrade: "Millora", messageSatellite: "Sat", messageMax: "MAX", victory: "VICTÒRIA!", defeat: "DERROTA", tie: "EMPAT ESTEL·LAR", restartPrompt: "Toca per reiniciar.", invalidNodes: (min, max) => `Nodes invàlids. Introdueix un número entre ${min} i ${max}.`, invalidEnemies: (min, max) => `Enemics invàlids. Introdueix un número entre ${min} i ${max}.`, },
                es: { languageLabel: "Idioma:", neutralNodesLabel: "Nodos Neutrales (4-100):", enemiesLabel: "Enemigos IA (1-5):", aiLevelLabel: "Nivel IA:", aiLevelBasic: "Básica", aiLevelNormal: "Normal", aiLevelExpert: "Experta", musicLabel: "Música ambiente:", authorText: "por", loading: "Cargando Recursos...", startGame: "Iniciar Juego", menuButton: "Menu", sendLabel: "Enviar:", messageTapDrag: "Toca/Arrastra Nodo", messageSending: "Enviar", messageNode: "Nodo", messageNodes: "Nodos", messageUnits: "U", messageLvl: "L", messageUpgrade: "Mejora", messageSatellite: "Sat", messageMax: "MAX", victory: "¡VICTORIA!", defeat: "DERROTA", tie: "EMPATE ESTELAR", restartPrompt: "Toca para reiniciar.", invalidNodes: (min, max) => `Nodos inválidos. Introduce un número entre ${min} y ${max}.`, invalidEnemies: (min, max) => `Enemigos inválidos. Introduce un número entre ${min} y ${max}.`, },
                en: { languageLabel: "Language:", neutralNodesLabel: "Neutral Nodes (4-100):", enemiesLabel: "AI Enemies (1-5):", aiLevelLabel: "AI Level:", aiLevelBasic: "Basic", aiLevelNormal: "Normal", aiLevelExpert: "Expert", musicLabel: "Ambient Music:", authorText: "by", loading: "Loading Resources...", startGame: "Start Game", menuButton: "Menu", sendLabel: "Send:", messageTapDrag: "Tap/Drag Node", messageSending: "Send", messageNode: "Node", messageNodes: "Nodes", messageUnits: "U", messageLvl: "Lvl", messageUpgrade: "Upgrade", messageSatellite: "Sat", messageMax: "MAX", victory: "VICTORY!", defeat: "DEFEAT", tie: "STELLAR DRAW", restartPrompt: "Tap to restart.", invalidNodes: (min, max) => `Invalid nodes. Enter a number between ${min} and ${max}.`, invalidEnemies: (min, max) => `Invalid enemies. Enter a number between ${min} and ${max}.`, },
                ja: { languageLabel: "言語:", neutralNodesLabel: "中立ノード (4-100):", enemiesLabel: "AI敵 (1-5):", aiLevelLabel: "AIレベル:", aiLevelBasic: "基本", aiLevelNormal: "ノーマル", aiLevelExpert: "エキスパート", musicLabel: "環境音楽:", authorText: "作", loading: "リソースを読み込み中...", startGame: "ゲーム開始", menuButton: "メニュー", sendLabel: "送信:", messageTapDrag: "ノードをタップ/ドラッグ", messageSending: "送信", messageNode: "ノード", messageNodes: "ノード", messageUnits: "U", messageLvl: "L", messageUpgrade: "アップグレード", messageSatellite: "衛星", messageMax: "最大", victory: "勝利！", defeat: "敗北", tie: "引き分け", restartPrompt: "タップして再起動", invalidNodes: (min, max) => `無効なノード。${min}から${max}の間の数値を入力してください。`, invalidEnemies: (min, max) => `無効な敵。${min}から${max}の間の数値を入力してください。`, },
                zh: { languageLabel: "语言:", neutralNodesLabel: "中立节点 (4-100):", enemiesLabel: "AI敌人 (1-5):", aiLevelLabel: "AI 等级:", aiLevelBasic: "基础", aiLevelNormal: "普通", aiLevelExpert: "专家", musicLabel: "环境音乐:", authorText: "作者", loading: "正在加载资源...", startGame: "开始游戏", menuButton: "菜单", sendLabel: "发送:", messageTapDrag: "点击/拖动节点", messageSending: "发送", messageNode: "节点", messageNodes: "节点", messageUnits: "单位", messageLvl: "等级", messageUpgrade: "升级", messageSatellite: "卫星", messageMax: "最大", victory: "胜利！", defeat: "失败", tie: "平局", restartPrompt: "点击重新开始。", invalidNodes: (min, max) => `无效节点。请输入 ${min} 到 ${max} 之间的数字。`, invalidEnemies: (min, max) => `无效敌人。请输入 ${min} 到 ${max} 之间的数字。`, }
            };

            // --- Funciones Utilitarias y de Estado (Definidas Temprano) ---
            function getText(key) { const langTexts = translations[currentLanguage] || translations['en']; const textOrFunc = langTexts[key]; if (typeof textOrFunc === 'function') { const args = Array.prototype.slice.call(arguments, 1); return textOrFunc.apply(null, args); } return textOrFunc || `[${key}]`; }
            function updateLanguage() { document.documentElement.lang = currentLanguage; languageLabel.textContent = getText('languageLabel'); neutralNodesLabel.textContent = getText('neutralNodesLabel'); enemiesLabel.textContent = getText('enemiesLabel'); aiLevelLabel.textContent = getText('aiLevelLabel'); aiLevelBasic.textContent = getText('aiLevelBasic'); aiLevelNormal.textContent = getText('aiLevelNormal'); aiLevelExpert.textContent = getText('aiLevelExpert'); musicLabel.textContent = getText('musicLabel'); authorText.innerHTML = `${getText('authorText')} <a href="https://www.linkedin.com/in/oriol-badia" target="_blank" rel="noopener noreferrer">Oriol Badia Campanera</a>`; startButton.textContent = imagesLoaded ? getText('startGame') : getText('loading'); menuButton.textContent = getText('menuButton'); sendLabel.textContent = getText('sendLabel'); restartPrompt.textContent = getText('restartPrompt'); if (!gameRunning) { updateMessage(); } }
            function controlSound() { soundEnabled = soundCheckbox.checked; try { if (soundEnabled) { if (firstInteractionDone && (!currentAmbientTrack || currentAmbientTrack.paused)) { console.log("ControlSound: Starting ambient loop with Track 1."); currentAmbientTrack = ambientAudio1; ambientAudio1.play().catch(e => console.warn("Ambient 1 play failed:", e)); if (ambientAudio2 && !ambientAudio2.paused) ambientAudio2.pause(); } else if (!firstInteractionDone) { console.log("ControlSound: Sound enabled, but waiting for first interaction to play."); if (ambientAudio1 && !ambientAudio1.paused) ambientAudio1.pause(); if (ambientAudio2 && !ambientAudio2.paused) ambientAudio2.pause(); currentAmbientTrack = ambientAudio1; } } else { console.log("ControlSound: Stopping ambient loop."); if (ambientAudio1 && !ambientAudio1.paused) ambientAudio1.pause(); if (ambientAudio2 && !ambientAudio2.paused) ambientAudio2.pause(); currentAmbientTrack = null; } } catch (e) { console.error("Error controlling ambient audio:", e); } }
            function handleFirstInteraction() { if (firstInteractionDone) return; firstInteractionDone = true; console.log("First user interaction detected."); if (soundEnabled && currentAmbientTrack && currentAmbientTrack.paused) { console.log("Attempting to play ambient sound after interaction."); currentAmbientTrack.play().catch(e => console.warn("Still couldn't play sound after interaction:", e)); } document.removeEventListener('pointerdown', handleFirstInteraction); document.removeEventListener('keydown', handleFirstInteraction); }
            function updateMessage() { if (!gameRunning && startScreenDiv.style.display === 'flex') { messageDiv.innerHTML = '...'; return; } let msg = ""; const percentageText = `${Math.round(currentSendPercentage * 100)}%`; if (selectedNodes.length === 0) { msg = `${getText('messageTapDrag')} | ${getText('sendLabel')} ${percentageText}`; } else if (selectedNodes.length === 1) { const node = selectedNodes[0]; const cost = calculateUpgradeCost(node); let upgradeText = cost === Infinity ? `(${getText('messageMax')})` : `(${getText('messageUpgrade')}: ${cost} ${getText('messageUnits')})`; let satelliteText = node.satellites.length > 0 ? ` (${node.satellites.length}/${MAX_SATELLITES_PER_NODE} ${getText('messageSatellite')})` : ""; let buildSatText = ""; if(node.satellites.length < MAX_SATELLITES_PER_NODE) { buildSatText = ` (${getText('messageSatellite')}: ${SATELLITE_COST} ${getText('messageUnits')})`; } let unitsToSend = 0; if (currentSendPercentage === 1.0 && node.unitCount > 1) unitsToSend = node.unitCount - 1; else unitsToSend = Math.floor(node.unitCount * currentSendPercentage); if (unitsToSend === 0 && node.unitCount >=1 && currentSendPercentage > 0) unitsToSend = 1; unitsToSend = Math.min(unitsToSend, node.unitCount); msg = `${getText('messageNode')}: ${Math.floor(node.unitCount)}/${node.getMaxCapacity()} ${getText('messageUnits')} ${getText('messageLvl')}${node.level}${satelliteText} ${upgradeText}${buildSatText} | ${getText('messageSending')} ${unitsToSend} (${percentageText})`; } else { let totalUnits = 0; selectedNodes.forEach(node => totalUnits += node.unitCount); let totalUnitsToSend = 0; selectedNodes.forEach(node => { let unitsFromThisNode = 0; if (currentSendPercentage === 1.0 && node.unitCount > 1) unitsFromThisNode = node.unitCount - 1; else unitsFromThisNode = Math.floor(node.unitCount * currentSendPercentage); if (unitsFromThisNode === 0 && node.unitCount >=1 && currentSendPercentage > 0) unitsFromThisNode = 1; totalUnitsToSend += Math.min(unitsFromThisNode, node.unitCount); }); msg = `${selectedNodes.length} ${getText('messageNodes')}: ${Math.floor(totalUnits)} ${getText('messageUnits')} | ${getText('messageSending')} ~${totalUnitsToSend} (${percentageText})`; } messageDiv.innerHTML = msg; }
            function preloadImages(callback) { console.log("Preloading images..."); loadedImageCount = 0; planetImages.length = 0; if (planetImageURLs.length === 0) { console.warn("No planet images defined."); imagesLoaded = true; if (callback) callback(); return; } planetImageURLs.forEach((url, index) => { const img = new Image(); img.onload = () => { loadedImageCount++; if (loadedImageCount === planetImageURLs.length) { imagesLoaded = true; console.log("All images preloaded."); if (callback) callback(); } }; img.onerror = () => { console.error(`Failed to load image: ${url}`); loadedImageCount++; if (loadedImageCount === planetImageURLs.length) { imagesLoaded = true; console.warn("Finished preloading images, some failed."); if (callback) callback(); } }; img.src = url; planetImages[index] = img; }); }

            // --- Definiciones de Clases (Particle, Node, Satellite, Unit, SpatialGrid) ---
            // ... (código de las clases aquí, sin cambios) ...
            class Particle { constructor(x, y, color, type = 'explosion') { this.x = x; this.y = y; this.color = color; this.type = type; if (type === 'trail') { this.radius = TRAIL_PARTICLE_RADIUS_MIN + Math.random() * (TRAIL_PARTICLE_RADIUS_MAX - TRAIL_PARTICLE_RADIUS_MIN); this.life = TRAIL_PARTICLE_LIFE_MIN + Math.random() * (TRAIL_PARTICLE_LIFE_MAX - TRAIL_PARTICLE_LIFE_MIN); this.alpha = parseFloat(TRAIL_COLOR_ALPHA); const angle = Math.random() * Math.PI * 2; const speed = Math.random() * 0.3 + 0.1; this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed; } else { this.radius = Math.random() * 2.0 + 1.0; this.life = 450 + Math.random() * 450; this.alpha = 1.0; const angle = Math.random() * Math.PI * 2; const speed = Math.random() * 1.8 + 0.6; this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed; } this.initialLife = this.life; this.initialAlpha = this.alpha; } update(deltaTime) { this.life -= deltaTime; if (this.life <= 0) return true; this.x += this.vx; this.y += this.vy; this.alpha = Math.max(0, (this.life / this.initialLife) * this.initialAlpha); if (this.type !== 'trail') { this.vx *= 0.97; this.vy *= 0.97; } else { this.vx *= 0.99; this.vy *= 0.99; } return false; } draw() { ctx.save(); ctx.globalAlpha = this.alpha; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.restore(); } }
            function calculateUpgradeCost(node) { if (node.level >= MAX_NODE_LEVEL) return Infinity; const targetLevel = node.level + 1; const targetCapacity = targetLevel * UNIT_CAPACITY_PER_LEVEL; return Math.floor(targetCapacity / 2); }
            class Node { constructor(x, y, owner, initialUnits) { this.x = x; this.y = y; this.owner = owner; this.unitCount = initialUnits; this.level = 1; this.generationTimer = 0; this.isSelected = false; this.isUnderAttack = false; this.attackTimer = 0; this.satellites = []; this.imageIndex = Math.floor(Math.random() * planetImages.length); } get radius() { return NODE_RADIUS_BASE + (this.level * NODE_RADIUS_PER_LEVEL) + this.unitCount * NODE_RADIUS_PER_UNIT; } getColor() { if (this.owner === PLAYER) return PLAYER_COLOR; if (this.owner === NEUTRAL) return NEUTRAL_COLOR; const aiIndex = this.owner - 2; return AI_COLORS[aiIndex % AI_COLORS.length]; } getMaxCapacity() { return this.level * UNIT_CAPACITY_PER_LEVEL; } draw() { const color = this.getColor(); const r = this.radius; const img = planetImages[this.imageIndex]; const useCircleAura = cameraZoom < AURA_CIRCLE_MIN_ZOOM; const useShadowAura = cameraZoom >= SHADOW_MIN_ZOOM; if (this.owner !== NEUTRAL && useCircleAura) { ctx.fillStyle = this.getColor(); ctx.globalAlpha = 0.6; ctx.beginPath(); ctx.arc(this.x, this.y, r * 1.2, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1.0; } if (this.owner !== NEUTRAL && useShadowAura) { const baseColor = this.getColor(); let auraColor = baseColor; const rgbaMatch = baseColor.match(/rgba?\((\d+), *(\d+), *(\d+)(?:, *([\d.]+))?\)/); if (rgbaMatch) { auraColor = `rgba(${rgbaMatch[1]}, ${rgbaMatch[2]}, ${rgbaMatch[3]}, ${AURA_ALPHA})`; } ctx.shadowBlur = r * AURA_BLUR_FACTOR; ctx.shadowColor = auraColor; } else { ctx.shadowBlur = 0; } if (img && img.complete) { try { ctx.drawImage(img, this.x - r, this.y - r, r * 2, r * 2); } catch (e) { console.error("Error drawing node image:", e, img.src); ctx.fillStyle = NEUTRAL_COLOR; ctx.beginPath(); ctx.arc(this.x, this.y, r, 0, Math.PI * 2); ctx.fill(); } } else { ctx.fillStyle = NEUTRAL_COLOR; ctx.beginPath(); ctx.arc(this.x, this.y, r, 0, Math.PI * 2); ctx.fill(); } ctx.shadowBlur = 0; if (this.isSelected) { ctx.strokeStyle = SELECTED_COLOR; ctx.lineWidth = SELECTION_LINE_WIDTH / cameraZoom; ctx.beginPath(); ctx.arc(this.x, this.y, r + 6 / cameraZoom, 0, Math.PI * 2); ctx.stroke(); } if (this.isUnderAttack) { const blinkOn = Math.floor(performance.now() / ATTACK_INDICATOR_BLINK_RATE) % 2 === 0; if (blinkOn) { ctx.strokeStyle = ATTACK_INDICATOR_COLOR; ctx.lineWidth = (SELECTION_LINE_WIDTH + 2) / cameraZoom; ctx.beginPath(); ctx.arc(this.x, this.y, r + 9 / cameraZoom, 0, Math.PI * 2); ctx.stroke(); } } ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; const baseFontSize = Math.max(12, r * 0.5); const textPadding = 4; const textBgAlpha = 0.65; ctx.font = `bold ${baseFontSize}px 'Exo 2', sans-serif`; const unitText = Math.floor(this.unitCount); const unitTextWidth = ctx.measureText(unitText).width; const unitBgWidth = unitTextWidth + textPadding * 2; const unitBgHeight = baseFontSize + textPadding * 1.5; const unitBgY = this.y - unitBgHeight / 2; ctx.fillStyle = `rgba(0, 0, 0, ${textBgAlpha})`; ctx.fillRect(this.x - unitBgWidth / 2, unitBgY, unitBgWidth, unitBgHeight); ctx.fillStyle = 'white'; ctx.fillText(unitText, this.x, this.y); if (this.owner !== NEUTRAL) { const levelFontSize = Math.max(10, r * 0.3); ctx.font = `bold ${levelFontSize}px 'Exo 2', sans-serif`; const levelText = `${getText('messageLvl')} ${this.level}`; const levelTextWidth = ctx.measureText(levelText).width; const levelBgWidth = levelTextWidth + textPadding * 2; const levelBgHeight = levelFontSize + textPadding * 1.5; const levelBgY = this.y + unitBgHeight / 2 + 2; ctx.fillStyle = `rgba(0, 0, 0, ${textBgAlpha})`; ctx.fillRect(this.x - levelBgWidth / 2, levelBgY, levelBgWidth, levelBgHeight); ctx.fillStyle = 'white'; ctx.fillText(levelText, this.x, levelBgY + levelBgHeight / 2); } this.satellites.forEach(sat => sat.draw()); } update(deltaTime) { if (this.owner !== NEUTRAL && gameRunning) { const maxCapacity = this.getMaxCapacity(); if (this.unitCount < maxCapacity) { this.generationTimer += deltaTime; const effectiveInterval = GENERATION_INTERVAL / Math.pow(1.6, this.level - 1); if (this.generationTimer >= effectiveInterval) { const generations = Math.floor(this.generationTimer / effectiveInterval); const generatedAmount = Math.min(generations, maxCapacity - Math.floor(this.unitCount)); this.unitCount += generatedAmount; this.generationTimer %= effectiveInterval; } } else { this.generationTimer = 0; } } if (this.isUnderAttack) { this.attackTimer -= deltaTime; if (this.attackTimer <= 0) { this.isUnderAttack = false; } } this.satellites.forEach(sat => sat.update(deltaTime)); } attemptUpgrade() { if (this.level >= MAX_NODE_LEVEL) return false; const cost = calculateUpgradeCost(this); if (this.unitCount >= cost) { this.unitCount -= cost; this.level++; if (this.owner === PLAYER) updateMessage(); return true; } else { return false; } } resetOnCapture() { this.level = 1; this.generationTimer = 0; this.isUnderAttack = false; this.attackTimer = 0; this.satellites = []; } attemptBuildSatellite() { if (this.satellites.length >= MAX_SATELLITES_PER_NODE) return false; if (this.unitCount >= SATELLITE_COST) { this.unitCount -= SATELLITE_COST; const newSatellite = new Satellite(this, 0); this.satellites.push(newSatellite); const totalSatellites = this.satellites.length; const angleStep = (Math.PI * 2) / totalSatellites; this.satellites.forEach((sat, index) => { sat.angle = index * angleStep; sat.updatePosition(); }); if (this.owner === PLAYER) updateMessage(); return true; } else { return false; } } }
            class Satellite { constructor(parentNode, initialAngle = 0) { this.parentNode = parentNode; this.angle = initialAngle; this.orbitRadiusOffset = SATELLITE_ORBIT_RADIUS_BASE; this.fireRateLevel = 1; this.fireCooldown = 0; this.targetUnit = null; this.x = 0; this.y = 0; this.updatePosition(); } get fireRate() { return SATELLITE_FIRE_RATE_BASE; } updatePosition() { const orbitRadius = this.parentNode.radius + this.orbitRadiusOffset / cameraZoom; this.x = this.parentNode.x + Math.cos(this.angle) * orbitRadius; this.y = this.parentNode.y + Math.sin(this.angle) * orbitRadius; } update(deltaTime) { this.angle += SATELLITE_ORBIT_SPEED; if (this.angle > Math.PI * 2) this.angle -= Math.PI * 2; this.updatePosition(); if (this.fireCooldown > 0) { this.fireCooldown -= deltaTime; } if (this.fireCooldown <= 0) { if (!this.targetUnit || !units.includes(this.targetUnit) || this.distanceTo(this.targetUnit) > SATELLITE_RANGE || this.targetUnit.toBeRemoved) { this.findTarget(); } if (this.targetUnit) { this.fire(); } } } distanceTo(unit) { const dx = unit.x - this.x; const dy = unit.y - this.y; return Math.sqrt(dx * dx + dy * dy); } findTarget() { this.targetUnit = null; let closestDistSq = SATELLITE_RANGE * SATELLITE_RANGE; let potentialTarget = null; if (!spatialGrid) return; const nearbyUnits = spatialGrid.getNearbyUnits(this); for (const unit of nearbyUnits) { if (unit && unit.owner !== this.parentNode.owner && unit.owner !== NEUTRAL && !unit.toBeRemoved) { const dx = unit.x - this.x; const dy = unit.y - this.y; const distSq = dx * dx + dy * dy; if (distSq < closestDistSq) { closestDistSq = distSq; potentialTarget = unit; } } } this.targetUnit = potentialTarget; } fire() { if (!this.targetUnit || this.targetUnit.toBeRemoved) { this.targetUnit = null; return; } if (soundEnabled && laserSound) { laserSound.currentTime = 0; laserSound.play().catch(e => console.warn("Laser sound play failed:", e)); } activeLasers.push({ fromX: this.x, fromY: this.y, toX: this.targetUnit.x, toY: this.targetUnit.y, endTime: performance.now() + SATELLITE_LASER_DURATION, ownerColor: this.parentNode.getColor() }); const targetX = this.targetUnit.x; const targetY = this.targetUnit.y; const targetColor = this.targetUnit.getColor(); this.targetUnit.toBeRemoved = true; spawnExplosion(targetX, targetY, targetColor, EXPLOSION_PARTICLE_COUNT + 2, 1.3); this.targetUnit = null; this.fireCooldown = this.fireRate; } draw() { ctx.fillStyle = this.parentNode.getColor(); ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)'; ctx.lineWidth = 1.5 / cameraZoom; const useShadow = cameraZoom >= SHADOW_MIN_ZOOM; if(useShadow){ ctx.shadowBlur = 10; ctx.shadowColor = this.parentNode.getColor().replace('1)', '0.7)'); } ctx.beginPath(); ctx.arc(this.x, this.y, SATELLITE_RADIUS, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); if(useShadow) ctx.shadowBlur = 0; } }
            class Unit { constructor(startX, startY, targetNode, owner) { this.x = startX; this.y = startY; this.owner = owner; this.radius = UNIT_RADIUS; this.targetNode = targetNode; this.interceptTargetUnit = null; this.toBeRemoved = false; this.vx = 0; this.vy = 0; this.trailSpawnTimer = Math.random() * TRAIL_SPAWN_INTERVAL; if (this.targetNode) { const targetX = this.targetNode.x; const targetY = this.targetNode.y; const dx = targetX - startX; const dy = targetY - startY; const dist = Math.sqrt(dx * dx + dy * dy); if (dist !== 0) { this.vx = (dx / dist) * UNIT_SPEED; this.vy = (dy / dist) * UNIT_SPEED; } } else { this.toBeRemoved = true; } } getColor() { if (this.owner === PLAYER) return PLAYER_COLOR; if (this.owner === NEUTRAL) return NEUTRAL_COLOR; const aiIndex = this.owner - 2; return AI_COLORS[aiIndex % AI_COLORS.length]; } getColorWithAlpha(alpha) { return this.getColor().replace(/, *1 *\)/, `, ${alpha})`); } draw() { const useShadow = cameraZoom >= SHADOW_MIN_ZOOM; const useSimpleDraw = cameraZoom < UNIT_TRAIL_MIN_ZOOM; if (useShadow && !useSimpleDraw) { ctx.shadowBlur = 8; ctx.shadowColor = this.getColor().replace('1)', '0.8)'); } ctx.fillStyle = this.getColor(); ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); if (useShadow && !useSimpleDraw) ctx.shadowBlur = 0; } update(deltaTime) { if (this.toBeRemoved) return; if (this.interceptTargetUnit) { if (!this.interceptTargetUnit || this.interceptTargetUnit.toBeRemoved || !units.includes(this.interceptTargetUnit)) { this.interceptTargetUnit = null; if (this.targetNode) { const dx = this.targetNode.x - this.x; const dy = this.targetNode.y - this.y; const dist = Math.sqrt(dx*dx + dy*dy); if (dist > 0) { this.vx = (dx / dist) * UNIT_SPEED; this.vy = (dy / dist) * UNIT_SPEED; } else { this.vx = 0; this.vy = 0; } } else { this.vx = 0; this.vy = 0; } } else { const dx = this.interceptTargetUnit.x - this.x; const dy = this.interceptTargetUnit.y - this.y; const dist = Math.sqrt(dx * dx + dy * dy); if (dist > 0) { this.vx = (dx / dist) * UNIT_SPEED; this.vy = (dy / dist) * UNIT_SPEED; } } } else if (!this.vx && !this.vy && this.targetNode) { const dx = this.targetNode.x - this.x; const dy = this.targetNode.y - this.y; const dist = Math.sqrt(dx*dx + dy*dy); if (dist > 0) { this.vx = (dx / dist) * UNIT_SPEED; this.vy = (dy / dist) * UNIT_SPEED; } } this.x += this.vx; this.y += this.vy; const canSpawnTrail = cameraZoom >= UNIT_TRAIL_MIN_ZOOM; if (canSpawnTrail) { this.trailSpawnTimer += deltaTime; if (this.trailSpawnTimer >= TRAIL_SPAWN_INTERVAL) { this.trailSpawnTimer %= TRAIL_SPAWN_INTERVAL; const trailX = this.x - this.vx * 0.8; const trailY = this.y - this.vy * 0.8; spawnTrailParticle(trailX, trailY, this.getColor()); } } } onArrival() { if (!gameRunning || this.toBeRemoved || !this.targetNode) return; const targetNode = this.targetNode; if (targetNode.owner === this.owner) { targetNode.unitCount++; } else { if (targetNode.owner !== NEUTRAL) { targetNode.isUnderAttack = true; targetNode.attackTimer = ATTACK_INDICATOR_DURATION; } targetNode.unitCount--; if (targetNode.unitCount < 0) { const oldOwner = targetNode.owner; targetNode.owner = this.owner; targetNode.unitCount = 1; targetNode.resetOnCapture(); const indexInSelection = selectedNodes.indexOf(targetNode); if (indexInSelection > -1) { targetNode.isSelected = false; selectedNodes.splice(indexInSelection, 1); updateMessage(); } checkWinCondition(); } } } }
            class SpatialGrid { constructor(worldWidth, worldHeight, cellSize) { this.cellSize = cellSize; this.cols = Math.ceil(worldWidth / cellSize); this.rows = Math.ceil(worldHeight / cellSize); this.grid = []; for (let i = 0; i < this.cols; i++) { this.grid[i] = []; for (let j = 0; j < this.rows; j++) { this.grid[i][j] = new Set(); } } console.log(`Spatial Grid created: ${this.cols}x${this.rows} cells of size ${this.cellSize}`); } clear() { for (let i = 0; i < this.cols; i++) { for (let j = 0; j < this.rows; j++) { this.grid[i][j].clear(); } } } getCellCoords(x, y) { const col = Math.max(0, Math.min(this.cols - 1, Math.floor(x / this.cellSize))); const row = Math.max(0, Math.min(this.rows - 1, Math.floor(y / this.cellSize))); return { col, row }; } add(unit) { const { col, row } = this.getCellCoords(unit.x, unit.y); if(this.grid[col]?.[row]) { this.grid[col][row].add(unit); } } getNearbyUnits(entity) { const nearby = new Set(); const { col: centerCol, row: centerRow } = this.getCellCoords(entity.x, entity.y); for (let i = Math.max(0, centerCol - 1); i <= Math.min(this.cols - 1, centerCol + 1); i++) { for (let j = Math.max(0, centerRow - 1); j <= Math.min(this.rows - 1, centerRow + 1); j++) { if(this.grid[i]?.[j]) { this.grid[i][j].forEach(otherUnit => { if (entity !== otherUnit) { nearby.add(otherUnit); } }); } } } return nearby; } }

            // --- Funciones de Juego Principales ---
            // ... (igual que antes) ...
            function spawnExplosion(x, y, color, count, speedMultiplier = 1.0) { for (let i = 0; i < count; i++) { const p = new Particle(x, y, color, 'explosion'); p.vx *= speedMultiplier; p.vy *= speedMultiplier; particles.push(p); } }
            function spawnTrailParticle(x, y, baseColor) { const trailColor = baseColor.replace(/, *1 *\)/, `, ${TRAIL_COLOR_ALPHA})`); particles.push(new Particle(x, y, trailColor, 'trail')); }
            function startGameLogic() { console.log(`--- Start Game: ${NUM_NEUTRAL_NODES_SETTING} Nodes, ${NUM_ENEMIES_SETTING} Enemies (${aiDifficultySetting} AI) ---`); switch (aiDifficultySetting) { case 'basic': AI_ACTION_INTERVAL = 1200; AI_UPGRADE_CHANCE = 0.15; break; case 'expert': AI_ACTION_INTERVAL = 700; AI_UPGRADE_CHANCE = 0.40; break; case 'normal': default: AI_ACTION_INTERVAL = 950; AI_UPGRADE_CHANCE = 0.25; break; } console.log(`AI Params: Interval=${AI_ACTION_INTERVAL}, UpgradeChance=${AI_UPGRADE_CHANCE}`); resizeCanvas(); spatialGrid = new SpatialGrid(WORLD_WIDTH, WORLD_HEIGHT, GRID_CELL_SIZE); nodes = []; units = []; selectedNodes = []; particles = []; activeLasers = []; activeNodeButtons = []; gameRunning = true; interaction = { pointers: new Map(), lastTapTime: 0, lastTappedNodeForDoubleTap: null, isInteractingNode: false, isPanning: false, isPinching: false, isBoxSelecting: false, pinchInitialDistance: 0, currentPointerScreenPos: { x: null, y: null }, boxStartScreenX: 0, boxStartScreenY: 0 }; ambientPointerScreenPos = { x: null, y: null }; gameOverMessageDiv.style.display = 'none'; currentSendPercentage = 0.50; setActivePercentageButton(); stars = []; for (let i = 0; i < NUM_STARS; i++) { stars.push({ x: Math.random() * WORLD_WIDTH, y: Math.random() * WORLD_HEIGHT, depth: 0.05 + Math.random() * 0.75, size: 0.5 + Math.random() * 1.1, alpha: 0.4 + Math.random() * 0.5 }); } stars.sort((a, b) => a.depth - b.depth); const maxInitialUnits = 35; const maxInitialRadius = NODE_RADIUS_BASE + (1 * NODE_RADIUS_PER_LEVEL) + maxInitialUnits * NODE_RADIUS_PER_UNIT + 10; const worldMargin = maxInitialRadius * 1.5; const startingPlayers = 1 + NUM_ENEMIES_SETTING; const playerPositions = []; playerPositions.push({ x: worldMargin + Math.random() * (WORLD_WIDTH - 2 * worldMargin), y: worldMargin + Math.random() * (WORLD_HEIGHT - 2 * worldMargin), owner: PLAYER }); for (let i = 0; i < NUM_ENEMIES_SETTING; i++) { let placed = false; let attempts = 0; const maxPlacementAttempts = 600; const minDistSq = Math.pow(Math.min(WORLD_WIDTH, WORLD_HEIGHT) / (startingPlayers * 1.2), 2); while (!placed && attempts < maxPlacementAttempts) { attempts++; const potentialX = worldMargin + Math.random() * (WORLD_WIDTH - 2 * worldMargin); const potentialY = worldMargin + Math.random() * (WORLD_HEIGHT - 2 * worldMargin); let tooClose = false; for (const p of playerPositions) { const dx = potentialX - p.x; const dy = potentialY - p.y; if (dx * dx + dy * dy < minDistSq) { tooClose = true; break; } } if (!tooClose) { playerPositions.push({ x: potentialX, y: potentialY, owner: 2 + i }); placed = true; } } if (!placed) console.warn(`Could not place AI ${i+1} far apart after ${maxPlacementAttempts} attempts.`); } let playerNodeRef = null; playerPositions.forEach(p => { const newNode = new Node(p.x, p.y, p.owner, maxInitialUnits); nodes.push(newNode); if (p.owner === PLAYER) playerNodeRef = newNode; }); let neutralCount = 0; let attempts = 0; const maxAttempts = 250; while (neutralCount < NUM_NEUTRAL_NODES_SETTING && attempts < maxAttempts * NUM_NEUTRAL_NODES_SETTING) { attempts++; const nx = worldMargin + Math.random() * (WORLD_WIDTH - 2 * worldMargin); const ny = worldMargin + Math.random() * (WORLD_HEIGHT - 2 * worldMargin); const newNode = new Node(nx, ny, NEUTRAL, 15 + Math.floor(Math.random() * 21)); let tooClose = false; for (const existingNode of nodes) { const dx = newNode.x - existingNode.x; const dy = newNode.y - existingNode.y; const effectiveMinDist = MIN_NODE_DISTANCE + newNode.radius + existingNode.radius; if (dx * dx + dy * dy < effectiveMinDist * effectiveMinDist) { tooClose = true; break; } } if (!tooClose) { nodes.push(newNode); neutralCount++; } } if(neutralCount < NUM_NEUTRAL_NODES_SETTING) console.warn(`Placed only ${neutralCount}/${NUM_NEUTRAL_NODES_SETTING} neutral nodes.`); const zoomFitW = canvas.width / WORLD_WIDTH; const zoomFitH = canvas.height / WORLD_HEIGHT; minZoomToFitWorld = Math.max(zoomFitW, zoomFitH); cameraZoom = Math.max(minZoomToFitWorld, INITIAL_CAMERA_ZOOM); console.log(`Initial Zoom set to: ${cameraZoom.toFixed(3)} (Fixed target: ${INITIAL_CAMERA_ZOOM}, MinFit: ${minZoomToFitWorld.toFixed(3)})`); if (playerNodeRef) { const initialScreenW = canvas.width; const initialScreenH = canvas.height; cameraX = playerNodeRef.x - (initialScreenW / 2) / cameraZoom; cameraY = playerNodeRef.y - (initialScreenH / 2) / cameraZoom; } else { cameraX = (WORLD_WIDTH - canvas.width / cameraZoom) / 2; cameraY = (WORLD_HEIGHT - canvas.height / cameraZoom) / 2; } clampCamera(); lastGenerationTime = performance.now(); lastAiActionTime = performance.now(); if (animationFrameId) { cancelAnimationFrame(animationFrameId); } updateMessage(); controlSound(); gameLoop(); }
            function resizeCanvas() { const controlsHeight = document.getElementById('controls').offsetHeight; const availableHeight = window.innerHeight - controlsHeight - 5; const availableWidth = window.innerWidth; canvas.width = availableWidth; canvas.height = availableHeight; canvas.style.marginTop = `${controlsHeight}px`; const zoomFitW = canvas.width / WORLD_WIDTH; const zoomFitH = canvas.height / WORLD_HEIGHT; minZoomToFitWorld = Math.max(zoomFitW, zoomFitH); console.log(`Canvas resized: ${canvas.width}x${canvas.height}. New Min Zoom: ${minZoomToFitWorld.toFixed(3)}`); cameraZoom = Math.max(minZoomToFitWorld, cameraZoom); clampCamera(); if (spatialGrid) { spatialGrid = new SpatialGrid(WORLD_WIDTH, WORLD_HEIGHT, GRID_CELL_SIZE); } }
            function sendUnits(sourceNode, targetNode) { if (!sourceNode || !targetNode || sourceNode === targetNode || sourceNode.unitCount < 1) return; let unitsToSend = 0; if (currentSendPercentage === 1.0 && sourceNode.unitCount > 1) { unitsToSend = sourceNode.unitCount - 1; } else { unitsToSend = Math.floor(sourceNode.unitCount * currentSendPercentage); if (unitsToSend === 0 && sourceNode.unitCount >= 1 && currentSendPercentage > 0) unitsToSend = 1; } unitsToSend = Math.min(unitsToSend, sourceNode.unitCount); if (unitsToSend <= 0) return; sourceNode.unitCount -= unitsToSend; for (let i = 0; i < unitsToSend; i++) { const angle = Math.random() * Math.PI * 2; const radiusOffset = Math.random() * sourceNode.radius * 0.5; const startX = sourceNode.x + Math.cos(angle) * radiusOffset; const startY = sourceNode.y + Math.sin(angle) * radiusOffset; units.push(new Unit(startX, startY, targetNode, sourceNode.owner)); } }
            function clearSelection(keepInteractionState = false) { selectedNodes.forEach(node => node.isSelected = false); selectedNodes = []; if (!keepInteractionState) { interaction.isInteractingNode = false; canvas.classList.remove('interacting-node'); canvas.style.cursor = 'default'; } activeNodeButtons = []; updateMessage(); }
            function setActivePercentageButton() { percentageButtonsContainer.querySelectorAll('button').forEach(button => { if (parseFloat(button.getAttribute('data-percent')) === currentSendPercentage) button.classList.add('active'); else button.classList.remove('active'); }); updateMessage(); }
            function runAIForPlayer(aiOwnerId, currentTime) { const aiNodes = nodes.filter(n => n.owner === aiOwnerId); const enemyNodes = nodes.filter(n => n.owner === PLAYER || (n.owner >= 2 && n.owner !== aiOwnerId)); const neutralNodes = nodes.filter(n => n.owner === NEUTRAL); const nonAiOwnedNodes = enemyNodes.concat(neutralNodes); if (aiNodes.length === 0 || nonAiOwnedNodes.length === 0) return; let potentialActions = []; const isExpert = aiDifficultySetting === 'expert'; const isBasic = aiDifficultySetting === 'basic'; aiNodes.forEach(node => { if (!node) return; if (node.level < MAX_NODE_LEVEL) { const cost = calculateUpgradeCost(node); if (cost !== Infinity) { let upgradeThreshold = isExpert ? 0.75 : 0.7; let costMultiplier = isBasic ? 1.8 : 1.6; if (node.unitCount > cost * costMultiplier || (node.unitCount > node.getMaxCapacity() * upgradeThreshold && node.unitCount >= cost)) { let score = 10 + node.level * 5 + (node.unitCount / node.getMaxCapacity()) * 15; if (isExpert) score *= 1.1; potentialActions.push({ type: 'upgrade', node: node, score: score }); } } } let buildSatThreshold = isBasic ? 0.6 : 0.5; if (node.satellites.length < MAX_SATELLITES_PER_NODE && node.unitCount >= SATELLITE_COST * 1.5 && node.unitCount > node.getMaxCapacity() * buildSatThreshold) { let score = 15 + (MAX_SATELLITES_PER_NODE - node.satellites.length) * 6; if (isExpert) score *= 1.1; potentialActions.push({ type: 'build_satellite', node: node, score: score }); } }); aiNodes.forEach(sourceNode => { if (!sourceNode) return; let minAttackUnits = isBasic ? 20 : 15; if (sourceNode.unitCount > minAttackUnits) { nonAiOwnedNodes.forEach(targetNode => { if (!targetNode) return; const unitsToSendIA = Math.floor(sourceNode.unitCount * (isExpert ? 0.55 : 0.5)); if (unitsToSendIA <= 0) return; let score = 0; const dist = Math.hypot(sourceNode.x - targetNode.x, sourceNode.y - targetNode.y); const playerLevelBonus = isExpert ? 15 : 12; const targetStrength = targetNode.unitCount + (targetNode.owner === PLAYER ? targetNode.level * playerLevelBonus : (targetNode.owner >= 2 ? targetNode.level * 6 : 0)); const advantageRatio = unitsToSendIA / Math.max(1, targetStrength); let baseNeutralScore = isBasic ? 150 : 160; let distPenalty = isBasic ? 0.20 : 0.18; if (targetNode.owner === NEUTRAL) { score = baseNeutralScore - targetStrength - dist * distPenalty; } else { let requiredAdvantage = isBasic ? 1.35 : (isExpert ? 1.15 : 1.25); let scoreMultiplier = isExpert ? 1.7 : 1.6; if (advantageRatio > requiredAdvantage) { score = 110 + (unitsToSendIA - targetStrength) * scoreMultiplier - dist * (distPenalty - 0.06); } else if (advantageRatio > (isBasic ? 0.8 : 0.7)) { score = (isBasic ? 30 : 35) - dist * distPenalty; } if(targetNode.owner === PLAYER) score *= (isExpert ? 1.35 : (isBasic ? 1.05 : 1.15)); } let randomFactor = isExpert ? (Math.random() * 0.2 + 0.9) : (isBasic ? (Math.random() * 0.4 + 0.8) : (Math.random() * 0.3 + 0.85)); score *= randomFactor; let scoreThreshold = isBasic ? 10 : 8; if (score > scoreThreshold) { potentialActions.push({ type: 'attack', source: sourceNode, target: targetNode, score: score }); } }); } }); aiNodes.forEach(sourceNode => { if (!sourceNode) return; let reinforceThreshold = isBasic ? 0.7 : 0.65; if (sourceNode.unitCount > sourceNode.getMaxCapacity() * reinforceThreshold ) { aiNodes.forEach(targetNode => { if (!targetNode) return; let targetEmptyThreshold = isExpert ? 0.5 : 0.45; if (sourceNode !== targetNode && targetNode.unitCount < targetNode.getMaxCapacity() * targetEmptyThreshold ) { const dist = Math.hypot(sourceNode.x - targetNode.x, sourceNode.y - targetNode.y); let reinforceRange = isBasic ? (WORLD_WIDTH / 4.0) : (WORLD_WIDTH / 3.5); if (dist < reinforceRange) { let score = (isBasic ? 20 : 25) - dist * (isBasic ? 0.02 : 0.015); potentialActions.push({ type: 'reinforce', source: sourceNode, target: targetNode, score: score }); } } }); } }); if (potentialActions.length > 0) { potentialActions.sort((a, b) => b.score - a.score); let choiceRandomness = isBasic ? 4 : (isExpert ? 2 : 3); const choiceIndex = Math.floor(Math.random() * Math.min(potentialActions.length, choiceRandomness)); const chosenAction = potentialActions[choiceIndex]; try { if (chosenAction.type === 'upgrade') { if (Math.random() < AI_UPGRADE_CHANCE) { chosenAction.node.attemptUpgrade(); } } else if (chosenAction.type === 'build_satellite') { chosenAction.node.attemptBuildSatellite(); } else if (chosenAction.type === 'attack' || chosenAction.type === 'reinforce') { if (chosenAction.source && chosenAction.target) { const unitsToSendIA = Math.floor(chosenAction.source.unitCount / 2); if (unitsToSendIA > 0) { chosenAction.source.unitCount -= unitsToSendIA; for (let i = 0; i < unitsToSendIA; i++) { const angle = Math.random()*Math.PI*2; const rOff = Math.random()*chosenAction.source.radius*0.5; const startX = chosenAction.source.x + Math.cos(angle) * rOff; const startY = chosenAction.source.y + Math.sin(angle) * rOff; units.push(new Unit(startX, startY, chosenAction.target, aiOwnerId)); } } } } } catch (error) { console.error(`AI ${aiOwnerId}: Error executing action ${chosenAction.type}:`, error); } } }
            function updateAI(currentTime) { if (currentTime - lastAiActionTime >= AI_ACTION_INTERVAL) { lastAiActionTime = currentTime; for (let i = 0; i < NUM_ENEMIES_SETTING; i++) { runAIForPlayer(2 + i, currentTime); } } }
            function checkWinCondition() { if (!gameRunning) return; const playerNodesExist = nodes.some(n => n.owner === PLAYER); const aiNodesExist = nodes.some(n => n.owner >= 2); let titleKey = ''; if (!aiNodesExist && playerNodesExist) { titleKey = 'victory'; } else if (!playerNodesExist && aiNodesExist) { titleKey = 'defeat'; } else if (!playerNodesExist && !aiNodesExist && nodes.some(n => n.owner === NEUTRAL)) { titleKey = 'tie'; } if (titleKey) { console.log(`--- Game Over: ${titleKey} ---`); gameOverTitle.textContent = getText(titleKey); gameOverMessageDiv.style.display = 'block'; gameRunning = false; clearSelection(); controlSound(); } }
            function update(currentTime) { if (!gameRunning || !spatialGrid) return; const deltaTime = currentTime - (lastGenerationTime || currentTime); if (deltaTime <= 0) { lastGenerationTime = currentTime; return; } lastGenerationTime = currentTime; spatialGrid.clear(); for (const unit of units) { if (!unit.toBeRemoved) { unit.update(deltaTime); spatialGrid.add(unit); } } nodes.forEach(node => node.update(deltaTime)); for (let i = units.length - 1; i >= 0; i--) { const unit = units[i]; if (!unit || unit.toBeRemoved) continue; if (!unit.targetNode && !unit.interceptTargetUnit) { let closestEnemyUnit = null; let minEnemyDistSq = SATELLITE_RANGE * SATELLITE_RANGE * 0.5; const nearbyUnits = spatialGrid.getNearbyUnits(unit); for (const otherUnit of nearbyUnits) { if (!otherUnit || otherUnit === unit || otherUnit.owner === unit.owner || otherUnit.owner === NEUTRAL || otherUnit.toBeRemoved) continue; const dx = otherUnit.x - unit.x; const dy = otherUnit.y - unit.y; const distSq = dx * dx + dy * dy; if (distSq < minEnemyDistSq) { minEnemyDistSq = distSq; closestEnemyUnit = otherUnit; } } if (closestEnemyUnit) { unit.interceptTargetUnit = closestEnemyUnit; } } const nearbyUnitsForCollision = spatialGrid.getNearbyUnits(unit); for (const otherUnit of nearbyUnitsForCollision) { if (!otherUnit || otherUnit === unit || otherUnit.owner === unit.owner || otherUnit.owner === NEUTRAL || otherUnit.toBeRemoved || unit.toBeRemoved) continue; const dx = otherUnit.x - unit.x; const dy = otherUnit.y - unit.y; const distSq = dx * dx + dy * dy; if (distSq <= UNIT_COLLISION_DIST_SQ) { spawnExplosion((unit.x + otherUnit.x)/2, (unit.y + otherUnit.y)/2, unit.getColor(), EXPLOSION_PARTICLE_COUNT, 1.0); spawnExplosion((unit.x + otherUnit.x)/2, (unit.y + otherUnit.y)/2, otherUnit.getColor(), EXPLOSION_PARTICLE_COUNT, 1.0); otherUnit.toBeRemoved = true; unit.toBeRemoved = true; break; } } if (unit.toBeRemoved) continue; if (unit.targetNode && !unit.interceptTargetUnit) { const dx = unit.targetNode.x - unit.x; const dy = unit.targetNode.y - unit.y; const distSq = dx * dx + dy * dy; const arrivalRadiusSq = Math.pow(unit.targetNode.radius * 0.95, 2); if (distSq <= arrivalRadiusSq) { unit.onArrival(); unit.toBeRemoved = true; } } if (unit.interceptTargetUnit && !unit.interceptTargetUnit.toBeRemoved) { const dx = unit.interceptTargetUnit.x - unit.x; const dy = unit.interceptTargetUnit.y - unit.y; const distSq = dx * dx + dy * dy; if (distSq <= UNIT_COLLISION_DIST_SQ * 0.8) { spawnExplosion((unit.x + unit.interceptTargetUnit.x)/2, (unit.y + unit.interceptTargetUnit.y)/2, unit.getColor(), EXPLOSION_PARTICLE_COUNT, 1.0); spawnExplosion((unit.x + unit.interceptTargetUnit.x)/2, (unit.y + unit.interceptTargetUnit.y)/2, unit.interceptTargetUnit.getColor(), EXPLOSION_PARTICLE_COUNT, 1.0); unit.interceptTargetUnit.toBeRemoved = true; unit.toBeRemoved = true; unit.interceptTargetUnit = null; } } if (!unit.targetNode && !unit.interceptTargetUnit && !unit.toBeRemoved) { unit.toBeRemoved = true; } } units = units.filter(unit => unit && !unit.toBeRemoved); for (let i = particles.length - 1; i >= 0; i--) { if (particles[i].update(deltaTime)) { particles.splice(i, 1); } } updateAI(currentTime); activeLasers = activeLasers.filter(laser => laser.endTime > currentTime); }
            function drawStars() { ctx.save(); ctx.fillStyle = 'white'; stars.forEach(star => { const screenX = (star.x - cameraX * star.depth) * cameraZoom; const screenY = (star.y - cameraY * star.depth) * cameraZoom; const starScreenSize = star.size; if (screenX >= -starScreenSize && screenX <= canvas.width + starScreenSize && screenY >= -starScreenSize && screenY <= canvas.height + starScreenSize) { ctx.globalAlpha = star.alpha * Math.min(1, cameraZoom * 1.5); ctx.beginPath(); ctx.arc(screenX, screenY, starScreenSize * Math.min(1.5, cameraZoom * 1.1), 0, Math.PI * 2); ctx.fill(); } }); ctx.restore(); }
            function drawMinimap() { if (!MINIMAP_ENABLED) return; ctx.save(); const mapX = canvas.width - MINIMAP_WIDTH - MINIMAP_MARGIN; const mapY = MINIMAP_MARGIN; const scaleX = MINIMAP_WIDTH / WORLD_WIDTH; const scaleY = MINIMAP_HEIGHT / WORLD_HEIGHT; ctx.fillStyle = 'rgba(10, 10, 30, 0.75)'; ctx.fillRect(mapX - 2, mapY - 2, MINIMAP_WIDTH + 4, MINIMAP_HEIGHT + 4); ctx.strokeStyle = 'rgba(100, 120, 180, 0.7)'; ctx.lineWidth = 1.5; ctx.strokeRect(mapX - 2, mapY - 2, MINIMAP_WIDTH + 4, MINIMAP_HEIGHT + 4); nodes.forEach(node => { const nodeMapX = mapX + node.x * scaleX; const nodeMapY = mapY + node.y * scaleY; ctx.fillStyle = node.getColor(); ctx.beginPath(); ctx.arc(nodeMapX, nodeMapY, MINIMAP_NODE_SIZE, 0, Math.PI * 2); ctx.fill(); }); const viewMapX = mapX + cameraX * scaleX; const viewMapY = mapY + cameraY * scaleY; const viewMapW = (canvas.width / cameraZoom) * scaleX; const viewMapH = (canvas.height / cameraZoom) * scaleY; ctx.strokeStyle = MINIMAP_CAMERA_COLOR; ctx.lineWidth = 2.0; ctx.strokeRect(viewMapX, viewMapY, viewMapW, viewMapH); ctx.restore(); }
            function drawInteractionIndicatorsAndButtons() { activeNodeButtons = []; let targetScreenX = null; let targetScreenY = null; let drawLinesAndMarker = false; if (interaction.isInteractingNode && interaction.pointers.size > 0 && !interaction.isPanning && interaction.currentPointerScreenPos.x !== null) { targetScreenX = interaction.currentPointerScreenPos.x; targetScreenY = interaction.currentPointerScreenPos.y; drawLinesAndMarker = selectedNodes.length > 0; } else if (selectedNodes.length > 0 && ambientPointerScreenPos.x !== null) { targetScreenX = ambientPointerScreenPos.x; targetScreenY = ambientPointerScreenPos.y; drawLinesAndMarker = true; } if (drawLinesAndMarker) { ctx.save(); ctx.strokeStyle = SELECTED_COLOR; ctx.lineWidth = SELECTION_LINE_WIDTH; ctx.setLineDash([6, 6]); selectedNodes.forEach(node => { const nodeScreenPos = worldToScreen(node.x, node.y); ctx.beginPath(); ctx.moveTo(nodeScreenPos.x, nodeScreenPos.y); ctx.lineTo(targetScreenX, targetScreenY); ctx.stroke(); }); ctx.setLineDash([]); ctx.fillStyle = SELECTED_COLOR; ctx.shadowBlur = 0; ctx.beginPath(); ctx.arc(targetScreenX, targetScreenY, POINTER_MARKER_RADIUS, 0, Math.PI * 2); ctx.fill(); ctx.restore(); } else if (interaction.isBoxSelecting && interaction.currentPointerScreenPos.x !== null) { ctx.save(); ctx.fillStyle = BOX_SELECT_COLOR; ctx.strokeStyle = SELECTED_COLOR; ctx.lineWidth = 1.5; ctx.setLineDash([4, 4]); const sx = interaction.boxStartScreenX; const sy = interaction.boxStartScreenY; const cx = interaction.currentPointerScreenPos.x; const cy = interaction.currentPointerScreenPos.y; ctx.fillRect(sx, sy, cx - sx, cy - sy); ctx.strokeRect(sx, sy, cx - sx, cy - sy); ctx.restore(); } if (selectedNodes.length === 1 && selectedNodes[0].owner === PLAYER) { const node = selectedNodes[0]; const nodeScreenPos = worldToScreen(node.x, node.y); const nodeScreenRadius = node.radius * cameraZoom; const buttonSize = 42; const buttonMargin = 12; const buttonExtraSpacing = 20; const baseButtonYOffset = nodeScreenRadius + buttonMargin + buttonExtraSpacing + buttonSize / 2; let initialButtonY = nodeScreenPos.y + baseButtonYOffset; const buttonHalfHeight = buttonSize / 2; const buttonHalfWidth = buttonSize / 2; const buttonTopMargin = 5; const buttonSideMargin = 5; const buttonsToDrawInfo = []; const upgradeCost = calculateUpgradeCost(node); const canUpgrade = upgradeCost !== Infinity && node.unitCount >= upgradeCost; if (upgradeCost !== Infinity) { buttonsToDrawInfo.push({ action: 'upgrade', icon: '⬆️', enabled: canUpgrade, color: canUpgrade ? 'rgba(0, 200, 0, 0.85)' : 'rgba(70, 70, 70, 0.8)' }); } const canBuildSatellite = node.satellites.length < MAX_SATELLITES_PER_NODE && node.unitCount >= SATELLITE_COST; if (node.satellites.length < MAX_SATELLITES_PER_NODE) { buttonsToDrawInfo.push({ action: 'build_satellite', icon: '🛰️', enabled: canBuildSatellite, color: canBuildSatellite ? 'rgba(0, 150, 220, 0.85)' : 'rgba(70, 70, 70, 0.8)' }); } if (buttonsToDrawInfo.length === 0) return; let finalButtonY = initialButtonY; if (initialButtonY + buttonHalfHeight > canvas.height) { finalButtonY = nodeScreenPos.y - baseButtonYOffset; if (finalButtonY - buttonHalfHeight < buttonTopMargin) { finalButtonY = buttonTopMargin + buttonHalfHeight; } } const totalWidth = buttonsToDrawInfo.length * buttonSize + (buttonsToDrawInfo.length - 1) * buttonMargin; let startX = nodeScreenPos.x - totalWidth / 2; const endX = startX + totalWidth; if (endX > canvas.width - buttonSideMargin) { startX -= (endX - (canvas.width - buttonSideMargin)); } if (startX < buttonSideMargin) { startX = buttonSideMargin; } ctx.save(); ctx.font = `${buttonSize * 0.55}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.lineWidth = 2.0; let currentButtonX = startX + buttonHalfWidth; buttonsToDrawInfo.forEach(buttonInfo => { const buttonRect = { x: currentButtonX - buttonHalfWidth, y: finalButtonY - buttonHalfHeight, width: buttonSize, height: buttonSize }; ctx.fillStyle = buttonInfo.color; ctx.fillRect(buttonRect.x, buttonRect.y, buttonRect.width, buttonRect.height); ctx.strokeStyle = buttonInfo.enabled ? 'rgba(230, 230, 230, 0.9)' : 'rgba(140, 140, 140, 0.7)'; ctx.strokeRect(buttonRect.x, buttonRect.y, buttonRect.width, buttonRect.height); ctx.globalAlpha = buttonInfo.enabled ? 1.0 : 0.6; ctx.fillStyle = 'white'; ctx.fillText(buttonInfo.icon, currentButtonX, finalButtonY + buttonSize * 0.05); ctx.globalAlpha = 1.0; if (buttonInfo.enabled) { activeNodeButtons.push({ rect: buttonRect, action: buttonInfo.action, node: node }); } currentButtonX += buttonSize + buttonMargin; }); ctx.restore(); } }
            function drawLasers() { if (activeLasers.length === 0) return; ctx.save(); ctx.lineWidth = 2.5; ctx.globalAlpha = 0.85; activeLasers.forEach(laser => { ctx.strokeStyle = laser.ownerColor; const startScreen = worldToScreen(laser.fromX, laser.fromY); const endScreen = worldToScreen(laser.toX, laser.toY); ctx.shadowBlur = 8; ctx.shadowColor = laser.ownerColor.replace('1)', '0.6)'); ctx.beginPath(); ctx.moveTo(startScreen.x, startScreen.y); ctx.lineTo(endScreen.x, endScreen.y); ctx.stroke(); ctx.shadowBlur = 0; }); ctx.restore(); }
            function draw() { ctx.fillStyle = '#03030A'; ctx.fillRect(0, 0, canvas.width, canvas.height); drawStars(); ctx.save(); ctx.scale(cameraZoom, cameraZoom); ctx.translate(-cameraX, -cameraY); particles.forEach(p => p.draw()); units.forEach(unit => unit.draw()); nodes.forEach(node => node.draw()); ctx.restore(); drawLasers(); drawInteractionIndicatorsAndButtons(); drawMinimap(); }
            function gameLoop(timestamp) { update(timestamp || 0); draw(); animationFrameId = requestAnimationFrame(gameLoop); }

            // --- Funciones de Coordenadas y Cámara ---
            // ... (sin cambios) ...
            function screenToWorld(screenX, screenY) { const worldX = (screenX / cameraZoom) + cameraX; const worldY = (screenY / cameraZoom) + cameraY; return { x: worldX, y: worldY }; }
            function worldToScreen(worldX, worldY) { const screenX = (worldX - cameraX) * cameraZoom; const screenY = (worldY - cameraY) * cameraZoom; return { x: screenX, y: screenY }; }
            function clampCamera() { const viewWidthWorld = canvas.width / cameraZoom; const viewHeightWorld = canvas.height / cameraZoom; cameraX = Math.max(0, Math.min(cameraX, WORLD_WIDTH - viewWidthWorld)); cameraY = Math.max(0, Math.min(cameraY, WORLD_HEIGHT - viewHeightWorld)); if (isNaN(cameraX)) cameraX = 0; if (isNaN(cameraY)) cameraY = 0; }
            function zoomAtPoint(screenX, screenY, zoomFactor) { const worldPos = screenToWorld(screenX, screenY); const currentMinZoom = Math.max(minZoomToFitWorld, ABSOLUTE_MIN_ZOOM); const newZoom = Math.max(currentMinZoom, Math.min(MAX_ZOOM, cameraZoom * zoomFactor)); if (newZoom === cameraZoom) return; cameraX = worldPos.x - (screenX / newZoom); cameraY = worldPos.y - (screenY / newZoom); cameraZoom = newZoom; clampCamera(); }

            // --- Funciones de Interacción ---
            // ... (sin cambios lógicos) ...
            function findClosestNode(worldX, worldY) { let closestNode = null; let minDistanceSq = TOUCH_SEARCH_RADIUS_WORLD * TOUCH_SEARCH_RADIUS_WORLD / (cameraZoom * cameraZoom); for (const node of nodes) { const dx = worldX - node.x; const dy = worldY - node.y; const distSq = dx * dx + dy * dy; const nodeRadius = node.radius; if (distSq < nodeRadius * nodeRadius || distSq < minDistanceSq) { if (distSq < nodeRadius * nodeRadius) { if (!closestNode || distSq < Math.pow(worldX - closestNode.x, 2) + Math.pow(worldY - closestNode.y, 2)) { closestNode = node; minDistanceSq = distSq; } } else if (!closestNode || distSq < minDistanceSq) { closestNode = node; minDistanceSq = distSq; } } } return closestNode; }
            function getPointerInfo(event) { const rect = canvas.getBoundingClientRect(); const pointers = []; const source = event.touches || [event]; for (let i = 0; i < source.length; i++) { const p = source[i]; const id = p.identifier ?? p.pointerId ?? 0; const screenX = p.clientX - rect.left; const screenY = p.clientY - rect.top; pointers.push({ id: id, screenX: screenX, screenY: screenY, ...screenToWorld(screenX, screenY), pointerType: event.pointerType || (event.touches ? 'touch' : 'mouse'), button: event.button }); } return pointers; }
            function getDistance(p1, p2) { const dx = p1.screenX - p2.screenX; const dy = p1.screenY - p2.screenY; return Math.sqrt(dx * dx + dy * dy); }
            function getMidpoint(p1, p2) { return { screenX: (p1.screenX + p2.screenX) / 2, screenY: (p1.screenY + p2.screenY) / 2 }; }
            function handleAmbientPointerMove(event) { if (!gameRunning && startScreenDiv.style.display === 'flex') return; const rect = canvas.getBoundingClientRect(); ambientPointerScreenPos.x = event.clientX - rect.left; ambientPointerScreenPos.y = event.clientY - rect.top; }
            function handleAmbientPointerLeave(event) { ambientPointerScreenPos.x = null; ambientPointerScreenPos.y = null; }
            function handlePointerDown(event) { if (!gameRunning && interaction.pointers.size === 0 && startScreenDiv.style.display === 'flex') return; handleFirstInteraction(); event.preventDefault(); canvas.setPointerCapture?.(event.pointerId); const currentPointers = getPointerInfo(event); const time = performance.now(); const pointer = currentPointers[0]; const screenX = pointer.screenX; const screenY = pointer.screenY; let clickedButton = null; for (const button of activeNodeButtons) { if (screenX >= button.rect.x && screenX <= button.rect.x + button.rect.width && screenY >= button.rect.y && screenY <= button.rect.y + button.rect.height) { clickedButton = button; break; } } if (clickedButton) { if (clickedButton.action === 'upgrade') { clickedButton.node.attemptUpgrade(); } else if (clickedButton.action === 'build_satellite') { clickedButton.node.attemptBuildSatellite(); } interaction.pointers.set(pointer.id, { id: pointer.id, isButtonPress: true, downTime: time }); return; } if (interaction.isInteractingNode && selectedNodes.length > 0 && interaction.pointers.size === 0) { const targetNode = findClosestNode(pointer.x, pointer.y); if (targetNode) { const canSend = !(selectedNodes.length === 1 && selectedNodes[0] === targetNode); if (canSend) { selectedNodes.forEach(sourceNode => { if (sourceNode !== targetNode) sendUnits(sourceNode, targetNode); }); } clearSelection(); } else { clearSelection(); } interaction.pointers.set(pointer.id, { id: pointer.id, downTime: time }); return; } interaction.isPanning = false; interaction.isPinching = false; interaction.isBoxSelecting = false; interaction.isInteractingNode = false; canvas.classList.remove('grabbing', 'panning', 'box-selecting', 'interacting-node'); currentPointers.forEach(p => { if (!interaction.pointers.has(p.id)) { const downNode = findClosestNode(p.x, p.y); interaction.pointers.set(p.id, { id: p.id, screenX: p.screenX, screenY: p.screenY, initialScreenX: p.screenX, initialScreenY: p.screenY, x: p.x, y: p.y, downTime: time, downNode: downNode, pointerType: p.pointerType, button: p.button, isButtonPress: false }); interaction.currentPointerScreenPos = { x: p.screenX, y: p.screenY }; interaction.boxStartScreenX = p.screenX; interaction.boxStartScreenY = p.screenY; } }); const numActivePointers = Array.from(interaction.pointers.values()).filter(p => !p.isButtonPress).length; if (numActivePointers === 1) { const firstPointerData = interaction.pointers.get(pointer.id); if (firstPointerData && firstPointerData.downNode && firstPointerData.downNode.owner === PLAYER) { interaction.lastTappedNodeForDoubleTap = firstPointerData.downNode; } else { interaction.lastTappedNodeForDoubleTap = null; } interaction.lastTapTime = time; } else if (numActivePointers === 2) { const pointersArray = Array.from(interaction.pointers.values()).filter(p => !p.isButtonPress); interaction.pinchInitialDistance = getDistance(pointersArray[0], pointersArray[1]); interaction.isPinching = true; interaction.isPanning = true; clearSelection(); canvas.classList.add('panning', 'grabbing'); } }
            function handlePointerMove(event) { if ((!gameRunning && startScreenDiv.style.display === 'flex') || interaction.pointers.size === 0) return; event.preventDefault(); const currentPointers = getPointerInfo(event); currentPointers.forEach(p => { if (interaction.pointers.has(p.id)) { const storedPointer = interaction.pointers.get(p.id); if(storedPointer.isButtonPress) return; storedPointer.screenX = p.screenX; storedPointer.screenY = p.screenY; storedPointer.x = p.x; storedPointer.y = p.y; if(p.id === Array.from(interaction.pointers.keys())[0]) { interaction.currentPointerScreenPos = { x: p.screenX, y: p.screenY }; } } }); const activePointers = Array.from(interaction.pointers.values()).filter(p => !p.isButtonPress); const numActivePointers = activePointers.length; if (numActivePointers === 1) { const pointer = activePointers[0]; const dxScreen = pointer.screenX - pointer.initialScreenX; const dyScreen = pointer.screenY - pointer.initialScreenY; const distSqScreen = dxScreen * dxScreen + dyScreen * dyScreen; const hasMovedSignificantly = distSqScreen >= DRAG_THRESHOLD_FOR_ACTION * DRAG_THRESHOLD_FOR_ACTION; if (!interaction.isPanning && !interaction.isBoxSelecting && !interaction.isInteractingNode && hasMovedSignificantly) { if (pointer.button === 2) { interaction.isPanning = true; clearSelection(); } else if (pointer.downNode && pointer.downNode.owner === PLAYER) { interaction.isInteractingNode = true; if (!selectedNodes.includes(pointer.downNode)) { clearSelection(true); pointer.downNode.isSelected = true; selectedNodes.push(pointer.downNode); updateMessage(); } } else { if (pointer.pointerType === 'touch') { interaction.isPanning = true; clearSelection(); } else { interaction.isBoxSelecting = true; clearSelection(); } } if(interaction.isPanning) { canvas.classList.add('panning', 'grabbing'); canvas.classList.remove('interacting-node', 'box-selecting'); } else if(interaction.isInteractingNode) { canvas.classList.add('interacting-node'); canvas.classList.remove('panning', 'grabbing', 'box-selecting'); } else if(interaction.isBoxSelecting) { canvas.classList.add('box-selecting'); canvas.classList.remove('panning', 'grabbing', 'interacting-node'); } } if (interaction.isPanning) { const deltaXScreen = pointer.screenX - pointer.initialScreenX; const deltaYScreen = pointer.screenY - pointer.initialScreenY; cameraX -= deltaXScreen / cameraZoom; cameraY -= deltaYScreen / cameraZoom; clampCamera(); pointer.initialScreenX = pointer.screenX; pointer.initialScreenY = pointer.screenY; if (!canvas.classList.contains('grabbing')) canvas.classList.add('grabbing'); } else if (interaction.isInteractingNode) { const nodeUnderPointer = findClosestNode(pointer.x, pointer.y); if (nodeUnderPointer && nodeUnderPointer.owner === PLAYER && !nodeUnderPointer.isSelected) { nodeUnderPointer.isSelected = true; selectedNodes.push(nodeUnderPointer); updateMessage(); } if (!canvas.classList.contains('interacting-node')) canvas.classList.add('interacting-node'); } else if (interaction.isBoxSelecting) { if (!canvas.classList.contains('box-selecting')) canvas.classList.add('box-selecting'); } } else if (numActivePointers === 2) { interaction.isInteractingNode = false; interaction.isBoxSelecting = false; interaction.isPanning = true; const p1 = activePointers[0]; const p2 = activePointers[1]; const newDist = getDistance(p1, p2); const midPoint = getMidpoint(p1, p2); if (interaction.pinchInitialDistance > 0 && newDist > 0) { const zoomFactor = newDist / interaction.pinchInitialDistance; zoomAtPoint(midPoint.screenX, midPoint.screenY, zoomFactor); } const p1Start = interaction.pointers.get(p1.id); const p2Start = interaction.pointers.get(p2.id); if (!p1Start || !p2Start) return; const initialMidPoint = getMidpoint(p1Start, p2Start); const deltaXScreen = midPoint.screenX - initialMidPoint.screenX; const deltaYScreen = midPoint.screenY - initialMidPoint.screenY; cameraX -= deltaXScreen / cameraZoom; cameraY -= deltaYScreen / cameraZoom; clampCamera(); interaction.pinchInitialDistance = newDist; p1Start.initialScreenX = p1.screenX; p1Start.initialScreenY = p1.screenY; p2Start.initialScreenX = p2.screenX; p2Start.initialScreenY = p2.screenY; canvas.classList.add('panning', 'grabbing'); canvas.classList.remove('interacting-node', 'box-selecting'); } }
            function handlePointerUp(event) { if (!gameRunning && gameOverMessageDiv.style.display === 'block') { initializeApp(); return; } handleFirstInteraction(); event.preventDefault(); const pointerId = event.identifier ?? event.pointerId ?? 0; const pointerData = interaction.pointers.get(pointerId); if (pointerData) { if (pointerData.isButtonPress) { interaction.pointers.delete(pointerId); } else { const time = performance.now(); const duration = time - pointerData.downTime; const dx = pointerData.screenX - pointerData.initialScreenX; const dy = pointerData.screenY - pointerData.initialScreenY; const distSq = dx * dx + dy * dy; const hasMovedSignificantly = distSq >= TAP_MOVEMENT_THRESHOLD * TAP_MOVEMENT_THRESHOLD; const isTap = !interaction.isPanning && !interaction.isBoxSelecting && !interaction.isInteractingNode && duration < TAP_DURATION_THRESHOLD && !hasMovedSignificantly; const isDragSelectEnd = interaction.isInteractingNode && !interaction.isPanning; const isBoxSelectEnd = interaction.isBoxSelecting; const nodeAtPointerUp = findClosestNode(pointerData.x, pointerData.y); if (isBoxSelectEnd) { const boxP1World = screenToWorld(interaction.boxStartScreenX, interaction.boxStartScreenY); const boxP2World = screenToWorld(pointerData.screenX, pointerData.screenY); const minX = Math.min(boxP1World.x, boxP2World.x); const maxX = Math.max(boxP1World.x, boxP2World.x); const minY = Math.min(boxP1World.y, boxP2World.y); const maxY = Math.max(boxP1World.y, boxP2World.y); clearSelection(true); nodes.forEach(node => { if (node.owner === PLAYER && node.x >= minX && node.x <= maxX && node.y >= minY && node.y <= maxY) { node.isSelected = true; selectedNodes.push(node); } }); updateMessage(); interaction.isInteractingNode = selectedNodes.length > 0; } else if (isDragSelectEnd) { if (nodeAtPointerUp && selectedNodes.length > 0) { const canSend = !(selectedNodes.length === 1 && selectedNodes[0] === nodeAtPointerUp); if (canSend) { selectedNodes.forEach(sourceNode => { if (sourceNode !== nodeAtPointerUp) sendUnits(sourceNode, nodeAtPointerUp); }); clearSelection(); } else { clearSelection(); } } else { interaction.isInteractingNode = selectedNodes.length > 0; } } else if (isTap) { if (pointerData.downNode && nodeAtPointerUp === pointerData.downNode) { if (pointerData.downNode.owner === PLAYER) { if (selectedNodes.includes(pointerData.downNode)) { clearSelection(); } else { clearSelection(true); pointerData.downNode.isSelected = true; selectedNodes.push(pointerData.downNode); } updateMessage(); interaction.isInteractingNode = selectedNodes.length > 0; activeNodeButtons = []; } else { clearSelection(); } } else { clearSelection(); } interaction.lastTapTime = time; interaction.lastTappedNodeForDoubleTap = pointerData.downNode; } interaction.pointers.delete(pointerId); } canvas.releasePointerCapture?.(pointerId); } const remainingPointersData = Array.from(interaction.pointers.values()).filter(p => !p.isButtonPress); const remainingActivePointers = remainingPointersData.length; if (remainingActivePointers === 0) { interaction.isPanning = false; interaction.isPinching = false; interaction.isBoxSelecting = false; interaction.pinchInitialDistance = 0; interaction.isInteractingNode = selectedNodes.length > 0; canvas.classList.remove('grabbing', 'panning', 'box-selecting'); if (!interaction.isInteractingNode) { interaction.currentPointerScreenPos = { x: null, y: null }; canvas.classList.remove('interacting-node'); canvas.style.cursor = 'default'; activeNodeButtons = []; } else { canvas.classList.add('interacting-node'); canvas.style.cursor = 'crosshair'; } } else if (remainingActivePointers === 1) { interaction.isPinching = false; interaction.pinchInitialDistance = 0; interaction.isBoxSelecting = false; const remainingPointerData = remainingPointersData[0]; if (remainingPointerData) { remainingPointerData.initialScreenX = remainingPointerData.screenX; remainingPointerData.initialScreenY = remainingPointerData.screenY; const nodeUnderRemaining = findClosestNode(remainingPointerData.x, remainingPointerData.y); if ((remainingPointerData.pointerType === 'touch' && (!nodeUnderRemaining || nodeUnderRemaining.owner !== PLAYER)) || remainingPointerData.button === 2) { interaction.isPanning = true; interaction.isInteractingNode = false; canvas.classList.add('panning', 'grabbing'); canvas.classList.remove('interacting-node', 'box-selecting'); } else { interaction.isPanning = false; interaction.isInteractingNode = selectedNodes.length > 0; canvas.classList.remove('panning', 'grabbing', 'box-selecting'); if(interaction.isInteractingNode) canvas.classList.add('interacting-node'); else canvas.style.cursor = 'default'; } } else { interaction.isPanning = false; interaction.isInteractingNode = selectedNodes.length > 0; canvas.classList.remove('panning', 'grabbing', 'box-selecting'); if(interaction.isInteractingNode) canvas.classList.add('interacting-node'); else canvas.style.cursor = 'default'; } } }
            function handlePointerOut(e) { const pointerData = interaction.pointers.get(e.pointerId ?? 0); if (pointerData && pointerData.button !== 2 && !pointerData.isButtonPress) { handlePointerUp(e); } }
            function preventContextMenu(e) { e.preventDefault(); }
            function handleWheel(e) { if (!gameRunning && startScreenDiv.style.display === 'flex') return; handleFirstInteraction(); e.preventDefault(); const zoomFactor = e.deltaY < 0 ? 1.15 : 1 / 1.15; const rect = canvas.getBoundingClientRect(); const screenX = e.clientX - rect.left; const screenY = e.clientY - rect.top; zoomAtPoint(screenX, screenY, zoomFactor); }
            // *** handleResize MODIFICADO ***
            function handleResize() {
                console.log("Window resized.");
                // Solo ajustar canvas y cámara, no reiniciar todo
                if (canvas) { // Asegurar que el canvas existe
                    resizeCanvas();
                    if(gameRunning) {
                        updateMessage(); // Actualizar mensaje si el juego está corriendo
                    }
                } else {
                    console.warn("Canvas not ready during resize event.");
                }
            }
            function handleGameOverClick() { if (gameOverMessageDiv.style.display === 'block') { console.log("Game over message clicked - Restarting."); initializeApp(); } }

            // --- Inicialización y Listeners ---
            function initializeApp() {
                gameContainer.style.display = 'none';
                introVideoContainer.style.display = 'none'; // Asegura que el vídeo esté oculto al inicio/menú
                startScreenDiv.style.display = 'flex';
                if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
                gameRunning = false;
                removeGameListeners();
                interaction = { pointers: new Map(), isPanning: false, isPinching: false, isInteractingNode: false, isBoxSelecting: false, currentPointerScreenPos: { x: null, y: null } };
                selectedNodes = []; activeNodeButtons = []; activeLasers = []; particles = []; units = []; nodes = [];
                ambientPointerScreenPos = { x: null, y: null }; spatialGrid = null;
                gameOverMessageDiv.style.display = 'none';
                console.log("App initialized, showing start screen.");
                firstInteractionDone = false;
                document.removeEventListener('pointerdown', handleFirstInteraction);
                document.removeEventListener('keydown', handleFirstInteraction);
                document.addEventListener('pointerdown', handleFirstInteraction);
                document.addEventListener('keydown', handleFirstInteraction);
                currentLanguage = languageSelect.value || 'ca';
                updateLanguage();
                soundEnabled = soundCheckbox.checked;
                controlSound();
                // Salir de pantalla completa si se vuelve al menú
                if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
                    if (document.exitFullscreen) { document.exitFullscreen().catch(err => console.warn("Exit fullscreen error:", err)); }
                    else if (document.webkitExitFullscreen) { document.webkitExitFullscreen(); }
                    else if (document.mozCancelFullScreen) { document.mozCancelFullScreen(); }
                    else if (document.msExitFullscreen) { document.msExitFullscreen(); }
                }
                // Resetear el vídeo por si se interrumpió
                if(introVideo) {
                    introVideo.pause();
                    introVideo.currentTime = 0;
                }
            }
            function addGameListeners() { /* ... (sin cambios) ... */ canvas.addEventListener('pointerdown', handlePointerDown); canvas.addEventListener('pointermove', handlePointerMove); canvas.addEventListener('pointerup', handlePointerUp); canvas.addEventListener('pointercancel', handlePointerUp); canvas.addEventListener('pointerout', handlePointerOut); canvas.addEventListener('contextmenu', preventContextMenu); canvas.addEventListener('wheel', handleWheel, { passive: false }); window.addEventListener('resize', handleResize); gameOverMessageDiv.addEventListener('click', handleGameOverClick); canvas.addEventListener('pointermove', handleAmbientPointerMove); canvas.addEventListener('pointerleave', handleAmbientPointerLeave); }
            function removeGameListeners() { /* ... (sin cambios) ... */ canvas.removeEventListener('pointerdown', handlePointerDown); canvas.removeEventListener('pointermove', handlePointerMove); canvas.removeEventListener('pointerup', handlePointerUp); canvas.removeEventListener('pointercancel', handlePointerUp); canvas.removeEventListener('pointerout', handlePointerOut); canvas.removeEventListener('contextmenu', preventContextMenu); canvas.removeEventListener('wheel', handleWheel); window.removeEventListener('resize', handleResize); gameOverMessageDiv.removeEventListener('click', handleGameOverClick); canvas.removeEventListener('pointermove', handleAmbientPointerMove); canvas.removeEventListener('pointerleave', handleAmbientPointerLeave); }
            function playIntroVideoFullScreen() { /* ... (sin cambios) ... */ if (!introVideo || !introVideoContainer) return; introVideoContainer.style.display = 'block'; const requestFullScreen = introVideoContainer.requestFullscreen || introVideoContainer.mozRequestFullScreen || introVideoContainer.webkitRequestFullscreen || introVideoContainer.msRequestFullscreen; if (requestFullScreen) { requestFullScreen.call(introVideoContainer).then(() => { console.log("Entered fullscreen for video"); introVideo.play().catch(e => console.error("Video play error after fullscreen:", e)); }).catch(err => { console.warn(`Error attempting fullscreen: ${err.message} (${err.name}). Playing video inline.`); introVideo.play().catch(e => console.error("Video play error (inline):", e)); }); } else { console.warn("Fullscreen API not fully supported. Playing video inline."); introVideo.play().catch(e => console.error("Video play error (no fullscreen API):", e)); } }

            // --- Setup Inicial y Listeners Permanentes ---
            startButton.addEventListener('click', () => { if (!imagesLoaded) { console.log("Waiting for images to load..."); return; } handleFirstInteraction(); const numNodesVal = parseInt(numNodesInput.value); const numEnemiesVal = parseInt(numEnemiesInput.value); aiDifficultySetting = aiDifficultySelect.value; if (isNaN(numNodesVal) || numNodesVal < parseInt(numNodesInput.min) || numNodesVal > parseInt(numNodesInput.max)) { alert(getText('invalidNodes', numNodesInput.min, numNodesInput.max)); return; } if (isNaN(numEnemiesVal) || numEnemiesVal < parseInt(numEnemiesInput.min) || numEnemiesVal > parseInt(numEnemiesInput.max)) { alert(getText('invalidEnemies', numEnemiesInput.min, numEnemiesInput.max)); return; } if (!['basic', 'normal', 'expert'].includes(aiDifficultySetting)) { aiDifficultySetting = 'normal'; console.warn("Invalid AI difficulty selected, defaulting to normal.");} NUM_NEUTRAL_NODES_SETTING = numNodesVal; NUM_ENEMIES_SETTING = numEnemiesVal; startScreenDiv.style.display = 'none'; playIntroVideoFullScreen(); });
            introVideo.addEventListener('ended', () => { console.log("Intro video finished."); if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) { if (document.exitFullscreen) { document.exitFullscreen().catch(err => console.warn("Exit fullscreen error:", err)); } else if (document.webkitExitFullscreen) { document.webkitExitFullscreen(); } else if (document.mozCancelFullScreen) { document.mozCancelFullScreen(); } else if (document.msExitFullscreen) { document.msExitFullscreen(); } } introVideoContainer.style.display = 'none'; gameContainer.style.display = 'flex'; canvas.style.display = 'block'; addGameListeners(); startGameLogic(); });
            percentageButtonsContainer.addEventListener('click', (event) => { if (event.target.tagName === 'BUTTON') { const percent = parseFloat(event.target.getAttribute('data-percent')); if (!isNaN(percent)) { currentSendPercentage = percent; setActivePercentageButton(); } } });
            menuButton.addEventListener('click', () => { console.log("Menu button clicked - Returning to start screen."); initializeApp(); });
            soundCheckbox.addEventListener('change', () => { handleFirstInteraction(); controlSound(); });
            languageSelect.addEventListener('change', (e) => { currentLanguage = e.target.value; updateLanguage(); });
            ambientAudio1.addEventListener('ended', () => { if (soundEnabled && currentAmbientTrack === ambientAudio1) { currentAmbientTrack = ambientAudio2; ambientAudio2.play().catch(e => console.warn("Ambient 2 play failed:", e)); } });
            ambientAudio2.addEventListener('ended', () => { if (soundEnabled && currentAmbientTrack === ambientAudio2) { currentAmbientTrack = ambientAudio1; ambientAudio1.play().catch(e => console.warn("Ambient 1 play failed:", e)); } });

            // --- Inicio ---
            preloadImages(() => {
                startButton.disabled = false;
                initializeApp(); // Initialize app state
            });

        }); // *** FIN DEL LISTENER DOMContentLoaded ***
    </script>

</body>
</html>
