<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Space Conquest v23.6.3</title> <!-- Título y Versión Corregida -->
    <style>
        /* CSS (sin cambios) */
        body { margin: 0; overflow: hidden; background-color: #000; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: sans-serif; flex-direction: column; color: #eee; }
        canvas { display: block; background-color: #05050f; touch-action: none; max-width: 100%; cursor: default; }
        canvas.panning { cursor: grab; }
        canvas.panning.grabbing { cursor: grabbing; }
        canvas.interacting-node { cursor: crosshair; }
        canvas.box-selecting { cursor: crosshair; }
        #gameContainer { position: relative; width: 100%; height: 100%; display: none; justify-content: center; align-items: center; }
        #controls { position: absolute; top: 5px; left: 5px; right: 5px; background-color: rgba(0,0,0,0.7); padding: 8px; border-radius: 5px; color: white; font-size: 13px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; z-index: 10; pointer-events: none; }
        #controls > * { pointer-events: auto; }
        #message { line-height: 1.3; margin-right: 10px; flex-grow: 1; }
        #percentageButtons { display: flex; align-items: center; white-space: nowrap; }
        #percentageButtons span { margin-right: 5px;}
        #percentageButtons button { padding: 4px 7px; margin-left: 3px; font-size: 12px; cursor: pointer; border: 1px solid #ccc; background-color: #555; color: white; border-radius: 3px; }
        #percentageButtons button.active { background-color: #007bff; border-color: #0056b3; font-weight: bold; }
        #gameOverMessage { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.85); color: white; padding: 30px 40px; border-radius: 10px; text-align: center; font-size: 22px; display: none; z-index: 20; }
        #gameOverMessage h2 { margin-top: 0; font-size: 28px; margin-bottom: 15px;}
        #gameOverMessage p { font-size: 18px; margin-bottom: 0; }
        #startScreen { background-color: #0a0a1a; color: #eee; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 30; text-align: center; padding: 20px; box-sizing: border-box; width: 100vw; height: 100vh; }
        #startScreen h1 { margin-top: 0; margin-bottom: 10px; color: #00aaff; font-size: clamp(2em, 8vw, 3.5em); text-shadow: 1px 1px 3px rgba(0, 100, 150, 0.8); }
        #startScreen .version { font-size: clamp(0.7em, 2vw, 0.9em); color: #aaa; margin-bottom: 25px; }
        #startScreen .author { margin-bottom: 30px; font-size: clamp(0.9em, 3vw, 1.1em); color: #ccc; }
        #startScreen .author a { color: #66ccff; text-decoration: none; }
        #startScreen .author a:hover { text-decoration: underline; }
        #startScreen .settings { background-color: rgba(255, 255, 255, 0.05); padding: 20px; border-radius: 8px; margin-bottom: 30px; max-width: 400px; width: 90%; }
        #startScreen .setting-item { margin-bottom: 15px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; }
        #startScreen label { margin-right: 10px; text-align: left; flex-basis: calc(60% - 10px); margin-bottom: 5px; font-size: clamp(0.9em, 2.5vw, 1em); }
        #startScreen input[type="number"] { width: 70px; padding: 8px; border-radius: 4px; border: 1px solid #555; background-color: #333; color: #eee; text-align: center; flex-basis: calc(35% - 10px); font-size: clamp(0.9em, 2.5vw, 1em); -moz-appearance: textfield; }
        #startScreen input[type=number]::-webkit-inner-spin-button,
        #startScreen input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        #startButton { padding: 12px 35px; font-size: clamp(1em, 4vw, 1.3em); cursor: pointer; background-color: #0088cc; color: white; border: none; border-radius: 5px; transition: background-color 0.2s ease; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); }
        #startButton:hover { background-color: #00aaff; }
    </style>
</head>
<body>
    <div id="startScreen">
        <h1>Space Conquest</h1>
        <div class="version">v23.6.3</div> <!-- Versión -->
        <p class="author">por <a href="https://www.linkedin.com/in/oriol-badia" target="_blank" rel="noopener noreferrer">Oriol Badia Campanera</a></p>
        <div class="settings">
            <div class="setting-item">
                <label for="numNodesInput">Nodos Neutrales (4-100):</label>
                <input type="number" id="numNodesInput" value="20" min="4" max="100">
            </div>
            <div class="setting-item">
                <label for="numEnemiesInput">Enemigos IA (1-5):</label>
                <input type="number" id="numEnemiesInput" value="1" min="1" max="5">
            </div>
        </div>
        <button id="startButton">Iniciar Juego</button>
    </div>

    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="controls">
            <div id="message">...</div>
            <div id="percentageButtons">
                <span>Enviar:</span>
                <button data-percent="0.25">25%</button>
                <button data-percent="0.50" class="active">50%</button>
                <button data-percent="0.75">75%</button>
                <button data-percent="1.00">100%</button>
            </div>
        </div>
        <div id="gameOverMessage">
            <h2 id="gameOverTitle"></h2>
            <p>Toca para reiniciar.</p>
        </div>
    </div>

<script>
    // --- Elementos del DOM ---
    const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d'); const messageDiv = document.getElementById('message'); const percentageButtonsContainer = document.getElementById('percentageButtons'); const gameOverMessageDiv = document.getElementById('gameOverMessage'); const gameOverTitle = document.getElementById('gameOverTitle'); const startScreenDiv = document.getElementById('startScreen'); const numNodesInput = document.getElementById('numNodesInput'); const numEnemiesInput = document.getElementById('numEnemiesInput'); const startButton = document.getElementById('startButton'); const gameContainer = document.getElementById('gameContainer');

    // --- Configuración ---
    const PLAYER = 1; const NEUTRAL = 0;
    const PLAYER_COLOR = 'rgba(0, 150, 255, 1)'; const AI_COLORS = ['rgba(255, 50, 50, 1)','rgba(50, 200, 50, 1)','rgba(255, 150, 0, 1)','rgba(200, 0, 200, 1)','rgba(255, 255, 50, 1)']; const NEUTRAL_COLOR = 'rgba(150, 150, 150, 1)'; const SELECTED_COLOR = 'rgba(255, 255, 0, 0.8)'; const ATTACK_INDICATOR_COLOR = 'rgba(255, 0, 0, 0.9)'; const BOX_SELECT_COLOR = 'rgba(0, 150, 255, 0.4)';
    const UNIT_RADIUS = 3.5; const NODE_RADIUS_BASE = 18; const NODE_RADIUS_PER_UNIT = 0.02; const NODE_RADIUS_PER_LEVEL = 2; const MAX_NODE_LEVEL = 5; const UNIT_CAPACITY_PER_LEVEL = 100; const GENERATION_INTERVAL = 1100; const UNIT_SPEED = 1.6;
    const AI_ACTION_INTERVAL = 1000; const AI_UPGRADE_CHANCE = 0.25;
    const SELECTION_LINE_WIDTH = 3.5; const POINTER_MARKER_RADIUS = 6; const ATTACK_INDICATOR_DURATION = 1500; const ATTACK_INDICATOR_BLINK_RATE = 250;
    const SATELLITE_COST = 50; const MAX_SATELLITES_PER_NODE = 5; const SATELLITE_ORBIT_RADIUS_BASE = 15; const SATELLITE_ORBIT_SPEED = 0.02; const SATELLITE_RADIUS = 4; const SATELLITE_RANGE = 150; const SATELLITE_FIRE_RATE_BASE = 200; const SATELLITE_LASER_DURATION = 100;
    const WORLD_WIDTH = 3000; const WORLD_HEIGHT = 2000; const MIN_NODE_DISTANCE = 85;
    let NUM_NEUTRAL_NODES_SETTING = 20; let NUM_ENEMIES_SETTING = 1;
    let cameraX = 0; let cameraY = 0; let cameraZoom = 0.6; let minZoomToFitWorld = 0.1; const ABSOLUTE_MIN_ZOOM = 0.1; const MAX_ZOOM = 2.0;
    const NUM_STARS = 1500; let stars = [];
    let nodes = []; let units = []; let selectedNodes = []; let particles = [];
    let currentSendPercentage = 0.50; let lastGenerationTime = 0; let lastAiActionTime = 0;
    let animationFrameId; let gameRunning = false; let activeLasers = [];
    let ambientPointerScreenPos = { x: null, y: null };
    let interaction = { pointers: new Map(), lastTapTime: 0, lastTappedNodeForDoubleTap: null, isInteractingNode: false, isPanning: false, isPinching: false, isBoxSelecting: false, pinchInitialDistance: 0, currentPointerScreenPos: { x: null, y: null }, boxStartScreenX: 0, boxStartScreenY: 0 };
    const DOUBLE_TAP_DELAY = 300; const TAP_DURATION_THRESHOLD = 250; const TAP_MOVEMENT_THRESHOLD = 10; const DRAG_THRESHOLD_FOR_ACTION = 15; const TOUCH_SEARCH_RADIUS_WORLD = 60;
    let activeNodeButtons = [];
    const MINIMAP_ENABLED = true; const MINIMAP_WIDTH = 150; const MINIMAP_HEIGHT = (MINIMAP_WIDTH / WORLD_WIDTH) * WORLD_HEIGHT; const MINIMAP_MARGIN = 10; const MINIMAP_NODE_SIZE = 3; const MINIMAP_CAMERA_COLOR = 'rgba(255, 255, 255, 0.6)';
    const UNIT_COLLISION_DIST_SQ = (UNIT_RADIUS * 1.8) * (UNIT_RADIUS * 1.8);

    // --- Clases ---
    class Particle { constructor(x, y, color) { this.x = x; this.y = y; this.color = color; this.radius = Math.random() * 1.8 + 0.8; this.life = 500 + Math.random() * 500; this.initialLife = this.life; this.alpha = 0.9; const angle = Math.random() * Math.PI * 2; const speed = Math.random() * 1.5 + 0.5; this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed; } update(deltaTime) { this.life -= deltaTime; if (this.life <= 0) return true; this.x += this.vx; this.y += this.vy; this.alpha = Math.max(0, (this.life / this.initialLife) * 0.9); this.vx *= 0.98; this.vy *= 0.98; return false; } draw() { ctx.save(); ctx.globalAlpha = this.alpha; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.restore(); } }
    function calculateUpgradeCost(node) { if (node.level >= MAX_NODE_LEVEL) return Infinity; const targetLevel = node.level + 1; const targetCapacity = targetLevel * UNIT_CAPACITY_PER_LEVEL; return Math.floor(targetCapacity / 2); }
    class Node {
        constructor(x, y, owner, initialUnits) { this.x = x; this.y = y; this.owner = owner; this.unitCount = initialUnits; this.level = 1; this.generationTimer = 0; this.isSelected = false; this.isUnderAttack = false; this.attackTimer = 0; this.satellites = []; this.targetedEnemyUnits = new Set(); }
        get radius() { return NODE_RADIUS_BASE + (this.level * NODE_RADIUS_PER_LEVEL) + this.unitCount * NODE_RADIUS_PER_UNIT; }
        getColor() { if (this.owner === PLAYER) return PLAYER_COLOR; if (this.owner === NEUTRAL) return NEUTRAL_COLOR; const aiIndex = this.owner - 2; return AI_COLORS[aiIndex % AI_COLORS.length]; }
        getMaxCapacity() { return this.level * UNIT_CAPACITY_PER_LEVEL; }
        draw() { const color = this.getColor(); const r = this.radius; ctx.shadowBlur = 15 + this.level * 2.5; ctx.shadowColor = color.replace('1)', '0.65)'); ctx.fillStyle = color; ctx.beginPath(); ctx.arc(this.x, this.y, r, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0; if (this.isSelected) { ctx.strokeStyle = SELECTED_COLOR; ctx.lineWidth = SELECTION_LINE_WIDTH / cameraZoom; ctx.beginPath(); ctx.arc(this.x, this.y, r + 5 / cameraZoom, 0, Math.PI * 2); ctx.stroke(); } if (this.isUnderAttack) { const blinkOn = Math.floor(performance.now() / ATTACK_INDICATOR_BLINK_RATE) % 2 === 0; if (blinkOn) { ctx.strokeStyle = ATTACK_INDICATOR_COLOR; ctx.lineWidth = (SELECTION_LINE_WIDTH + 2) / cameraZoom; ctx.beginPath(); ctx.arc(this.x, this.y, r + 8 / cameraZoom, 0, Math.PI * 2); ctx.stroke(); } } ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; const fontSize = Math.max(11, r * 0.6); ctx.font = `bold ${fontSize}px sans-serif`; ctx.fillText(Math.floor(this.unitCount), this.x, this.y - fontSize * 0.3); const levelFontSize = Math.max(9, r * 0.4); ctx.font = `${levelFontSize}px sans-serif`; if (this.owner !== NEUTRAL) { ctx.fillText(`Lvl ${this.level}`, this.x, this.y + fontSize * 0.45); } this.satellites.forEach(sat => sat.draw()); }
        update(deltaTime) { if (this.owner !== NEUTRAL && gameRunning) { const maxCapacity = this.getMaxCapacity(); if (this.unitCount < maxCapacity) { this.generationTimer += deltaTime; const effectiveInterval = GENERATION_INTERVAL / Math.pow(1.5, this.level - 1); if (this.generationTimer >= effectiveInterval) { const generations = Math.floor(this.generationTimer / effectiveInterval); this.unitCount = Math.min(maxCapacity, this.unitCount + generations); this.generationTimer %= effectiveInterval; } } else { this.generationTimer = 0; } } if (this.isUnderAttack) { this.attackTimer -= deltaTime; if (this.attackTimer <= 0) { this.isUnderAttack = false; } } this.satellites.forEach(sat => sat.update(deltaTime)); }
        attemptUpgrade() {
            // CORREGIDO: Permitir a la IA mejorar
            if (this.level >= MAX_NODE_LEVEL) return false;
            const cost = calculateUpgradeCost(this);
            if (this.unitCount >= cost) {
                this.unitCount -= cost; this.level++;
                if (this.owner === PLAYER) updateMessage(); // Actualizar UI solo para jugador
                console.log(`Node (owner ${this.owner}) upgraded to level ${this.level}`);
                return true;
            } else { return false; }
        }
        resetOnCapture() { this.level = 1; this.generationTimer = 0; this.isUnderAttack = false; this.attackTimer = 0; this.satellites = []; this.targetedEnemyUnits.clear(); }
        attemptBuildSatellite() {
            // CORREGIDO: Permitir a la IA construir
            if (this.satellites.length >= MAX_SATELLITES_PER_NODE) return false;
            if (this.unitCount >= SATELLITE_COST) {
                this.unitCount -= SATELLITE_COST; const newSatellite = new Satellite(this, 0); this.satellites.push(newSatellite); const totalSatellites = this.satellites.length; const angleStep = (Math.PI * 2) / totalSatellites; this.satellites.forEach((sat, index) => { sat.angle = index * angleStep; sat.updatePosition(); });
                console.log(`Satellite built for node (owner ${this.owner}). Total: ${totalSatellites}.`);
                if (this.owner === PLAYER) updateMessage(); // Actualizar UI solo para jugador
                return true;
            } else { return false; }
        }
    }
    class Satellite {
        constructor(parentNode, initialAngle = 0) { this.parentNode = parentNode; this.angle = initialAngle; this.orbitRadiusOffset = SATELLITE_ORBIT_RADIUS_BASE; this.fireRateLevel = 1; this.fireCooldown = 0; this.targetUnit = null; this.x = 0; this.y = 0; this.updatePosition(); }
        get fireRate() { return SATELLITE_FIRE_RATE_BASE; }
        updatePosition() { const orbitRadius = this.parentNode.radius + this.orbitRadiusOffset / cameraZoom; this.x = this.parentNode.x + Math.cos(this.angle) * orbitRadius; this.y = this.parentNode.y + Math.sin(this.angle) * orbitRadius; }
        update(deltaTime) { this.angle += SATELLITE_ORBIT_SPEED; if (this.angle > Math.PI * 2) this.angle -= Math.PI * 2; this.updatePosition(); if (this.fireCooldown > 0) { this.fireCooldown -= deltaTime; } if (!this.targetUnit || !units.includes(this.targetUnit) || this.distanceTo(this.targetUnit) > SATELLITE_RANGE || this.targetUnit.toBeRemoved) { this.findTarget(); } if (this.targetUnit && this.fireCooldown <= 0) { this.fire(); } }
        distanceTo(unit) { const dx = unit.x - this.x; const dy = unit.y - this.y; return Math.sqrt(dx * dx + dy * dy); }
        findTarget() { this.targetUnit = null; let closestDistSq = SATELLITE_RANGE * SATELLITE_RANGE; let potentialTarget = null; for (const unit of units) { if (unit.owner !== this.parentNode.owner && unit.owner !== NEUTRAL && !unit.toBeRemoved) { const dx = unit.x - this.x; const dy = unit.y - this.y; const distSq = dx * dx + dy * dy; if (distSq < closestDistSq) { closestDistSq = distSq; potentialTarget = unit; } } } this.targetUnit = potentialTarget; }
        fire() { if (!this.targetUnit) return; activeLasers.push({ fromX: this.x, fromY: this.y, toX: this.targetUnit.x, toY: this.targetUnit.y, endTime: performance.now() + SATELLITE_LASER_DURATION, ownerColor: this.parentNode.getColor() }); const targetX = this.targetUnit.x; const targetY = this.targetUnit.y; const targetColor = this.targetUnit.getColor(); this.targetUnit.toBeRemoved = true; spawnExplosion(targetX, targetY, targetColor, 8, 1.2); this.targetUnit = null; this.fireCooldown = this.fireRate; }
        draw() { ctx.fillStyle = this.parentNode.getColor(); ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; ctx.lineWidth = 1 / cameraZoom; ctx.beginPath(); ctx.arc(this.x, this.y, SATELLITE_RADIUS, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); }
    }
    class Unit {
        constructor(startX, startY, target, owner, isInterceptor = false, targetUnit = null) { this.x = startX; this.y = startY; this.owner = owner; this.radius = UNIT_RADIUS; this.isInterceptor = isInterceptor; this.targetNode = isInterceptor ? null : target; this.targetUnit = isInterceptor ? target : null; this.toBeRemoved = false; this.vx = 0; this.vy = 0; let targetX, targetY; if (this.isInterceptor && this.targetUnit) { targetX = this.targetUnit.x; targetY = this.targetUnit.y; } else if (this.targetNode) { targetX = this.targetNode.x; targetY = this.targetNode.y; } else { this.toBeRemoved = true; return; } const dx = targetX - startX; const dy = targetY - startY; const dist = Math.sqrt(dx * dx + dy * dy); if (dist !== 0) { const speedFactor = UNIT_SPEED * (this.isInterceptor ? 1.3 : 1.0); this.vx = (dx / dist) * speedFactor; this.vy = (dy / dist) * speedFactor; } }
        getColor() { if (this.owner === PLAYER) return PLAYER_COLOR; if (this.owner === NEUTRAL) return NEUTRAL_COLOR; const aiIndex = this.owner - 2; return AI_COLORS[aiIndex % AI_COLORS.length]; }
        draw() { ctx.shadowBlur = 8; ctx.shadowColor = this.getColor().replace('1)', '0.7)'); ctx.fillStyle = this.getColor(); ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0; }
        update() {
            if (this.toBeRemoved) return true;
            if (this.isInterceptor) {
                if (!this.targetUnit || this.targetUnit.toBeRemoved || !units.includes(this.targetUnit)) { this.toBeRemoved = true; return true; }
                const dx = this.targetUnit.x - this.x; const dy = this.targetUnit.y - this.y; const distSq = dx * dx + dy * dy; const dist = Math.sqrt(distSq);
                if (dist > 0) { const speedFactor = UNIT_SPEED * 1.3; this.vx = (dx / dist) * speedFactor; this.vy = (dy / dist) * speedFactor; }
                this.x += this.vx; this.y += this.vy;
                if (distSq <= UNIT_COLLISION_DIST_SQ) { spawnExplosion(this.x, this.y, this.getColor(), 6, 1.0); spawnExplosion(this.targetUnit.x, this.targetUnit.y, this.targetUnit.getColor(), 6, 1.0); this.targetUnit.toBeRemoved = true; this.toBeRemoved = true; return true; }
                if (dist > SATELLITE_RANGE * 1.5) { this.toBeRemoved = true; return true; }
            } else {
                this.x += this.vx; this.y += this.vy;
                const targetNode = this.targetNode; if (!targetNode) { this.toBeRemoved = true; return true; }
                const dx = targetNode.x - this.x; const dy = targetNode.y - this.y; const distSq = dx * dx + dy * dy; const targetRadius = targetNode.radius; const targetRadiusSq = targetRadius * targetRadius;
                const interceptRadiusSq = targetRadiusSq * 9; // Radio triple al cuadrado
                if (this.owner !== targetNode.owner && targetNode.owner !== NEUTRAL && targetNode.unitCount > 0 && !targetNode.targetedEnemyUnits.has(this)) {
                    if (distSq <= interceptRadiusSq) {
                        targetNode.unitCount--; targetNode.targetedEnemyUnits.add(this);
                        const spawnAngle = Math.atan2(dy, dx); const spawnX = targetNode.x + Math.cos(spawnAngle) * targetRadius; const spawnY = targetNode.y + Math.sin(spawnAngle) * targetRadius;
                        const interceptor = new Unit(spawnX, spawnY, this, targetNode.owner, true, this);
                        units.push(interceptor);
                    }
                }
                if (distSq <= targetRadiusSq) { if (targetNode.targetedEnemyUnits.has(this)) { targetNode.targetedEnemyUnits.delete(this); } this.onArrival(); this.toBeRemoved = true; return true; }
            }
            return false;
        }
        onArrival() { if (!gameRunning || this.toBeRemoved) return; const targetNode = this.targetNode; if (!targetNode) return; if (targetNode.owner === this.owner) { targetNode.unitCount++; } else { if (targetNode.owner !== NEUTRAL) { targetNode.isUnderAttack = true; targetNode.attackTimer = ATTACK_INDICATOR_DURATION; } targetNode.unitCount--; if (targetNode.unitCount < 0) { const oldOwner = targetNode.owner; targetNode.owner = this.owner; targetNode.unitCount = 1; targetNode.resetOnCapture(); const indexInSelection = selectedNodes.indexOf(targetNode); if (indexInSelection > -1) { targetNode.isSelected = false; selectedNodes.splice(indexInSelection, 1); updateMessage(); } checkWinCondition(); } } }
    }

    // --- Funciones Coordenadas & Cámara ---
    function screenToWorld(screenX, screenY) { const worldX = (screenX / cameraZoom) + cameraX; const worldY = (screenY / cameraZoom) + cameraY; return { x: worldX, y: worldY }; }
    function worldToScreen(worldX, worldY) { const screenX = (worldX - cameraX) * cameraZoom; const screenY = (worldY - cameraY) * cameraZoom; return { x: screenX, y: screenY }; }
    function clampCamera() { const viewWidthWorld = canvas.width / cameraZoom; const viewHeightWorld = canvas.height / cameraZoom; cameraX = Math.max(0, Math.min(cameraX, WORLD_WIDTH - viewWidthWorld)); cameraY = Math.max(0, Math.min(cameraY, WORLD_HEIGHT - viewHeightWorld)); }
    function zoomAtPoint(screenX, screenY, zoomFactor) { const worldPos = screenToWorld(screenX, screenY); const currentMinZoom = Math.max(minZoomToFitWorld, ABSOLUTE_MIN_ZOOM); const newZoom = Math.max(currentMinZoom, Math.min(MAX_ZOOM, cameraZoom * zoomFactor)); if (newZoom === cameraZoom) return; cameraX = worldPos.x - (screenX / newZoom); cameraY = worldPos.y - (screenY / newZoom); cameraZoom = newZoom; clampCamera(); }

    // --- Funciones de Juego ---
    function spawnExplosion(x, y, color, count, speedMultiplier = 1.0) { for (let i = 0; i < count; i++) { particles.push(new Particle(x, y, color)); } }
    function startGameLogic() { console.log(`--- Start Game: ${NUM_NEUTRAL_NODES_SETTING} Nodes, ${NUM_ENEMIES_SETTING} Enemies ---`); resizeCanvas(); nodes = []; units = []; selectedNodes = []; particles = []; activeLasers = []; activeNodeButtons = []; gameRunning = true; interaction = { pointers: new Map(), lastTapTime: 0, lastTappedNodeForDoubleTap: null, isInteractingNode: false, isPanning: false, isPinching: false, isBoxSelecting: false, pinchInitialDistance: 0, currentPointerScreenPos: { x: null, y: null }, boxStartScreenX: 0, boxStartScreenY: 0 }; ambientPointerScreenPos = { x: null, y: null }; gameOverMessageDiv.style.display = 'none'; currentSendPercentage = 0.50; setActivePercentageButton(); stars = []; for (let i = 0; i < NUM_STARS; i++) { stars.push({ x: Math.random() * WORLD_WIDTH, y: Math.random() * WORLD_HEIGHT, depth: 0.05 + Math.random() * 0.65, size: 0.4 + Math.random() * 0.8, alpha: 0.3 + Math.random() * 0.6 }); } stars.sort((a, b) => a.depth - b.depth); const maxInitialUnits = 35; const maxInitialRadius = NODE_RADIUS_BASE + (1 * NODE_RADIUS_PER_LEVEL) + maxInitialUnits * NODE_RADIUS_PER_UNIT + 5; const worldMargin = maxInitialRadius; const startingPlayers = 1 + NUM_ENEMIES_SETTING; const playerPositions = []; playerPositions.push({ x: worldMargin + Math.random() * (WORLD_WIDTH - 2 * worldMargin), y: worldMargin + Math.random() * (WORLD_HEIGHT - 2 * worldMargin), owner: PLAYER }); for (let i = 0; i < NUM_ENEMIES_SETTING; i++) { let placed = false; let attempts = 0; const maxPlacementAttempts = 500; while (!placed && attempts < maxPlacementAttempts) { attempts++; const potentialX = worldMargin + Math.random() * (WORLD_WIDTH - 2 * worldMargin); const potentialY = worldMargin + Math.random() * (WORLD_HEIGHT - 2 * worldMargin); let tooClose = false; const minDistSq = Math.pow(WORLD_WIDTH / (startingPlayers * 1.5), 2); for (const p of playerPositions) { const dx = potentialX - p.x; const dy = potentialY - p.y; if (dx * dx + dy * dy < minDistSq) { tooClose = true; break; } } if (!tooClose) { playerPositions.push({ x: potentialX, y: potentialY, owner: 2 + i }); placed = true; } } if (!placed) console.warn(`Could not place AI ${i+1} far apart.`); } let playerNodeRef = null; playerPositions.forEach(p => { const newNode = new Node(p.x, p.y, p.owner, maxInitialUnits); nodes.push(newNode); if (p.owner === PLAYER) playerNodeRef = newNode; }); let neutralCount = 0; let attempts = 0; const maxAttempts = 200; while (neutralCount < NUM_NEUTRAL_NODES_SETTING && attempts < maxAttempts * NUM_NEUTRAL_NODES_SETTING) { attempts++; const nx = worldMargin + Math.random() * (WORLD_WIDTH - 2 * worldMargin); const ny = worldMargin + Math.random() * (WORLD_HEIGHT - 2 * worldMargin); const newNode = new Node(nx, ny, NEUTRAL, 10 + Math.floor(Math.random() * 16)); let tooClose = false; for (const existingNode of nodes) { const dx = newNode.x - existingNode.x; const dy = newNode.y - existingNode.y; if (dx * dx + dy * dy < MIN_NODE_DISTANCE * MIN_NODE_DISTANCE) { tooClose = true; break; } } if (!tooClose) { nodes.push(newNode); neutralCount++; } } if(neutralCount < NUM_NEUTRAL_NODES_SETTING) console.warn(`Placed only ${neutralCount}/${NUM_NEUTRAL_NODES_SETTING} neutral nodes.`); const zoomFitHalfW = canvas.width / (WORLD_WIDTH / 1.5); const zoomFitHalfH = canvas.height / (WORLD_HEIGHT / 1.5); const initialZoomTarget = Math.min(zoomFitHalfW, zoomFitHalfH); cameraZoom = Math.max(minZoomToFitWorld, initialZoomTarget, 0.4); console.log(`Initial Zoom calculated: ${cameraZoom.toFixed(3)} (Target: ${initialZoomTarget.toFixed(3)})`); if (playerNodeRef) { const initialScreenW = canvas.width; const initialScreenH = canvas.height; cameraX = playerNodeRef.x - (initialScreenW / 2) / cameraZoom; cameraY = playerNodeRef.y - (initialScreenH / 2) / cameraZoom; clampCamera(); } else { cameraX = 0; cameraY = 0; } lastGenerationTime = performance.now(); lastAiActionTime = performance.now(); if (animationFrameId) { cancelAnimationFrame(animationFrameId); } updateMessage(); gameLoop(); }
    function resizeCanvas() { const controlsHeight = document.getElementById('controls').offsetHeight; const availableHeight = window.innerHeight - controlsHeight - 5; const availableWidth = window.innerWidth; canvas.width = availableWidth; canvas.height = availableHeight; canvas.style.marginTop = `${controlsHeight}px`; const zoomFitW = canvas.width / WORLD_WIDTH; const zoomFitH = canvas.height / WORLD_HEIGHT; minZoomToFitWorld = Math.max(zoomFitW, zoomFitH); console.log(`Canvas resized: ${canvas.width}x${canvas.height}. Min Zoom: ${minZoomToFitWorld.toFixed(3)}`); cameraZoom = Math.max(minZoomToFitWorld, cameraZoom); clampCamera(); }
    function sendUnits(sourceNode, targetNode) { if (!sourceNode || !targetNode || sourceNode === targetNode || sourceNode.unitCount < 1) return; let unitsToSend = 0; if (currentSendPercentage === 1.0 && sourceNode.unitCount > 1) { unitsToSend = sourceNode.unitCount - 1; } else { unitsToSend = Math.floor(sourceNode.unitCount * currentSendPercentage); if (unitsToSend === 0 && sourceNode.unitCount >= 1 && currentSendPercentage > 0) unitsToSend = 1; } unitsToSend = Math.min(unitsToSend, sourceNode.unitCount); if (unitsToSend <= 0) return; sourceNode.unitCount -= unitsToSend; for (let i = 0; i < unitsToSend; i++) { const angle = Math.random() * Math.PI * 2; const radiusOffset = Math.random() * sourceNode.radius * 0.6; const startX = sourceNode.x + Math.cos(angle) * radiusOffset; const startY = sourceNode.y + Math.sin(angle) * radiusOffset; units.push(new Unit(startX, startY, targetNode, sourceNode.owner)); } }
    function clearSelection(keepInteractionState = false) { selectedNodes.forEach(node => node.isSelected = false); selectedNodes = []; if (!keepInteractionState) { interaction.isInteractingNode = false; canvas.classList.remove('interacting-node'); canvas.style.cursor = 'default'; } activeNodeButtons = []; updateMessage(); }
    function updateMessage() { if (!gameRunning) return; let msg = ""; const percentageText = `${currentSendPercentage * 100}%`; if (selectedNodes.length === 0) { msg = `Toca/arrastra nodo (M:o Box). ${percentageText}.`; } else if (selectedNodes.length === 1) { const node = selectedNodes[0]; const cost = calculateUpgradeCost(node); let upgradeText = cost === Infinity ? "(Nivel Máx)" : `(Mejora: ${cost} U)`; let satelliteText = node.satellites.length > 0 ? ` (${node.satellites.length}/${MAX_SATELLITES_PER_NODE} Sat)` : ""; let buildSatText = ""; if(node.satellites.length < MAX_SATELLITES_PER_NODE) { buildSatText = ` (Const Sat: ${SATELLITE_COST} U)`; } let unitsToSend = 0; if (currentSendPercentage === 1.0 && node.unitCount > 1) unitsToSend = node.unitCount - 1; else unitsToSend = Math.floor(node.unitCount * currentSendPercentage); if (unitsToSend === 0 && node.unitCount >=1 && currentSendPercentage > 0) unitsToSend = 1; unitsToSend = Math.min(unitsToSend, node.unitCount); msg = `1 Nodo: ${Math.floor(node.unitCount)}/${node.getMaxCapacity()} U L${node.level}${satelliteText} ${upgradeText}${buildSatText} | `; msg += `Enviar ${unitsToSend} (${percentageText}). Toca/suelta en destino.`; } else { let totalUnits = 0; selectedNodes.forEach(node => totalUnits += node.unitCount); let totalUnitsToSend = 0; selectedNodes.forEach(node => { let unitsFromThisNode = 0; if (currentSendPercentage === 1.0 && node.unitCount > 1) unitsFromThisNode = node.unitCount - 1; else unitsFromThisNode = Math.floor(node.unitCount * currentSendPercentage); if (unitsFromThisNode === 0 && node.unitCount >=1 && currentSendPercentage > 0) unitsFromThisNode = 1; totalUnitsToSend += Math.min(unitsFromThisNode, node.unitCount); }); msg = `${selectedNodes.length} Nodos: ${Math.floor(totalUnits)} U | `; msg += `Enviar ~${totalUnitsToSend} (${percentageText}). Toca/suelta en destino.`; } messageDiv.innerHTML = msg; }
    function setActivePercentageButton() { percentageButtonsContainer.querySelectorAll('button').forEach(button => { if (parseFloat(button.getAttribute('data-percent')) === currentSendPercentage) button.classList.add('active'); else button.classList.remove('active'); }); if (gameRunning) updateMessage(); }
    // --- IA (Restaurada y Funcional) ---
    function runAIForPlayer(aiOwnerId, currentTime) { const aiNodes = nodes.filter(n => n.owner === aiOwnerId); const enemyNodes = nodes.filter(n => n.owner === PLAYER || (n.owner >= 2 && n.owner !== aiOwnerId)); const neutralNodes = nodes.filter(n => n.owner === NEUTRAL); const nonAiOwnedNodes = enemyNodes.concat(neutralNodes); if (aiNodes.length === 0 || nonAiOwnedNodes.length === 0) return; let potentialActions = []; aiNodes.forEach(node => { if (node.level < MAX_NODE_LEVEL) { const cost = calculateUpgradeCost(node); if (node.unitCount > cost * 1.6 || (node.unitCount > node.getMaxCapacity() * 0.6 && node.unitCount > cost)) { let score = 10 + node.level * 5 + (node.unitCount / node.getMaxCapacity()) * 10; potentialActions.push({ type: 'upgrade', node: node, score: score }); } } if (node.satellites.length < MAX_SATELLITES_PER_NODE && node.unitCount >= SATELLITE_COST * 1.5 && node.unitCount > node.getMaxCapacity() * 0.5) { let score = 15 + (MAX_SATELLITES_PER_NODE - node.satellites.length) * 5; potentialActions.push({ type: 'build_satellite', node: node, score: score }); } }); aiNodes.forEach(sourceNode => { if (sourceNode.unitCount > 15) { nonAiOwnedNodes.forEach(targetNode => { const unitsToSendIA = Math.floor(sourceNode.unitCount / 2); if (unitsToSendIA <= 0) return; let score = 0; const dist = Math.hypot(sourceNode.x - targetNode.x, sourceNode.y - targetNode.y); const targetStrength = targetNode.unitCount + (targetNode.owner === PLAYER ? targetNode.level * 10 : (targetNode.owner >= 2 ? targetNode.level * 5 : 0)); if (targetNode.owner === NEUTRAL) { score = 150 - targetStrength - dist * 0.15; } else { if (unitsToSendIA > targetStrength * 1.2) { score = 100 + (unitsToSendIA - targetStrength) * 1.5 - dist * 0.1; } else if (unitsToSendIA > targetStrength * 0.7) { score = 30 - dist * 0.1; } if(targetNode.owner === PLAYER) score *= 1.1; } if (score > 5) { potentialActions.push({ type: 'attack', source: sourceNode, target: targetNode, score: score }); } }); } }); aiNodes.forEach(sourceNode => { if (sourceNode.unitCount > sourceNode.getMaxCapacity() * 0.6 ) { aiNodes.forEach(targetNode => { if (sourceNode !== targetNode && targetNode.unitCount < targetNode.getMaxCapacity() * 0.5 ) { const dist = Math.hypot(sourceNode.x - targetNode.x, sourceNode.y - targetNode.y); if (dist < WORLD_WIDTH / 4) { potentialActions.push({ type: 'reinforce', source: sourceNode, target: targetNode, score: 20 - dist * 0.01 }); } } }); } }); if (potentialActions.length > 0) { potentialActions.sort((a, b) => b.score - a.score); const choiceIndex = Math.floor(Math.random() * Math.min(potentialActions.length, 3)); const chosenAction = potentialActions[choiceIndex]; if (chosenAction.type === 'upgrade') { if (Math.random() < AI_UPGRADE_CHANCE) chosenAction.node.attemptUpgrade(); } else if (chosenAction.type === 'build_satellite') { chosenAction.node.attemptBuildSatellite(); } else if (chosenAction.type === 'attack' || chosenAction.type === 'reinforce') { const unitsToSendIA = Math.floor(chosenAction.source.unitCount / 2); if (unitsToSendIA > 0) { chosenAction.source.unitCount -= unitsToSendIA; for (let i = 0; i < unitsToSendIA; i++) { const angle = Math.random()*Math.PI*2; const rOff = Math.random()*chosenAction.source.radius*0.5; const startX = chosenAction.source.x + Math.cos(angle) * rOff; const startY = chosenAction.source.y + Math.sin(angle) * rOff; units.push(new Unit(startX, startY, chosenAction.target, aiOwnerId)); } } } } }
    function updateAI(currentTime) { if (currentTime - lastAiActionTime >= AI_ACTION_INTERVAL) { lastAiActionTime = currentTime; for (let i = 0; i < NUM_ENEMIES_SETTING; i++) { runAIForPlayer(2 + i, performance.now()); } } }
    // --- Fin IA ---
    function checkWinCondition() { if (!gameRunning) return; const playerNodesExist = nodes.some(n => n.owner === PLAYER); const aiNodesExist = nodes.some(n => n.owner >= 2); if (!aiNodesExist && playerNodesExist) { console.log("--- Game Over: Player Wins ---"); gameOverTitle.textContent = "¡Has Ganado!"; gameOverMessageDiv.style.display = 'block'; gameRunning = false; clearSelection(); } else if (!playerNodesExist && aiNodesExist) { console.log("--- Game Over: Player Loses ---"); gameOverTitle.textContent = "Has Perdido"; gameOverMessageDiv.style.display = 'block'; gameRunning = false; clearSelection(); } else if (!playerNodesExist && !aiNodesExist && nodes.some(n => n.owner === NEUTRAL)) { console.log("--- Game Over: Strange Draw ---"); gameOverTitle.textContent = "Empate Extraño..."; gameOverMessageDiv.style.display = 'block'; gameRunning = false; clearSelection(); } }
    function update(currentTime) {
        if (!gameRunning) return; const deltaTime = currentTime - (lastGenerationTime || currentTime); lastGenerationTime = currentTime;
        nodes.forEach(node => node.update(deltaTime));
        // 1. Update units (returns true if needs removal from arrival, interceptor logic, etc.)
        for (let i = units.length - 1; i >= 0; i--) { if (units[i].update()) { units.splice(i, 1); } }
        // 2. Check Mid-Space Collisions -> Mark units for removal
        for (let i = 0; i < units.length; i++) { const unitA = units[i]; if (unitA.toBeRemoved || unitA.owner === NEUTRAL) continue; for (let j = i + 1; j < units.length; j++) { const unitB = units[j]; if (unitB.toBeRemoved || unitB.owner === NEUTRAL) continue; if (unitA.owner !== unitB.owner) { const dx = unitA.x - unitB.x; const dy = unitA.y - unitB.y; const distSq = dx * dx + dy * dy; if (distSq <= UNIT_COLLISION_DIST_SQ) { const midX = (unitA.x + unitB.x) / 2; const midY = (unitA.y + unitB.y) / 2; spawnExplosion(midX, midY, unitA.getColor(), 6, 1.0); spawnExplosion(midX, midY, unitB.getColor(), 6, 1.0); unitA.toBeRemoved = true; unitB.toBeRemoved = true; break; } } } }
        // 3. Remove units marked by collision
        units = units.filter(unit => !unit.toBeRemoved);
        // 4. Update Particles
        for (let i = particles.length - 1; i >= 0; i--) { if (particles[i].update(deltaTime)) { particles.splice(i, 1); } }
        // 5. Update AI & Lasers
        updateAI(currentTime); activeLasers = activeLasers.filter(laser => laser.endTime > currentTime);
    }

    // --- Funciones de Dibujo ---
    function drawStars() { ctx.save(); ctx.fillStyle = 'white'; stars.forEach(star => { const screenX = (star.x - cameraX * star.depth) * cameraZoom; const screenY = (star.y - cameraY * star.depth) * cameraZoom; const starScreenSize = star.size; if (screenX >= -starScreenSize && screenX <= canvas.width + starScreenSize && screenY >= -starScreenSize && screenY <= canvas.height + starScreenSize) { ctx.globalAlpha = star.alpha; ctx.beginPath(); ctx.arc(screenX, screenY, starScreenSize, 0, Math.PI * 2); ctx.fill(); } }); ctx.restore(); }
    function drawMinimap() { if (!MINIMAP_ENABLED) return; ctx.save(); const mapX = canvas.width - MINIMAP_WIDTH - MINIMAP_MARGIN; const mapY = MINIMAP_MARGIN; const scaleX = MINIMAP_WIDTH / WORLD_WIDTH; const scaleY = MINIMAP_HEIGHT / WORLD_HEIGHT; ctx.fillStyle = 'rgba(10, 10, 20, 0.7)'; ctx.fillRect(mapX - 2, mapY - 2, MINIMAP_WIDTH + 4, MINIMAP_HEIGHT + 4); ctx.strokeStyle = 'rgba(100, 100, 120, 0.8)'; ctx.lineWidth = 1; ctx.strokeRect(mapX - 2, mapY - 2, MINIMAP_WIDTH + 4, MINIMAP_HEIGHT + 4); nodes.forEach(node => { const nodeMapX = mapX + node.x * scaleX; const nodeMapY = mapY + node.y * scaleY; ctx.fillStyle = node.getColor(); ctx.beginPath(); ctx.arc(nodeMapX, nodeMapY, MINIMAP_NODE_SIZE, 0, Math.PI * 2); ctx.fill(); }); const viewMapX = mapX + cameraX * scaleX; const viewMapY = mapY + cameraY * scaleY; const viewMapW = (canvas.width / cameraZoom) * scaleX; const viewMapH = (canvas.height / cameraZoom) * scaleY; ctx.strokeStyle = MINIMAP_CAMERA_COLOR; ctx.lineWidth = 1.5; ctx.strokeRect(viewMapX, viewMapY, viewMapW, viewMapH); ctx.restore(); }
    function drawInteractionIndicatorsAndButtons() {
         activeNodeButtons = []; let targetScreenX = null; let targetScreenY = null; let drawLinesAndMarker = false;
         if (interaction.isInteractingNode && interaction.pointers.size > 0 && !interaction.isPanning && interaction.currentPointerScreenPos.x !== null) { targetScreenX = interaction.currentPointerScreenPos.x; targetScreenY = interaction.currentPointerScreenPos.y; drawLinesAndMarker = selectedNodes.length > 0; }
         else if (selectedNodes.length > 0 && ambientPointerScreenPos.x !== null) { targetScreenX = ambientPointerScreenPos.x; targetScreenY = ambientPointerScreenPos.y; drawLinesAndMarker = true; }
         if (drawLinesAndMarker) { ctx.save(); ctx.strokeStyle = SELECTED_COLOR; ctx.lineWidth = SELECTION_LINE_WIDTH; ctx.setLineDash([5, 5]); selectedNodes.forEach(node => { const nodeScreenPos = worldToScreen(node.x, node.y); ctx.beginPath(); ctx.moveTo(nodeScreenPos.x, nodeScreenPos.y); ctx.lineTo(targetScreenX, targetScreenY); ctx.stroke(); }); ctx.setLineDash([]); ctx.fillStyle = SELECTED_COLOR; ctx.shadowBlur = 0; ctx.beginPath(); ctx.arc(targetScreenX, targetScreenY, POINTER_MARKER_RADIUS, 0, Math.PI * 2); ctx.fill(); ctx.restore(); }
         else if (interaction.isBoxSelecting && interaction.currentPointerScreenPos.x !== null) { ctx.save(); ctx.fillStyle = BOX_SELECT_COLOR; ctx.strokeStyle = SELECTED_COLOR; ctx.lineWidth = 1; ctx.setLineDash([3, 3]); const sx = interaction.boxStartScreenX; const sy = interaction.boxStartScreenY; const cx = interaction.currentPointerScreenPos.x; const cy = interaction.currentPointerScreenPos.y; ctx.fillRect(sx, sy, cx - sx, cy - sy); ctx.strokeRect(sx, sy, cx - sx, cy - sy); ctx.restore(); }
         if (selectedNodes.length === 1 && selectedNodes[0].owner === PLAYER) {
             const node = selectedNodes[0]; const nodeScreenPos = worldToScreen(node.x, node.y); const nodeScreenRadius = node.radius * cameraZoom;
             const buttonSize = 38; const buttonMargin = 10; const buttonExtraSpacing = 18; const baseButtonYOffset = nodeScreenRadius + buttonMargin + buttonExtraSpacing + buttonSize / 2; let initialButtonY = nodeScreenPos.y + baseButtonYOffset;
             const buttonHalfHeight = buttonSize / 2; const buttonHalfWidth = buttonSize / 2; const buttonTopMargin = 5; const buttonSideMargin = 5;
             const buttonsToDrawInfo = []; const upgradeCost = calculateUpgradeCost(node); const canUpgrade = upgradeCost !== Infinity && node.unitCount >= upgradeCost; if (upgradeCost !== Infinity) { buttonsToDrawInfo.push({ action: 'upgrade', icon: '⬆️', enabled: canUpgrade, color: canUpgrade ? 'rgba(0, 200, 0, 0.8)' : 'rgba(80, 80, 80, 0.8)' }); } const canBuildSatellite = node.satellites.length < MAX_SATELLITES_PER_NODE && node.unitCount >= SATELLITE_COST; if (node.satellites.length < MAX_SATELLITES_PER_NODE) { buttonsToDrawInfo.push({ action: 'build_satellite', icon: '🛰️', enabled: canBuildSatellite, color: canBuildSatellite ? 'rgba(0, 150, 200, 0.8)' : 'rgba(80, 80, 80, 0.8)' }); } if (buttonsToDrawInfo.length === 0) return;
             let finalButtonY = initialButtonY; if (initialButtonY + buttonHalfHeight > canvas.height) { finalButtonY = nodeScreenPos.y - baseButtonYOffset; if (finalButtonY - buttonHalfHeight < buttonTopMargin) { finalButtonY = buttonTopMargin + buttonHalfHeight; } }
             const totalWidth = buttonsToDrawInfo.length * buttonSize + (buttonsToDrawInfo.length - 1) * buttonMargin; let startX = nodeScreenPos.x - totalWidth / 2; const endX = startX + totalWidth; if (endX > canvas.width - buttonSideMargin) { startX -= (endX - (canvas.width - buttonSideMargin)); } if (startX < buttonSideMargin) { startX = buttonSideMargin; }
             ctx.save(); ctx.font = `${buttonSize * 0.5}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.lineWidth = 1.5;
             let currentButtonX = startX + buttonHalfWidth;
             buttonsToDrawInfo.forEach(buttonInfo => { const buttonRect = { x: currentButtonX - buttonHalfWidth, y: finalButtonY - buttonHalfHeight, width: buttonSize, height: buttonSize }; ctx.fillStyle = buttonInfo.color; ctx.fillRect(buttonRect.x, buttonRect.y, buttonRect.width, buttonRect.height); ctx.strokeStyle = buttonInfo.enabled ? 'rgba(220, 220, 220, 0.9)' : 'rgba(150, 150, 150, 0.7)'; ctx.strokeRect(buttonRect.x, buttonRect.y, buttonRect.width, buttonRect.height); ctx.globalAlpha = buttonInfo.enabled ? 1.0 : 0.5; ctx.fillStyle = 'white'; ctx.fillText(buttonInfo.icon, currentButtonX, finalButtonY + buttonSize * 0.05); ctx.globalAlpha = 1.0; if (buttonInfo.enabled) { activeNodeButtons.push({ rect: buttonRect, action: buttonInfo.action, node: node }); } currentButtonX += buttonSize + buttonMargin; });
             ctx.restore();
         }
    }
    function drawLasers() { if (activeLasers.length === 0) return; ctx.save(); ctx.lineWidth = 1.5; ctx.globalAlpha = 0.8; activeLasers.forEach(laser => { ctx.strokeStyle = laser.ownerColor; const startScreen = worldToScreen(laser.fromX, laser.fromY); const endScreen = worldToScreen(laser.toX, laser.toY); ctx.beginPath(); ctx.moveTo(startScreen.x, startScreen.y); ctx.lineTo(endScreen.x, endScreen.y); ctx.stroke(); }); ctx.restore(); }
    function draw() { ctx.fillStyle = '#05050f'; ctx.fillRect(0, 0, canvas.width, canvas.height); drawStars(); ctx.save(); ctx.scale(cameraZoom, cameraZoom); ctx.translate(-cameraX, -cameraY); units.forEach(unit => unit.draw()); nodes.forEach(node => node.draw()); particles.forEach(p => p.draw()); ctx.restore(); drawLasers(); drawInteractionIndicatorsAndButtons(); drawMinimap(); }
    function gameLoop(timestamp) { update(timestamp || 0); draw(); animationFrameId = requestAnimationFrame(gameLoop); }

    // --- Funciones Interacción (Restauradas v23.6.1) ---
    function findClosestNode(worldX, worldY) { let closestNode = null; let minDistanceSq = TOUCH_SEARCH_RADIUS_WORLD * TOUCH_SEARCH_RADIUS_WORLD; for (const node of nodes) { const dx = worldX - node.x; const dy = worldY - node.y; const distSq = dx * dx + dy * dy; const nodeRadius = node.radius; if (distSq < nodeRadius * nodeRadius || distSq < minDistanceSq) { if (distSq < minDistanceSq) { minDistanceSq = distSq; closestNode = node; } else if (distSq < nodeRadius*nodeRadius && (!closestNode || distSq < Math.pow(worldX - closestNode.x, 2) + Math.pow(worldY - closestNode.y, 2))) { closestNode = node; } } } return closestNode; }
    function getPointerInfo(event) { const rect = canvas.getBoundingClientRect(); const pointers = []; const source = event.touches || [event]; for (let i = 0; i < source.length; i++) { const p = source[i]; const id = p.identifier ?? p.pointerId ?? 0; const screenX = p.clientX - rect.left; const screenY = p.clientY - rect.top; pointers.push({ id: id, screenX: screenX, screenY: screenY, ...screenToWorld(screenX, screenY), pointerType: event.pointerType || (event.touches ? 'touch' : 'mouse'), button: event.button }); } return pointers; }
    function getDistance(p1, p2) { const dx = p1.screenX - p2.screenX; const dy = p1.screenY - p2.screenY; return Math.sqrt(dx * dx + dy * dy); }
    function getMidpoint(p1, p2) { return { screenX: (p1.screenX + p2.screenX) / 2, screenY: (p1.screenY + p2.screenY) / 2 }; }
    function handleAmbientPointerMove(event) { if (!gameRunning) return; const rect = canvas.getBoundingClientRect(); ambientPointerScreenPos.x = event.clientX - rect.left; ambientPointerScreenPos.y = event.clientY - rect.top; }
    function handleAmbientPointerLeave(event) { ambientPointerScreenPos.x = null; ambientPointerScreenPos.y = null; }
    function handlePointerDown(event) { if (!gameRunning && interaction.pointers.size === 0) return; event.preventDefault(); canvas.setPointerCapture?.(event.pointerId); const currentPointers = getPointerInfo(event); const time = performance.now(); const pointer = currentPointers[0]; const screenX = pointer.screenX; const screenY = pointer.screenY; let clickedButton = null; for (const button of activeNodeButtons) { if (screenX >= button.rect.x && screenX <= button.rect.x + button.rect.width && screenY >= button.rect.y && screenY <= button.rect.y + button.rect.height) { clickedButton = button; break; } } if (clickedButton) { console.log(`Clicked Action Button: ${clickedButton.action}`); if (clickedButton.action === 'upgrade') { clickedButton.node.attemptUpgrade(); } else if (clickedButton.action === 'build_satellite') { clickedButton.node.attemptBuildSatellite(); } interaction.pointers.set(pointer.id, { id: pointer.id, isButtonPress: true }); return; } if (interaction.isInteractingNode && selectedNodes.length > 0 && interaction.pointers.size === 0) { const targetNode = findClosestNode(pointer.x, pointer.y); if (targetNode) { const canSend = !(selectedNodes.length === 1 && selectedNodes[0] === targetNode); if (canSend) { selectedNodes.forEach(sourceNode => { if (sourceNode !== targetNode) sendUnits(sourceNode, targetNode); }); clearSelection(); } else { clearSelection(); } } else { clearSelection(); } return; } interaction.isPanning = false; interaction.isPinching = false; interaction.isBoxSelecting = false; interaction.isInteractingNode = false; canvas.classList.remove('grabbing', 'panning', 'box-selecting', 'interacting-node'); currentPointers.forEach(p => { if (!interaction.pointers.has(p.id)) { const downNode = findClosestNode(p.x, p.y); interaction.pointers.set(p.id, { id: p.id, screenX: p.screenX, screenY: p.screenY, initialScreenX: p.screenX, initialScreenY: p.screenY, x: p.x, y: p.y, downTime: time, downNode: downNode, pointerType: p.pointerType, button: p.button }); interaction.currentPointerScreenPos = { x: p.screenX, y: p.screenY }; interaction.boxStartScreenX = p.screenX; interaction.boxStartScreenY = p.screenY; } }); const numPointers = interaction.pointers.size; if (numPointers === 1) { if (pointer.downNode && pointer.downNode.owner === PLAYER) { interaction.lastTappedNodeForDoubleTap = pointer.downNode; } else { interaction.lastTappedNodeForDoubleTap = null; } interaction.lastTapTime = time; } else if (numPointers === 2) { const pointersArray = Array.from(interaction.pointers.values()); interaction.pinchInitialDistance = getDistance(pointersArray[0], pointersArray[1]); interaction.isPinching = true; interaction.isPanning = true; console.log("Two pointers down: starting pinch/pan"); clearSelection(); canvas.classList.add('panning', 'grabbing'); } }
    function handlePointerMove(event) { if (!gameRunning || interaction.pointers.size === 0) return; event.preventDefault(); const currentPointers = getPointerInfo(event); currentPointers.forEach(p => { if (interaction.pointers.has(p.id)) { const storedPointer = interaction.pointers.get(p.id); if(storedPointer.isButtonPress) return; storedPointer.screenX = p.screenX; storedPointer.screenY = p.screenY; storedPointer.x = p.x; storedPointer.y = p.y; if(p.id === Array.from(interaction.pointers.keys())[0]) { interaction.currentPointerScreenPos = { x: p.screenX, y: p.screenY }; } } }); const pointersArray = Array.from(interaction.pointers.values()).filter(p => !p.isButtonPress); const numPointers = pointersArray.length; if (numPointers === 1) { const pointer = pointersArray[0]; const dxScreen = pointer.screenX - pointer.initialScreenX; const dyScreen = pointer.screenY - pointer.initialScreenY; const distSqScreen = dxScreen * dxScreen + dyScreen * dyScreen; const hasMovedSignificantly = distSqScreen >= DRAG_THRESHOLD_FOR_ACTION * DRAG_THRESHOLD_FOR_ACTION; if (!interaction.isPanning && !interaction.isBoxSelecting && !interaction.isInteractingNode && hasMovedSignificantly) { console.log("Drag threshold exceeded - Determining action..."); if (pointer.button === 2) { console.log("Determined: Right-Click Pan"); interaction.isPanning = true; clearSelection(); } else if (pointer.downNode && pointer.downNode.owner === PLAYER) { console.log("Determined: Drag-Select from node"); interaction.isInteractingNode = true; if (!(selectedNodes.length === 1 && selectedNodes[0] === pointer.downNode)) { clearSelection(true); pointer.downNode.isSelected = true; selectedNodes.push(pointer.downNode); updateMessage(); } } else { if (pointer.pointerType === 'touch') { console.log("Determined: Touch Pan"); interaction.isPanning = true; clearSelection(); } else { console.log("Determined: Box Select"); interaction.isBoxSelecting = true; clearSelection(); } } if(interaction.isPanning) { canvas.classList.add('panning', 'grabbing'); canvas.classList.remove('interacting-node', 'box-selecting'); } else if(interaction.isInteractingNode) { canvas.classList.add('interacting-node'); canvas.classList.remove('panning', 'grabbing', 'box-selecting'); } else if(interaction.isBoxSelecting) { canvas.classList.add('box-selecting'); canvas.classList.remove('panning', 'grabbing', 'interacting-node'); } } if (interaction.isPanning) { const deltaXScreen = pointer.screenX - pointer.initialScreenX; const deltaYScreen = pointer.screenY - pointer.initialScreenY; cameraX -= deltaXScreen / cameraZoom; cameraY -= deltaYScreen / cameraZoom; clampCamera(); pointer.initialScreenX = pointer.screenX; pointer.initialScreenY = pointer.screenY; if (!canvas.classList.contains('grabbing')) canvas.classList.add('grabbing'); } else if (interaction.isInteractingNode) { const nodeUnderPointer = findClosestNode(pointer.x, pointer.y); if (nodeUnderPointer && nodeUnderPointer.owner === PLAYER && !nodeUnderPointer.isSelected) { nodeUnderPointer.isSelected = true; selectedNodes.push(nodeUnderPointer); updateMessage(); } if (!canvas.classList.contains('interacting-node')) canvas.classList.add('interacting-node'); } else if (interaction.isBoxSelecting) { if (!canvas.classList.contains('box-selecting')) canvas.classList.add('box-selecting'); } } else if (numPointers === 2) { interaction.isInteractingNode = false; interaction.isBoxSelecting = false; interaction.isPanning = true; const p1 = pointersArray[0]; const p2 = pointersArray[1]; const newDist = getDistance(p1, p2); const midPoint = getMidpoint(p1, p2); if (interaction.pinchInitialDistance > 0) { const zoomFactor = newDist / interaction.pinchInitialDistance; zoomAtPoint(midPoint.screenX, midPoint.screenY, zoomFactor); } const p1Start = interaction.pointers.get(p1.id); const p2Start = interaction.pointers.get(p2.id); if (!p1Start || !p2Start) return; const initialMidPoint = getMidpoint(p1Start, p2Start); const deltaXScreen = midPoint.screenX - initialMidPoint.screenX; const deltaYScreen = midPoint.screenY - initialMidPoint.screenY; cameraX -= deltaXScreen / cameraZoom; cameraY -= deltaYScreen / cameraZoom; clampCamera(); interaction.pinchInitialDistance = newDist; p1Start.initialScreenX = p1.screenX; p1Start.initialScreenY = p1.screenY; p2Start.initialScreenX = p2.screenX; p2Start.initialScreenY = p2.screenY; canvas.classList.add('panning', 'grabbing'); canvas.classList.remove('interacting-node', 'box-selecting'); } }
    function handlePointerUp(event) { if (!gameRunning && interaction.pointers.size === 0) { console.log("Tap on game over - Restarting"); initializeApp(); return; } event.preventDefault(); const pointerId = event.identifier ?? event.pointerId ?? 0; const pointerData = interaction.pointers.get(pointerId); if (pointerData) { if (pointerData.isButtonPress) { interaction.pointers.delete(pointerId); } else { const time = performance.now(); const duration = time - pointerData.downTime; const dx = pointerData.screenX - pointerData.initialScreenX; const dy = pointerData.screenY - pointerData.initialScreenY; const distSq = dx * dx + dy * dy; const hasMovedSignificantly = distSq >= DRAG_THRESHOLD_FOR_ACTION * DRAG_THRESHOLD_FOR_ACTION; const isTap = !interaction.isPanning && !interaction.isBoxSelecting && !interaction.isInteractingNode && duration < TAP_DURATION_THRESHOLD && !hasMovedSignificantly; const isDragSelectEnd = interaction.isInteractingNode && !interaction.isPanning; const isBoxSelectEnd = interaction.isBoxSelecting; const nodeAtPointerUp = findClosestNode(pointerData.x, pointerData.y); if (isBoxSelectEnd) { console.log("Finalized Box Select."); const boxP1World = screenToWorld(interaction.boxStartScreenX, interaction.boxStartScreenY); const boxP2World = screenToWorld(pointerData.screenX, pointerData.screenY); const minX = Math.min(boxP1World.x, boxP2World.x); const maxX = Math.max(boxP1World.x, boxP2World.x); const minY = Math.min(boxP1World.y, boxP2World.y); const maxY = Math.max(boxP1World.y, boxP2World.y); clearSelection(true); nodes.forEach(node => { if (node.owner === PLAYER && node.x >= minX && node.x <= maxX && node.y >= minY && node.y <= maxY) { node.isSelected = true; selectedNodes.push(node); } }); console.log(`Box select: ${selectedNodes.length} nodes.`); updateMessage(); interaction.isInteractingNode = selectedNodes.length > 0; } else if (isDragSelectEnd) { console.log("Finalized Drag Select / Target Click"); if (nodeAtPointerUp && selectedNodes.length > 0) { const canSend = !(selectedNodes.length === 1 && selectedNodes[0] === nodeAtPointerUp); if (canSend) { console.log(`Drag release on target -> Sending`); selectedNodes.forEach(sourceNode => { if (sourceNode !== nodeAtPointerUp) sendUnits(sourceNode, nodeAtPointerUp); }); clearSelection(); } else { console.log("Drag release on same node -> Cancelling"); clearSelection(); } } else { console.log("Drag release on empty space -> Selection remains active"); interaction.isInteractingNode = true; } } else if (isTap) { console.log("Tap detected"); if (pointerData.downNode && nodeAtPointerUp === pointerData.downNode) { if (pointerData.downNode.owner === PLAYER) { console.log("Tap on own node"); if (selectedNodes.length === 1 && selectedNodes[0] === pointerData.downNode) { clearSelection(); } else { clearSelection(true); pointerData.downNode.isSelected = true; selectedNodes.push(pointerData.downNode); } updateMessage(); interaction.isInteractingNode = selectedNodes.length > 0; activeNodeButtons = []; } else { console.log("Tap on non-player node -> Clear"); clearSelection(); } } else { console.log("Tap on empty/different node -> Clear"); clearSelection(); } interaction.lastTapTime = time; interaction.lastTappedNodeForDoubleTap = pointerData.downNode; } else if (interaction.isPanning) { console.log("Pan end."); } interaction.pointers.delete(pointerId); } canvas.releasePointerCapture?.(pointerId); } const remainingPointers = interaction.pointers.size; if (remainingPointers === 0) { interaction.isPanning = false; interaction.isPinching = false; interaction.isBoxSelecting = false; interaction.pinchInitialDistance = 0; interaction.isInteractingNode = selectedNodes.length > 0; canvas.classList.remove('grabbing', 'panning', 'box-selecting'); if (!interaction.isInteractingNode) { interaction.currentPointerScreenPos = { x: null, y: null }; canvas.classList.remove('interacting-node'); canvas.style.cursor = 'default'; activeNodeButtons = []; } else { canvas.classList.add('interacting-node'); canvas.style.cursor = 'crosshair'; } } else if (remainingPointers === 1) { interaction.isPinching = false; interaction.pinchInitialDistance = 0; interaction.isBoxSelecting = false; const remainingPointerData = interaction.pointers.values().next().value; if (remainingPointerData && !remainingPointerData.isButtonPress) { remainingPointerData.initialScreenX = remainingPointerData.screenX; remainingPointerData.initialScreenY = remainingPointerData.screenY; const nodeUnderRemaining = findClosestNode(remainingPointerData.x, remainingPointerData.y); if ((remainingPointerData.pointerType === 'touch' && !nodeUnderRemaining) || remainingPointerData.button === 2) { interaction.isPanning = true; interaction.isInteractingNode = false; canvas.classList.add('panning', 'grabbing'); canvas.classList.remove('interacting-node', 'box-selecting'); } else { interaction.isPanning = false; interaction.isInteractingNode = selectedNodes.length > 0; canvas.classList.remove('panning', 'grabbing', 'box-selecting'); if(interaction.isInteractingNode) canvas.classList.add('interacting-node'); else canvas.style.cursor = 'default'; } } else { interaction.isPanning = false; interaction.isInteractingNode = selectedNodes.length > 0; canvas.classList.remove('panning', 'grabbing', 'box-selecting'); if(interaction.isInteractingNode) canvas.classList.add('interacting-node'); else canvas.style.cursor = 'default'; } } }
    function handlePointerOut(e) { const pointerData = interaction.pointers.get(e.pointerId ?? 0); if (pointerData && pointerData.button !== 2 && !pointerData.isButtonPress) { handlePointerUp(e); } }
    function preventContextMenu(e) { if (gameRunning) { e.preventDefault(); } }
    function handleWheel(e) { if (!gameRunning) return; e.preventDefault(); const zoomFactor = e.deltaY < 0 ? 1.15 : 1 / 1.15; const rect = canvas.getBoundingClientRect(); const screenX = e.clientX - rect.left; const screenY = e.clientY - rect.top; zoomAtPoint(screenX, screenY, zoomFactor); }
    function handleResize() { console.log("Window resized - Returning to start screen."); initializeApp(); }
    function handleGameOverClick() { if (!gameRunning && interaction.pointers.size === 0) initializeApp(); }

    // --- Inicialización ---
    function initializeApp() { gameContainer.style.display = 'none'; startScreenDiv.style.display = 'flex'; if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } gameRunning = false; canvas.removeEventListener('pointerdown', handlePointerDown); canvas.removeEventListener('pointermove', handlePointerMove); canvas.removeEventListener('pointerup', handlePointerUp); canvas.removeEventListener('pointercancel', handlePointerUp); canvas.removeEventListener('pointerout', handlePointerOut); canvas.removeEventListener('contextmenu', preventContextMenu); canvas.removeEventListener('wheel', handleWheel); window.removeEventListener('resize', handleResize); gameOverMessageDiv.removeEventListener('click', handleGameOverClick); canvas.removeEventListener('pointermove', handleAmbientPointerMove); canvas.removeEventListener('pointerleave', handleAmbientPointerLeave); interaction = { pointers: new Map(), isPanning: false, isPinching: false, isInteractingNode: false, isBoxSelecting: false, currentPointerScreenPos: { x: null, y: null } }; selectedNodes = []; activeNodeButtons = []; activeLasers = []; particles = []; ambientPointerScreenPos = { x: null, y: null }; console.log("App initialized, showing start screen."); }
    startButton.addEventListener('click', () => { const numNodesVal = parseInt(numNodesInput.value); const numEnemiesVal = parseInt(numEnemiesInput.value); if (isNaN(numNodesVal) || numNodesVal < parseInt(numNodesInput.min) || numNodesVal > parseInt(numNodesInput.max)) { alert(`Nodos inválidos. Entre ${numNodesInput.min}-${numNodesInput.max}.`); return; } if (isNaN(numEnemiesVal) || numEnemiesVal < parseInt(numEnemiesInput.min) || numEnemiesVal > parseInt(numEnemiesInput.max)) { alert(`Enemigos inválidos. Entre ${numEnemiesInput.min}-${numEnemiesInput.max}.`); return; } NUM_NEUTRAL_NODES_SETTING = numNodesVal; NUM_ENEMIES_SETTING = numEnemiesVal; startScreenDiv.style.display = 'none'; gameContainer.style.display = 'flex'; canvas.style.display = 'block'; addGameListeners(); startGameLogic(); });
    percentageButtonsContainer.addEventListener('click', (event) => { if (event.target.tagName === 'BUTTON') { const percent = parseFloat(event.target.getAttribute('data-percent')); if (!isNaN(percent)) { currentSendPercentage = percent; setActivePercentageButton(); } } });
    function addGameListeners() { canvas.addEventListener('pointerdown', handlePointerDown); canvas.addEventListener('pointermove', handlePointerMove); canvas.addEventListener('pointerup', handlePointerUp); canvas.addEventListener('pointercancel', handlePointerUp); canvas.addEventListener('pointerout', handlePointerOut); canvas.addEventListener('contextmenu', preventContextMenu); canvas.addEventListener('wheel', handleWheel, { passive: false }); window.addEventListener('resize', handleResize); gameOverMessageDiv.addEventListener('click', handleGameOverClick); canvas.addEventListener('pointermove', handleAmbientPointerMove); canvas.addEventListener('pointerleave', handleAmbientPointerLeave); }
    initializeApp();

</script>

</body>
</html>