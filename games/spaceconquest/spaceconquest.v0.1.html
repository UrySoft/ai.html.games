<!DOCTYPE html>
<html lang="ca"> <!-- Idioma por defecto CA -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Space Conquest v23.6.26</title> <!-- Version updated -->
    <!-- Import Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@400;700&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <!-- Soporte básico para CJK fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP&family=Noto+Sans+SC&display=swap" rel="stylesheet">
    <style>
        /* CSS Styles (sin cambios) */
        body { margin: 0; overflow: hidden; background-color: #020208; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: 'Exo 2', 'Noto Sans JP', 'Noto Sans SC', sans-serif; flex-direction: column; color: #eee; }
        canvas { display: block; background-color: #03030A; touch-action: none; max-width: 100%; cursor: default; image-rendering: optimizeSpeed; image-rendering: -moz-crisp-edges; image-rendering: -webkit-optimize-contrast; image-rendering: pixelated; }
        canvas.panning { cursor: grab; }
        canvas.panning.grabbing { cursor: grabbing; }
        canvas.interacting-node { cursor: crosshair; }
        canvas.box-selecting { cursor: crosshair; }
        #gameContainer { position: relative; width: 100%; height: 100%; display: none; justify-content: center; align-items: center; }
        #controls { position: absolute; top: 5px; left: 5px; right: 5px; background-color: rgba(10, 10, 25, 0.85); padding: 8px 12px; border-radius: 5px; color: #fff; font-size: 13px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; z-index: 10; pointer-events: none; border: 1px solid rgba(100, 120, 150, 0.5); box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3); }
        #controls > * { pointer-events: auto; margin: 2px 5px; }
        .control-group { display: flex; align-items: center; white-space: nowrap; }
        .control-group > span { margin-right: 8px; font-size: 14px; }
        .control-group button, #menuButton, #fullscreenButton, #pauseButton { padding: 5px 10px; font-size: 13px; font-family: 'Orbitron', sans-serif; cursor: pointer; border: none; background-color: #444; color: #fff; border-radius: 4px; transition: background-color .2s ease; margin-left: 4px; }
        .control-group button:hover, #menuButton:hover, #fullscreenButton:hover, #pauseButton:hover { background-color: #666; }
        .control-group button.active { background-color: #007bff; font-weight: 700; box-shadow: 0 0 5px rgba(0, 123, 255, 0.7); }
        #menuButton { background-color: #dc3545; margin-right: 10px; }
        #menuButton:hover { background-color: #e74c5b; }
        #fullscreenButton { background-color: #28a745; margin-right: 10px; }
        #fullscreenButton:hover { background-color: #34c759; }
        #pauseButton { background-color: #ffc107; color: #333; margin-left: 0; margin-right: 10px; }
        #pauseButton:hover { background-color: #ffda6a; }
        #pauseButton.paused { background-color: #17a2b8; color: #fff; }
        #pauseButton.paused:hover { background-color: #1bb1c7; }
        #message { line-height: 1.3; margin: 2px 10px; flex-grow: 1; font-size: 14px; text-align: center; min-width: 150px; }
        #gameOverMessage { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(10, 10, 25, 0.9); color: #fff; padding: 35px 50px; border-radius: 10px; text-align: center; font-size: 24px; display: none; z-index: 20; cursor: pointer; border: 1px solid rgba(100, 120, 150, 0.6); box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5); }
        #gameOverMessage h2 { margin-top: 0; font-size: 32px; margin-bottom: 20px; font-family: 'Orbitron', 'Noto Sans JP', 'Noto Sans SC', sans-serif; color: #00aaff; text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5); }
        #gameOverMessage p { font-size: 18px; margin-bottom: 0; }
        #startScreen { background-color: #040410; color: #eee; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 30; text-align: center; padding: 20px; box-sizing: border-box; width: 100vw; height: 100vh; font-family: 'Exo 2', 'Noto Sans JP', 'Noto Sans SC', sans-serif; }
        #startScreen h1 { margin-top: 0; margin-bottom: 10px; color: #00aaff; font-size: clamp(2.2em, 9vw, 4em); font-family: 'Orbitron', sans-serif; text-shadow: 2px 2px 5px rgba(0, 120, 180, 0.7); }
        #startScreen .version { font-size: clamp(0.8em, 2.2vw, 1em); color: #bbb; margin-bottom: 25px; }
        #startScreen .author { margin-bottom: 30px; font-size: clamp(0.9em, 3vw, 1.1em); color: #ccc; }
        #startScreen .author a { color: #6cf; text-decoration: none; }
        #startScreen .author a:hover { text-decoration: underline; color: #8df; }
        #startScreen .settings { background-color: rgba(20, 20, 40, 0.7); padding: 25px; border-radius: 8px; margin-bottom: 35px; max-width: 420px; width: 90%; border: 1px solid rgba(100, 120, 150, 0.4); }
        #startScreen .setting-item { margin-bottom: 18px; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; }
        #startScreen label { margin-right: 10px; text-align: left; flex-basis: calc(60% - 10px); margin-bottom: 5px; font-size: clamp(0.95em, 2.6vw, 1.05em); }
        #startScreen input[type=number], #startScreen select { width: 75px; padding: 9px; border-radius: 4px; border: 1px solid #667; background-color: #2a2a3a; color: #eee; text-align: center; flex-basis: calc(35% - 10px); font-size: clamp(0.9em, 2.5vw, 1em); -moz-appearance: textfield; box-sizing: border-box; }
        #startScreen select { text-align-last: center; padding-right: 15px; appearance: none; -webkit-appearance: none; -moz-appearance: none; background: #2a2a3a url('data:image/svg+xml;utf8,<svg fill="white" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>') no-repeat right 5px center; background-size: 18px 18px; }
        #startScreen select#languageSelect { width: auto; flex-basis: calc(35% - 10px); }
        #startScreen input[type=number]::-webkit-inner-spin-button, #startScreen input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        #startScreen .setting-item.toggle-item { justify-content: center; }
        #startScreen .setting-item.toggle-item label { flex-basis: auto; margin-right: 10px; text-align: right; }
        #startScreen .setting-item.toggle-item input[type="checkbox"] { width: auto; flex-basis: auto; margin-left: 0; }
        #startButton { padding: 14px 40px; font-size: clamp(1.1em, 4.5vw, 1.4em); cursor: pointer; background-color: #08c; color: #fff; border: none; border-radius: 5px; transition: background-color .2s ease, transform .1s ease; text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.6); font-family: 'Orbitron', 'Noto Sans JP', 'Noto Sans SC', sans-serif; box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4); }
        #startButton:hover { background-color: #0af; transform: translateY(-1px); }
        #startButton:active { transform: translateY(0); }
        #startButton:disabled { background-color: #555; cursor: not-allowed; }
        #introVideoContainer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #000; z-index: 100; display: none; }
        #introVideo { width: 100%; height: 100%; object-fit: cover; }
    </style>
</head>
<body>
    <!-- Start Screen -->
    <div id="startScreen">
        <h1>Space Conquest</h1>
        <div class="version">v23.6.26</div> <!-- Version only -->
        <p class="author" id="authorText">per <a href="https://www.linkedin.com/in/oriol-badia" target="_blank" rel="noopener noreferrer">Oriol Badia Campanera</a></p>
        <div class="settings">
             <div class="setting-item"> <label for="languageSelect" id="languageLabel">Idioma:</label> <select id="languageSelect"> <option value="ca" selected>Català</option> <option value="es">Español</option> <option value="en">English</option> <option value="ja">日本語</option> <option value="zh">中文</option> </select> </div>
             <div class="setting-item"> <label for="numNodesInput" id="neutralNodesLabel">Nodes Neutrals (4-100):</label> <input type="number" id="numNodesInput" value="20" min="4" max="100"> </div>
            <div class="setting-item"> <label for="numEnemiesInput" id="enemiesLabel">Enemics IA (1-5):</label> <input type="number" id="numEnemiesInput" value="1" min="1" max="5"> </div>
            <div class="setting-item"> <label for="aiDifficultySelect" id="aiLevelLabel">Nivell IA:</label> <select id="aiDifficultySelect"> <option value="basic" id="aiLevelBasic">Bàsica</option> <option value="normal" id="aiLevelNormal" selected>Normal</option> <option value="expert" id="aiLevelExpert">Experta</option> </select> </div>
            <div class="setting-item toggle-item"> <label for="soundCheckbox" id="musicLabel">Música ambient:</label> <input type="checkbox" id="soundCheckbox" checked> </div>
            <div class="setting-item toggle-item"> <label for="backgroundCheckbox" id="showBackgroundLabel" title="Fons cortesia de JWST/NASA/ESA/CSA">Fons JWST:</label> <input type="checkbox" id="backgroundCheckbox" checked> </div>
        </div>
        <button id="startButton" disabled>Carregant Recursos...</button>
    </div>

    <!-- Contenedor del Vídeo de Intro -->
    <div id="introVideoContainer"> <video id="introVideo" preload="auto" playsinline> <source src="http://urysoft.github.io/ai.html.games/general/assets/videos/Interstellar.mp4" type="video/mp4"> Tu navegador no soporta el elemento de vídeo. </video> </div>

    <!-- Game Container -->
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="controls">
            <!-- Left Controls -->
            <div class="control-group">
                <button id="menuButton">Reiniciar</button>
                <button id="fullscreenButton" title="Pantalla Completa/Sortir">FS</button>
                <button id="pauseButton">Pausa</button>
            </div>
            <!-- Center Message -->
            <div id="message">...</div>
             <!-- Right Controls -->
             <div class="control-group">
                <div id="speedControls" class="control-group">
                    <span id="speedLabel">Vel:</span>
                    <button data-speed="1" class="active">x1</button>
                    <button data-speed="2">x2</button>
                    <button data-speed="4">x4</button>
                </div>
                <div id="percentageButtons" class="control-group">
                    <span id="sendLabel">Enviar:</span>
                    <button data-percent="0.25">25%</button>
                    <button data-percent="0.50" class="active">50%</button>
                    <button data-percent="0.75">75%</button>
                    <button data-percent="1.00">100%</button>
                </div>
            </div>
        </div>
        <div id="gameOverMessage"> <h2 id="gameOverTitle"></h2> <p id="restartPrompt">Toca per reiniciar.</p> </div>
    </div>
    <!-- Audio Elements -->
    <audio id="ambientAudio1" src="http://urysoft.github.io/ai.html.games/general/assets/sounds/conquesttheme1.mp3" preload="auto" loop></audio>
    <audio id="ambientAudio2" src="http://urysoft.github.io/ai.html.games/general/assets/sounds/conquesttheme2.mp3" preload="auto" loop></audio>
    <audio id="laserSound" src="http://urysoft.github.io/ai.html.games/general/assets/sounds/blaster2.mp3" preload="auto"></audio>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Elementos del DOM ---
            const canvas = document.getElementById('gameCanvas');
            if (!canvas) { console.error("¡Error Fatal! No se encontró el elemento canvas con ID 'gameCanvas'."); return; }
            const ctx = canvas.getContext('2d', { alpha: false });
            const messageDiv = document.getElementById('message');
            const percentageButtonsContainer = document.getElementById('percentageButtons');
            const gameOverMessageDiv = document.getElementById('gameOverMessage');
            const gameOverTitle = document.getElementById('gameOverTitle');
            const startScreenDiv = document.getElementById('startScreen');
            const numNodesInput = document.getElementById('numNodesInput');
            const numEnemiesInput = document.getElementById('numEnemiesInput');
            const startButton = document.getElementById('startButton');
            const gameContainer = document.getElementById('gameContainer');
            const menuButton = document.getElementById('menuButton');
            const aiDifficultySelect = document.getElementById('aiDifficultySelect');
            const soundCheckbox = document.getElementById('soundCheckbox');
            const ambientAudio1 = document.getElementById('ambientAudio1');
            const ambientAudio2 = document.getElementById('ambientAudio2');
            const laserSound = document.getElementById('laserSound');
            const languageSelect = document.getElementById('languageSelect');
            const languageLabel = document.getElementById('languageLabel');
            const neutralNodesLabel = document.getElementById('neutralNodesLabel');
            const enemiesLabel = document.getElementById('enemiesLabel');
            const aiLevelLabel = document.getElementById('aiLevelLabel');
            const aiLevelBasic = document.getElementById('aiLevelBasic');
            const aiLevelNormal = document.getElementById('aiLevelNormal');
            const aiLevelExpert = document.getElementById('aiLevelExpert');
            const musicLabel = document.getElementById('musicLabel');
            const authorText = document.getElementById('authorText');
            const sendLabel = document.getElementById('sendLabel');
            const restartPrompt = document.getElementById('restartPrompt');
            const introVideoContainer = document.getElementById('introVideoContainer');
            const introVideo = document.getElementById('introVideo');
            const fullscreenButton = document.getElementById('fullscreenButton');
            const speedControlsContainer = document.getElementById('speedControls');
            const speedLabel = document.getElementById('speedLabel');
            const pauseButton = document.getElementById('pauseButton');
            const backgroundCheckbox = document.getElementById('backgroundCheckbox');
            const showBackgroundLabel = document.getElementById('showBackgroundLabel');

            // --- Configuración Global ---
            const PLAYER = 1; const NEUTRAL = 0;
            const PLAYER_COLOR = 'rgba(0, 150, 255, 1)'; const AI_COLORS = ['rgba(255, 50, 50, 1)','rgba(50, 200, 50, 1)','rgba(255, 150, 0, 1)','rgba(200, 0, 200, 1)','rgba(255, 255, 50, 1)']; const NEUTRAL_COLOR = 'rgba(120, 120, 120, 1)'; const SELECTED_COLOR = 'rgba(255, 255, 0, 0.9)'; const ATTACK_INDICATOR_COLOR = 'rgba(255, 0, 0, 1)'; const BOX_SELECT_COLOR = 'rgba(0, 150, 255, 0.4)';
            const BUTTON_ENABLED_COLOR = 'rgba(0, 180, 0, 0.85)'; const BUTTON_DISABLED_COLOR = 'rgba(90, 90, 90, 0.8)';
            const UNIT_RADIUS = 2.0; const NODE_RADIUS_BASE = 35; const NODE_RADIUS_RANDOM_FACTOR = 0.4;
            const NODE_RADIUS_PER_UNIT = 0.02; const NODE_RADIUS_PER_LEVEL = 2.5; const MAX_NODE_LEVEL = 5; const UNIT_CAPACITY_PER_LEVEL = 100; const GENERATION_INTERVAL = 1050;
            let UNIT_SPEED = 0.1; let AI_ACTION_INTERVAL = 950; let AI_UPGRADE_CHANCE = 0.25;
            const SELECTION_LINE_WIDTH = 4.0; const POINTER_MARKER_RADIUS = 7; const ATTACK_INDICATOR_DURATION = 1500; const ATTACK_INDICATOR_BLINK_RATE = 200;
            const MAX_SATELLITES_PER_NODE = 5; const SATELLITE_ORBIT_RADIUS_BASE = 18; const SATELLITE_ORBIT_SPEED = 0.0125; const SATELLITE_RADIUS = 4.5; const SATELLITE_RANGE = 200; const SATELLITE_FIRE_RATE_BASE = 200; const SATELLITE_LASER_DURATION = 90;
            const SPACE_STATION_MIN_LEVEL = 5; const SPACE_STATION_COST = 2000; const SPACE_STATION_RADIUS = 30;
            const SPACE_STATION_ORBIT_RADIUS_FACTOR = 3.2; const SPACE_STATION_ORBIT_SPEED_FACTOR = 0.03;
            const SPACE_STATION_DEFENSE_BONUS = 600; const EXPLOSION_PARTICLE_COUNT = 15;
            const SHADOW_MIN_ZOOM = 0.4; const AURA_CIRCLE_MIN_ZOOM = 0.3; const AURA_BLUR_FACTOR = 1.8; const AURA_ALPHA = '0.9';
            const NODE_TEXT_MIN_SCREEN_SIZE = 9; const NODE_TEXT_MAX_SCREEN_SIZE = 22; const STATION_TEXT_MIN_SCREEN_SIZE = 8; const STATION_TEXT_MAX_SCREEN_SIZE = 18;
            const WORLD_WIDTH = 6000; const WORLD_HEIGHT = 4000; const MIN_NODE_DISTANCE = 100;
            const INITIAL_CAMERA_ZOOM = 1.0; let NUM_NEUTRAL_NODES_SETTING = 20; let NUM_ENEMIES_SETTING = 1; let aiDifficultySetting = "normal"; let cameraX = 0; let cameraY = 0; let cameraZoom = INITIAL_CAMERA_ZOOM; let minZoomToFitWorld = 0.1; const ABSOLUTE_MIN_ZOOM = 0.05; const MAX_ZOOM = 2.5;
            const NUM_STARS = 3000; const MINIMAP_ENABLED = true; const MINIMAP_WIDTH = 180; const MINIMAP_HEIGHT = (MINIMAP_WIDTH / WORLD_WIDTH) * WORLD_HEIGHT; const MINIMAP_MARGIN = 12; const MINIMAP_NODE_SIZE = 3.0; const MINIMAP_CAMERA_COLOR = 'rgba(255, 255, 255, 0.7)';
            const UNIT_COLLISION_DIST_SQ = (UNIT_RADIUS * 1.6) * (UNIT_RADIUS * 1.6); const GRID_CELL_SIZE = SATELLITE_RANGE * 1.5;
            const DOUBLE_TAP_DELAY = 300; const TAP_DURATION_THRESHOLD = 250; const TAP_MOVEMENT_THRESHOLD = 10; const DRAG_THRESHOLD_FOR_ACTION = 15;
            const TOUCH_SEARCH_RADIUS_WORLD = 120;
            const SMART_DROP_SEARCH_RADIUS_FACTOR = 2.0;
            const MIN_NODE_SCREEN_RADIUS = 15.0;
            const MIN_STATION_SCREEN_RADIUS = 10.0;
            const PLANET_IMAGE_COUNT = 13; const planetImageURLs = []; const planetImages = []; const PLANET_IMAGE_PATH = "http://urysoft.github.io/ai.html.games/general/assets/images/";
            for (let i = 1; i <= PLANET_IMAGE_COUNT; i++) { planetImageURLs.push(`${PLANET_IMAGE_PATH}planeta${i}.png`); }
            const stationImagePlayerURL = `${PLANET_IMAGE_PATH}station4.png`; const stationImageAIURL = `${PLANET_IMAGE_PATH}station3.png`;
            const BACKGROUND_IMAGE_COUNT = 11; const backgroundImageURLs = [];
            for (let i = 1; i <= BACKGROUND_IMAGE_COUNT; i++) { backgroundImageURLs.push(`${PLANET_IMAGE_PATH}universo${i}.png`); }
            let stationImagePlayer = null; let stationImageAI = null;
            let backgroundImages = []; let currentBackgroundImage = null;

            // --- Estado del Juego ---
            let stars = []; let nodes = []; let units = [];
            let selectedEntities = [];
            let particles = []; let activeLasers = []; let activeNodeButtons = [];
            let currentSendPercentage = 0.50; let lastUpdateTime = 0; let lastAiActionTime = 0; let animationFrameId;
            let gameRunning = false; let gamePaused = false; let showBackgroundSetting = true;
            let spatialGrid; let soundEnabled = true; let imagesLoaded = false; let loadedImageCount = 0;
            let totalImagesToLoad = planetImageURLs.length + 2 + backgroundImageURLs.length;
            let currentAmbientTrack = null; let firstInteractionDone = false; let currentLanguage = 'ca'; let gameSpeedMultiplier = 1.0;
            let ambientPointerScreenPos = { x: null, y: null };
            let interaction = { pointers: new Map(), lastTapTime: 0, lastTappedNodeForDoubleTap: null, isInteractingNode: false, isPanning: false, isPinching: false, isBoxSelecting: false, pinchInitialDistance: 0, currentPointerScreenPos: { x: null, y: null }, boxStartScreenX: 0, boxStartScreenY: 0, };

            // --- Textos de Traducción (i18n) ---
            const translations = {
                ca: { languageLabel: "Idioma:", neutralNodesLabel: "Nodes Neutrals (4-100):", enemiesLabel: "Enemics IA (1-5):", aiLevelLabel: "Nivell IA:", aiLevelBasic: "Bàsica", aiLevelNormal: "Normal", aiLevelExpert: "Experta", musicLabel: "Música ambient:", showBackgroundLabel: "Fons JWST:", authorText: "per", loading: "Carregant Recursos...", startGame: "Iniciar Joc", menuButton: "Reiniciar", sendLabel: "Enviar:", messageTapDrag: "Toca/Arrossega", messageSending: "Enviar", messageNode: "Node", messageNodes: "Nodes", messageStation: "Estació", messageStations: "Estacions", messageEntities: "Entitats", messageUnits: "U", messageLvl: "L", messageUpgrade: "Millora", messageSatellite: "Sat", messageMax: "MAX", victory: "VICTÒRIA!", defeat: "DERROTA", tie: "EMPAT ESTEL·LAR", restartPrompt: "Toca per reiniciar.", invalidNodes: (min, max) => `Nodes invàlids. Introdueix ${min}-${max}.`, invalidEnemies: (min, max) => `Enemics invàlids. Introdueix ${min}-${max}.`, fullscreenButtonTitle: "Pantalla Completa/Sortir", speedLabel: "Vel:", restartConfirm: "Segur que vols reiniciar? Es perdrà el progrés actual.", pauseButton: "Pausa", resumeButton: "Reprèn" },
                es: { languageLabel: "Idioma:", neutralNodesLabel: "Nodos Neutrales (4-100):", enemiesLabel: "Enemigos IA (1-5):", aiLevelLabel: "Nivel IA:", aiLevelBasic: "Básica", aiLevelNormal: "Normal", aiLevelExpert: "Experta", musicLabel: "Música ambiente:", showBackgroundLabel: "Fondo JWST:", authorText: "por", loading: "Cargando Recursos...", startGame: "Iniciar Juego", menuButton: "Reiniciar", sendLabel: "Enviar:", messageTapDrag: "Toca/Arrastra", messageSending: "Enviar", messageNode: "Nodo", messageNodes: "Nodos", messageStation: "Estación", messageStations: "Estaciones", messageEntities: "Entidades", messageUnits: "U", messageLvl: "L", messageUpgrade: "Mejora", messageSatellite: "Sat", messageMax: "MAX", victory: "¡VICTORIA!", defeat: "DERROTA", tie: "EMPATE ESTELAR", restartPrompt: "Toca para reiniciar.", invalidNodes: (min, max) => `Nodos inválidos. Introduce ${min}-${max}.`, invalidEnemies: (min, max) => `Enemigos inválidos. Introduce ${min}-${max}.`, fullscreenButtonTitle: "Pantalla Completa/Salir", speedLabel: "Vel:", restartConfirm: "¿Seguro que quieres reiniciar? Se perderá el progreso actual.", pauseButton: "Pausa", resumeButton: "Reanudar" },
                en: { languageLabel: "Language:", neutralNodesLabel: "Neutral Nodes (4-100):", enemiesLabel: "AI Enemies (1-5):", aiLevelLabel: "AI Level:", aiLevelBasic: "Basic", aiLevelNormal: "Normal", aiLevelExpert: "Expert", musicLabel: "Ambient Music:", showBackgroundLabel: "JWST Background:", authorText: "by", loading: "Loading Resources...", startGame: "Start Game", menuButton: "Restart", sendLabel: "Send:", messageTapDrag: "Tap/Drag", messageSending: "Send", messageNode: "Node", messageNodes: "Nodes", messageStation: "Station", messageStations: "Stations", messageEntities: "Entities", messageUnits: "U", messageLvl: "Lvl", messageUpgrade: "Upgrade", messageSatellite: "Sat", messageMax: "MAX", victory: "VICTORY!", defeat: "DEFEAT", tie: "STELLAR DRAW", restartPrompt: "Tap to restart.", invalidNodes: (min, max) => `Invalid nodes. Enter ${min}-${max}.`, invalidEnemies: (min, max) => `Invalid enemies. Enter ${min}-${max}.`, fullscreenButtonTitle: "Fullscreen/Exit", speedLabel: "Speed:", restartConfirm: "Are you sure you want to restart? Current progress will be lost.", pauseButton: "Pause", resumeButton: "Resume" },
                ja: { languageLabel: "言語:", neutralNodesLabel: "中立ノード (4-100):", enemiesLabel: "AI敵 (1-5):", aiLevelLabel: "AIレベル:", aiLevelBasic: "基本", aiLevelNormal: "ノーマル", aiLevelExpert: "エキスパート", musicLabel: "環境音楽:", showBackgroundLabel: "JWST背景:", authorText: "作", loading: "リソースを読み込み中...", startGame: "ゲーム開始", menuButton: "リスタート", sendLabel: "送信:", messageTapDrag: "タップ/ドラッグ", messageSending: "送信", messageNode: "ノード", messageNodes: "ノード", messageStation: "ステーション", messageStations: "ステーション", messageEntities: "エンティティ", messageUnits: "U", messageLvl: "L", messageUpgrade: "アップグレード", messageSatellite: "衛星", messageMax: "最大", victory: "勝利！", defeat: "敗北", tie: "引き分け", restartPrompt: "タップして再起動", invalidNodes: (min, max) => `無効なノード。${min}から${max}入力してください。`, invalidEnemies: (min, max) => `無効な敵。${min}から${max}入力してください。`, fullscreenButtonTitle: "全画面表示/終了", speedLabel: "速度:", restartConfirm: "本当にリスタートしますか？現在の進行状況は失われます。", pauseButton: "一時停止", resumeButton: "再開" },
                zh: { languageLabel: "语言:", neutralNodesLabel: "中立节点 (4-100):", enemiesLabel: "AI敌人 (1-5):", aiLevelLabel: "AI 等级:", aiLevelBasic: "基础", aiLevelNormal: "普通", aiLevelExpert: "专家", musicLabel: "环境音乐:", showBackgroundLabel: "JWST 背景:", authorText: "作者", loading: "正在加载资源...", startGame: "开始游戏", menuButton: "重新开始", sendLabel: "发送:", messageTapDrag: "点击/拖动", messageSending: "发送", messageNode: "节点", messageNodes: "节点", messageStation: "空间站", messageStations: "空间站", messageEntities: "实体", messageUnits: "单位", messageLvl: "等级", messageUpgrade: "升级", messageSatellite: "卫星", messageMax: "最大", victory: "胜利！", defeat: "失败", tie: "平局", restartPrompt: "点击重新开始。", invalidNodes: (min, max) => `无效节点。请输入 ${min}-${max}。`, invalidEnemies: (min, max) => `无效敌人。请输入 ${min}-${max}。`, fullscreenButtonTitle: "全屏/退出", speedLabel: "速度:", restartConfirm: "确定要重新开始吗？当前进度将丢失。", pauseButton: "暂停", resumeButton: "继续" }
            };

            // --- Funciones Utilitarias y de Estado ---
            function getText(key) { const langTexts = translations[currentLanguage] || translations['en']; const textOrFunc = langTexts[key]; if (typeof textOrFunc === 'function') { const args = Array.prototype.slice.call(arguments, 1); return textOrFunc.apply(null, args); } return textOrFunc || `[${key}]`; }
            function updateLanguage() { document.documentElement.lang = currentLanguage; languageLabel.textContent = getText('languageLabel'); neutralNodesLabel.textContent = getText('neutralNodesLabel'); enemiesLabel.textContent = getText('enemiesLabel'); aiLevelLabel.textContent = getText('aiLevelLabel'); aiLevelBasic.textContent = getText('aiLevelBasic'); aiLevelNormal.textContent = getText('aiLevelNormal'); aiLevelExpert.textContent = getText('aiLevelExpert'); musicLabel.textContent = getText('musicLabel'); showBackgroundLabel.textContent = getText('showBackgroundLabel'); authorText.innerHTML = `${getText('authorText')} <a href="https://www.linkedin.com/in/oriol-badia" target="_blank" rel="noopener noreferrer">Oriol Badia Campanera</a>`; startButton.textContent = imagesLoaded ? getText('startGame') : getText('loading'); menuButton.textContent = getText('menuButton'); sendLabel.textContent = getText('sendLabel'); restartPrompt.textContent = getText('restartPrompt'); fullscreenButton.title = getText('fullscreenButtonTitle'); speedLabel.textContent = getText('speedLabel'); pauseButton.textContent = gamePaused ? getText('resumeButton') : getText('pauseButton'); if (gameRunning) { updateMessage(); } else { messageDiv.innerHTML = '...'; } }
            function controlSound() { soundEnabled = soundCheckbox.checked; try { if (soundEnabled) { if (firstInteractionDone && (!currentAmbientTrack || currentAmbientTrack.paused)) { currentAmbientTrack = ambientAudio1; ambientAudio1.play().catch(e => { console.warn("Ambient 1 play failed on interaction:", e); currentAmbientTrack = ambientAudio2; ambientAudio2.play().catch(e2 => console.warn("Ambient 2 play also failed:", e2)); }); if (ambientAudio2 && !ambientAudio2.paused && currentAmbientTrack === ambientAudio1) ambientAudio2.pause(); else if (ambientAudio1 && !ambientAudio1.paused && currentAmbientTrack === ambientAudio2) ambientAudio1.pause(); } else if (!firstInteractionDone) { if (ambientAudio1 && !ambientAudio1.paused) ambientAudio1.pause(); if (ambientAudio2 && !ambientAudio2.paused) ambientAudio2.pause(); currentAmbientTrack = ambientAudio1; } } else { if (ambientAudio1 && !ambientAudio1.paused) ambientAudio1.pause(); if (ambientAudio2 && !ambientAudio2.paused) ambientAudio2.pause(); currentAmbientTrack = null; } } catch (e) { console.error("Error controlling ambient audio:", e); } }
            function handleFirstInteraction() { if (firstInteractionDone) return; firstInteractionDone = true; console.log("First user interaction detected."); if (soundEnabled && currentAmbientTrack && currentAmbientTrack.paused) { currentAmbientTrack.play().catch(e => console.warn("Still couldn't play sound after interaction:", e)); } document.removeEventListener('pointerdown', handleFirstInteraction); document.removeEventListener('keydown', handleFirstInteraction); }
            function updateMessage() { if (!gameRunning && startScreenDiv.style.display === 'flex') { messageDiv.innerHTML = '...'; return; } let msg = ""; const percentageText = `${Math.round(currentSendPercentage * 100)}%`; if (selectedEntities.length === 0) { msg = `${getText('messageTapDrag')} | ${getText('sendLabel')} ${percentageText}`; } else if (selectedEntities.length === 1) { const entity = selectedEntities[0]; if (entity instanceof Node) { const node = entity; const upgradeCost = calculateUpgradeCost(node); let upgradeText = upgradeCost === Infinity ? `(${getText('messageMax')})` : `(${getText('messageUpgrade')}: ${upgradeCost} ${getText('messageUnits')})`; let satelliteText = node.satellites.length > 0 ? ` (${node.satellites.length}/${MAX_SATELLITES_PER_NODE} ${getText('messageSatellite')})` : ""; let buildSatText = ""; if(node.satellites.length < MAX_SATELLITES_PER_NODE) { const satCost = calculateSatelliteCost(node); buildSatText = ` (${getText('messageSatellite')}: ${satCost} ${getText('messageUnits')})`; } let stationText = ""; if(node.hasSpaceStation && node.stationObject) { stationText = ` (${getText('messageStation')}: ${Math.floor(node.stationObject.unitCount)} ${getText('messageUnits')})`; } else if (node.level >= SPACE_STATION_MIN_LEVEL) { stationText = ` (${getText('messageStation')}: ${SPACE_STATION_COST} ${getText('messageUnits')})`; } let unitsAvailable = Math.floor(node.unitCount); let unitsToSend = 0; if (currentSendPercentage === 1.0 && unitsAvailable > 1) unitsToSend = unitsAvailable - 1; else unitsToSend = Math.floor(unitsAvailable * currentSendPercentage); if (unitsToSend === 0 && unitsAvailable >= 1 && currentSendPercentage > 0) unitsToSend = 1; unitsToSend = Math.min(unitsToSend, unitsAvailable); msg = `${getText('messageNode')}: ${unitsAvailable}/${node.getMaxCapacity()} ${getText('messageUnits')} ${getText('messageLvl')}${node.level}${satelliteText}${stationText} ${upgradeText}${buildSatText} | ${getText('messageSending')} ${unitsToSend} (${percentageText})`; } else if (entity instanceof SpaceStation) { const station = entity; let unitsAvailable = Math.floor(station.unitCount); let unitsToSend = 0; if (currentSendPercentage === 1.0 && unitsAvailable > 1) unitsToSend = unitsAvailable - 1; else unitsToSend = Math.floor(unitsAvailable * currentSendPercentage); if (unitsToSend === 0 && unitsAvailable >= 1 && currentSendPercentage > 0) unitsToSend = 1; unitsToSend = Math.min(unitsToSend, unitsAvailable); msg = `${getText('messageStation')}: ${unitsAvailable} ${getText('messageUnits')} | ${getText('messageSending')} ${unitsToSend} (${percentageText})`; } } else { let nodeCount = 0; let stationCount = 0; let totalUnits = 0; let totalUnitsToSend = 0; selectedEntities.forEach(entity => { let unitsAvailable = 0; if (entity instanceof Node) { nodeCount++; unitsAvailable = Math.floor(entity.unitCount); } else if (entity instanceof SpaceStation) { stationCount++; unitsAvailable = Math.floor(entity.unitCount); } totalUnits += unitsAvailable; let unitsFromThis = 0; if (currentSendPercentage === 1.0 && unitsAvailable > 1) unitsFromThis = unitsAvailable - 1; else unitsFromThis = Math.floor(unitsAvailable * currentSendPercentage); if (unitsFromThis === 0 && unitsAvailable >= 1 && currentSendPercentage > 0) unitsFromThis = 1; totalUnitsToSend += Math.min(unitsFromThis, unitsAvailable); }); let entityText = `${selectedEntities.length} ${getText('messageEntities')}`; if (nodeCount > 0 && stationCount > 0) entityText = `${nodeCount} ${getText(nodeCount > 1 ? 'messageNodes':'messageNode')} + ${stationCount} ${getText(stationCount > 1 ? 'messageStations':'messageStation')}`; else if (nodeCount > 0) entityText = `${nodeCount} ${getText(nodeCount > 1 ? 'messageNodes':'messageNode')}`; else if (stationCount > 0) entityText = `${stationCount} ${getText(stationCount > 1 ? 'messageStations':'messageStation')}`; msg = `${entityText}: ${Math.floor(totalUnits)} ${getText('messageUnits')} | ${getText('messageSending')} ~${totalUnitsToSend} (${percentageText})`; } messageDiv.innerHTML = msg; }
            function preloadImages(callback) { console.log("Preloading images..."); loadedImageCount = 0; planetImages.length = 0; backgroundImages = []; stationImagePlayer = null; stationImageAI = null; currentBackgroundImage = null; let allURLs = [...planetImageURLs, stationImagePlayerURL, stationImageAIURL, ...backgroundImageURLs]; totalImagesToLoad = allURLs.length; console.log(`Total images to load: ${totalImagesToLoad}`); function checkCompletion(imgSrc, status) { loadedImageCount++; console.log(`Image loaded/errored: ${imgSrc} (${status}). Count: ${loadedImageCount}/${totalImagesToLoad}`); if (loadedImageCount === totalImagesToLoad) { imagesLoaded = true; console.log(`All ${totalImagesToLoad} images preload check complete. BG Count: ${backgroundImages.length}, PlayerStation: ${!!stationImagePlayer}, AIStation: ${!!stationImageAI}`); if (callback) { console.log("Calling preload completion callback."); callback(); } else { console.warn("Preload callback is missing!"); } } } function loadImage(url, targetVar) { console.log(`Attempting to load: ${url} for ${targetVar}`); const img = new Image(); img.onload = () => { if (targetVar === 'planet') { planetImages.push(img); } else if (targetVar === 'stationPlayer') { stationImagePlayer = img; } else if (targetVar === 'stationAI') { stationImageAI = img; } else if (targetVar === 'background') { backgroundImages.push(img); } checkCompletion(url, 'success'); }; img.onerror = (err) => { console.error(`Failed to load image: ${url}`, err); if (targetVar === 'stationPlayer') stationImagePlayer = null; if (targetVar === 'stationAI') stationImageAI = null; checkCompletion(url, 'error'); }; img.src = url; } planetImageURLs.forEach(url => loadImage(url, 'planet')); loadImage(stationImagePlayerURL, 'stationPlayer'); loadImage(stationImageAIURL, 'stationAI'); backgroundImageURLs.forEach(url => loadImage(url, 'background')); }

            // --- Definiciones de Clases (sin cambios relevantes aquí) ---
            class Particle { constructor(x, y, color, type = 'explosion') { this.x = x; this.y = y; this.color = color; this.type = type; this.radius = Math.random() * 2.0 + 1.0; this.life = 450 + Math.random() * 450; this.alpha = 1.0; const angle = Math.random() * Math.PI * 2; const speed = (Math.random() * 1.8 + 0.6) * 0.01; this.vx = Math.cos(angle) * speed; this.vy = Math.sin(angle) * speed; this.initialLife = this.life; this.initialAlpha = this.alpha; } update(deltaTime) { this.life -= deltaTime; if (this.life <= 0) return true; this.x += this.vx * deltaTime; this.y += this.vy * deltaTime; this.alpha = Math.max(0, (this.life / this.initialLife) * this.initialAlpha); const decay = Math.pow(0.97, deltaTime / 16.66); this.vx *= decay; this.vy *= decay; return false; } draw() { ctx.save(); ctx.globalAlpha = this.alpha; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.restore(); } }
            function calculateUpgradeCost(node) { if (node.level >= MAX_NODE_LEVEL) return Infinity; const targetLevel = node.level + 1; const targetCapacity = targetLevel * UNIT_CAPACITY_PER_LEVEL; return targetCapacity * 2; }
            function calculateSatelliteCost(node) { const baseCost = 50; if (node.satellites.length === 0) return baseCost; return baseCost * Math.pow(2, node.satellites.length); }
            class SpaceStation { constructor(parentNode, owner) { this.parentNode = parentNode; this.owner = owner; this.unitCount = 0; this.radius = SPACE_STATION_RADIUS; this.angle = Math.random() * Math.PI * 2; this.orbitRadiusOffset = SATELLITE_ORBIT_RADIUS_BASE * SPACE_STATION_ORBIT_RADIUS_FACTOR; this.orbitSpeed = SATELLITE_ORBIT_SPEED * SPACE_STATION_ORBIT_SPEED_FACTOR; this.image = (owner === PLAYER) ? stationImagePlayer : stationImageAI; this.x = 0; this.y = 0; this._isSelected = false; this.updatePosition(); } get isSelected() { return this._isSelected; } set isSelected(value) { const currentlySelected = selectedEntities.includes(this); if (value && !currentlySelected) { selectedEntities.push(this); this._isSelected = true; } else if (!value && currentlySelected) { const index = selectedEntities.indexOf(this); if (index > -1) selectedEntities.splice(index, 1); this._isSelected = false; } else { this._isSelected = value; } } getColor() { return this.parentNode.getColor(); } updatePosition() { const zoomFactor = Math.max(0.1, Math.pow(cameraZoom, 0.7)); const orbitRadius = this.parentNode.radius + this.orbitRadiusOffset / zoomFactor; this.x = this.parentNode.x + Math.cos(this.angle) * orbitRadius; this.y = this.parentNode.y + Math.sin(this.angle) * orbitRadius; } update(deltaTime) { if (gamePaused) return; this.angle += this.orbitSpeed * (deltaTime / 16.66); if (this.angle > Math.PI * 2) this.angle -= Math.PI * 2; this.updatePosition(); } draw() { const logicalRadius = this.radius; const standardScreenRadius = logicalRadius * cameraZoom; const actualScreenRadius = Math.max(MIN_STATION_SCREEN_RADIUS, standardScreenRadius); const drawRadius = actualScreenRadius / cameraZoom; const useShadow = cameraZoom >= SHADOW_MIN_ZOOM; if (useShadow) { ctx.shadowBlur = 15; ctx.shadowColor = this.parentNode.getColor().replace('1)', '0.6)'); } if (this.image && this.image.complete) { try { ctx.drawImage(this.image, this.x - drawRadius, this.y - drawRadius, drawRadius * 2, drawRadius * 2); } catch (e) { this.drawFallback(drawRadius); } } else { this.drawFallback(drawRadius); } if (useShadow) ctx.shadowBlur = 0; if (this.isSelected) { ctx.strokeStyle = SELECTED_COLOR; ctx.lineWidth = SELECTION_LINE_WIDTH / cameraZoom; ctx.beginPath(); ctx.arc(this.x, this.y, drawRadius + 6 / cameraZoom, 0, Math.PI * 2); ctx.stroke(); } if (this.unitCount > 0) { ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; const textPadding = 3 / cameraZoom; const textBgAlpha = 0.6; const targetUnitScreenSize = Math.max(STATION_TEXT_MIN_SCREEN_SIZE, Math.min(STATION_TEXT_MAX_SCREEN_SIZE, (drawRadius * 0.4) * cameraZoom)); const unitFontWorldSize = targetUnitScreenSize / cameraZoom; ctx.font = `bold ${unitFontWorldSize}px 'Exo 2', sans-serif`; const unitText = `${Math.floor(this.unitCount)}`; const unitTextMetrics = ctx.measureText(unitText); const unitTextHeight = unitTextMetrics.actualBoundingBoxAscent ? (unitTextMetrics.actualBoundingBoxAscent + unitTextMetrics.actualBoundingBoxDescent) : unitFontWorldSize * 1.2; const unitBgWidth = unitTextMetrics.width + textPadding * 2; const unitBgHeight = unitTextHeight + textPadding * 1.5; const unitBgY = this.y + drawRadius + (4 / cameraZoom); ctx.fillStyle = `rgba(0, 0, 0, ${textBgAlpha})`; ctx.fillRect(this.x - unitBgWidth / 2, unitBgY, unitBgWidth, unitBgHeight); ctx.fillStyle = 'white'; ctx.fillText(unitText, this.x, unitBgY + unitBgHeight / 2); } } drawFallback(drawRadius) { ctx.fillStyle = this.parentNode.getColor(); ctx.strokeStyle = 'rgba(200, 200, 255, 0.8)'; ctx.lineWidth = 2 / cameraZoom; ctx.beginPath(); ctx.arc(this.x, this.y, drawRadius * 0.8, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); } }
            class Node { constructor(x, y, owner, initialUnits) { this.x = x; this.y = y; this.owner = owner; this.unitCount = initialUnits; this.level = 1; this.generationTimer = 0; this._isSelected = false; this.isUnderAttack = false; this.attackTimer = 0; this.satellites = []; this.hasSpaceStation = false; this.stationObject = null; this.baseRadius = NODE_RADIUS_BASE * (1.0 - NODE_RADIUS_RANDOM_FACTOR / 2 + Math.random() * NODE_RADIUS_RANDOM_FACTOR); this.imageIndex = Math.floor(Math.random() * planetImages.length); } get isSelected() { return this._isSelected; } set isSelected(value) { const currentlySelected = selectedEntities.includes(this); if (value && !currentlySelected) { selectedEntities.push(this); this._isSelected = true; } else if (!value && currentlySelected) { const index = selectedEntities.indexOf(this); if (index > -1) selectedEntities.splice(index, 1); this._isSelected = false; } else { this._isSelected = value; } } get radius() { return this.baseRadius + (this.level * NODE_RADIUS_PER_LEVEL) + this.unitCount * NODE_RADIUS_PER_UNIT; } getColor() { if (this.owner === PLAYER) return PLAYER_COLOR; if (this.owner === NEUTRAL) return NEUTRAL_COLOR; const aiIndex = this.owner - 2; return AI_COLORS[aiIndex % AI_COLORS.length]; } getMaxCapacity() { return this.level * UNIT_CAPACITY_PER_LEVEL; } draw() { const color = this.getColor(); const logicalRadius = this.radius; const img = planetImages[this.imageIndex]; const useCircleAura = cameraZoom < AURA_CIRCLE_MIN_ZOOM; const useShadowAura = cameraZoom >= SHADOW_MIN_ZOOM; const standardScreenRadius = logicalRadius * cameraZoom; const actualScreenRadius = Math.max(MIN_NODE_SCREEN_RADIUS, standardScreenRadius); const drawRadiusWorld = actualScreenRadius / cameraZoom; const r = drawRadiusWorld; if (this.owner !== NEUTRAL && useCircleAura) { ctx.fillStyle = color; ctx.globalAlpha = 0.6; ctx.beginPath(); ctx.arc(this.x, this.y, r * 1.2, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1.0; } if (this.owner !== NEUTRAL && useShadowAura) { let auraColor = color; const rgbaMatch = color.match(/rgba?\((\d+), *(\d+), *(\d+)(?:, *([\d.]+))?\)/); if (rgbaMatch) { auraColor = `rgba(${rgbaMatch[1]}, ${rgbaMatch[2]}, ${rgbaMatch[3]}, ${AURA_ALPHA})`; } ctx.shadowBlur = r * AURA_BLUR_FACTOR; ctx.shadowColor = auraColor; } else { ctx.shadowBlur = 0; } if (img && img.complete && cameraZoom > 0.1) { try { ctx.drawImage(img, this.x - r, this.y - r, r * 2, r * 2); } catch (e) { ctx.fillStyle = NEUTRAL_COLOR; ctx.beginPath(); ctx.arc(this.x, this.y, r, 0, Math.PI * 2); ctx.fill(); } } else { ctx.fillStyle = this.getColor(); ctx.beginPath(); ctx.arc(this.x, this.y, r, 0, Math.PI * 2); ctx.fill(); } ctx.shadowBlur = 0; if (this.owner !== NEUTRAL) { ctx.strokeStyle = color; ctx.lineWidth = SELECTION_LINE_WIDTH / cameraZoom; ctx.beginPath(); ctx.arc(this.x, this.y, r + 6 / cameraZoom, 0, Math.PI * 2); ctx.stroke(); } if (this.isSelected) { ctx.strokeStyle = SELECTED_COLOR; ctx.lineWidth = SELECTION_LINE_WIDTH / cameraZoom; ctx.beginPath(); ctx.arc(this.x, this.y, r + 6 / cameraZoom, 0, Math.PI * 2); ctx.stroke(); } if (this.isUnderAttack) { const blinkOn = Math.floor(performance.now() / ATTACK_INDICATOR_BLINK_RATE) % 2 === 0; if (blinkOn) { ctx.strokeStyle = ATTACK_INDICATOR_COLOR; ctx.lineWidth = (SELECTION_LINE_WIDTH + 2) / cameraZoom; ctx.beginPath(); ctx.arc(this.x, this.y, r + 9 / cameraZoom, 0, Math.PI * 2); ctx.stroke(); } } ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; const textPadding = 4 / cameraZoom; const textBgAlpha = 0.65; const targetUnitScreenSize = Math.max(NODE_TEXT_MIN_SCREEN_SIZE, Math.min(NODE_TEXT_MAX_SCREEN_SIZE, (this.baseRadius * 0.5) * cameraZoom)); const targetLevelScreenSize = Math.max(NODE_TEXT_MIN_SCREEN_SIZE * 0.8, Math.min(NODE_TEXT_MAX_SCREEN_SIZE * 0.8, (this.baseRadius * 0.3) * cameraZoom)); const unitFontWorldSize = targetUnitScreenSize / cameraZoom; const levelFontWorldSize = targetLevelScreenSize / cameraZoom; ctx.font = `bold ${unitFontWorldSize}px 'Exo 2', sans-serif`; const unitText = `${Math.floor(this.unitCount)}`; const unitTextMetrics = ctx.measureText(unitText); const unitTextHeight = unitTextMetrics.actualBoundingBoxAscent ? (unitTextMetrics.actualBoundingBoxAscent + unitTextMetrics.actualBoundingBoxDescent) : unitFontWorldSize * 1.2; const unitBgWidth = unitTextMetrics.width + textPadding * 2; const unitBgHeight = unitTextHeight + textPadding * 1.5; const unitBgY = this.y - unitBgHeight / 2; ctx.fillStyle = `rgba(0, 0, 0, ${textBgAlpha})`; ctx.fillRect(this.x - unitBgWidth / 2, unitBgY, unitBgWidth, unitBgHeight); ctx.fillStyle = 'white'; ctx.fillText(unitText, this.x, this.y); if (this.owner !== NEUTRAL) { ctx.font = `bold ${levelFontWorldSize}px 'Exo 2', sans-serif`; const levelText = `${getText('messageLvl')} ${this.level}`; const levelTextMetrics = ctx.measureText(levelText); const levelTextHeight = levelTextMetrics.actualBoundingBoxAscent ? (levelTextMetrics.actualBoundingBoxAscent + levelTextMetrics.actualBoundingBoxDescent) : levelFontWorldSize * 1.2; const levelBgWidth = levelTextMetrics.width + textPadding * 2; const levelBgHeight = levelTextHeight + textPadding * 1.5; const levelBgY = unitBgY + unitBgHeight + (2 / cameraZoom); ctx.fillStyle = `rgba(0, 0, 0, ${textBgAlpha})`; ctx.fillRect(this.x - levelBgWidth / 2, levelBgY, levelBgWidth, levelBgHeight); ctx.fillStyle = 'white'; ctx.fillText(levelText, this.x, levelBgY + levelBgHeight / 2); } this.satellites.forEach(sat => sat.draw()); this.stationObject?.draw(); } update(deltaTime) { if (this.owner !== NEUTRAL && gameRunning && !gamePaused) { const maxCapacity = this.getMaxCapacity(); if (this.unitCount < maxCapacity) { this.generationTimer += deltaTime; const generationRate = Math.pow(1.6, this.level - 1); const effectiveInterval = GENERATION_INTERVAL / generationRate; if (this.generationTimer >= effectiveInterval) { const generations = Math.floor(this.generationTimer / effectiveInterval); const generatedAmount = Math.min(generations, maxCapacity - Math.floor(this.unitCount)); this.unitCount += generatedAmount; this.generationTimer %= effectiveInterval; } } else { this.generationTimer = 0; } } else if (!gamePaused && this.owner === NEUTRAL) { this.generationTimer = 0; } if (this.isUnderAttack && !gamePaused) { this.attackTimer -= deltaTime; if (this.attackTimer <= 0) { this.isUnderAttack = false; } } this.satellites.forEach(sat => sat.update(deltaTime)); this.stationObject?.update(deltaTime); } attemptUpgrade() { if (gamePaused) return false; if (this.level >= MAX_NODE_LEVEL) return false; const cost = calculateUpgradeCost(this); if (this.unitCount >= cost) { this.unitCount -= cost; this.level++; if (this.owner === PLAYER) updateMessage(); return true; } else { return false; } } resetOnCapture() { this.level = 1; this.generationTimer = 0; this.isUnderAttack = false; this.attackTimer = 0; this.satellites = []; this.hasSpaceStation = false; this.stationObject = null; } attemptBuildSatellite() { if (gamePaused) return false; if (this.satellites.length >= MAX_SATELLITES_PER_NODE) return false; const cost = calculateSatelliteCost(this); if (this.unitCount >= cost) { this.unitCount -= cost; const newSatellite = new Satellite(this, 0); this.satellites.push(newSatellite); const totalSatellites = this.satellites.length; const angleStep = (Math.PI * 2) / totalSatellites; this.satellites.forEach((sat, index) => { sat.angle = index * angleStep; sat.updatePosition(); }); if (this.owner === PLAYER) updateMessage(); return true; } else { return false; } } attemptBuildSpaceStation() { if (gamePaused) return false; if (this.level < SPACE_STATION_MIN_LEVEL || this.hasSpaceStation || this.unitCount < SPACE_STATION_COST) return false; const requiredImage = (this.owner === PLAYER) ? stationImagePlayer : stationImageAI; if (!requiredImage) { console.warn(`Cannot build station for owner ${this.owner}, image not loaded.`); return false; } this.unitCount -= SPACE_STATION_COST; this.hasSpaceStation = true; this.stationObject = new SpaceStation(this, this.owner); console.log(`Player ${this.owner} built a space station at node (${this.x.toFixed(0)}, ${this.y.toFixed(0)})`); if (this.owner === PLAYER) updateMessage(); return true; } }
            class Satellite { constructor(parentNode, initialAngle = 0) { this.parentNode = parentNode; this.angle = initialAngle; this.orbitRadiusOffset = SATELLITE_ORBIT_RADIUS_BASE; this.fireRateLevel = 1; this.fireCooldown = 0; this.targetUnit = null; this.x = 0; this.y = 0; this.updatePosition(); } get fireRate() { return SATELLITE_FIRE_RATE_BASE; } updatePosition() { const zoomFactor = Math.max(0.1, Math.pow(cameraZoom, 0.9)); const orbitRadius = this.parentNode.radius + this.orbitRadiusOffset / zoomFactor; this.x = this.parentNode.x + Math.cos(this.angle) * orbitRadius; this.y = this.parentNode.y + Math.sin(this.angle) * orbitRadius; } update(deltaTime) { if (gamePaused) return; this.angle += SATELLITE_ORBIT_SPEED * (deltaTime / 16.66); if (this.angle > Math.PI * 2) this.angle -= Math.PI * 2; this.updatePosition(); if (this.fireCooldown > 0) { this.fireCooldown -= deltaTime; } if (this.fireCooldown <= 0) { if (!this.targetUnit || !units.includes(this.targetUnit) || this.distanceTo(this.targetUnit) > SATELLITE_RANGE || this.targetUnit.toBeRemoved) { this.findTarget(); } if (this.targetUnit) { this.fire(); } } } distanceTo(unit) { const dx = unit.x - this.x; const dy = unit.y - this.y; return Math.sqrt(dx * dx + dy * dy); } findTarget() { this.targetUnit = null; let closestDistSq = SATELLITE_RANGE * SATELLITE_RANGE; let potentialTarget = null; if (!spatialGrid) return; const nearbyUnits = spatialGrid.getNearbyUnits(this); for (const unit of nearbyUnits) { if (unit && unit.owner !== this.parentNode.owner && unit.owner !== NEUTRAL && !unit.toBeRemoved) { const dx = unit.x - this.x; const dy = unit.y - this.y; const distSq = dx * dx + dy * dy; if (distSq < closestDistSq) { closestDistSq = distSq; potentialTarget = unit; } } } this.targetUnit = potentialTarget; } fire() { if (!this.targetUnit || this.targetUnit.toBeRemoved) { this.targetUnit = null; return; } if (soundEnabled && laserSound) { laserSound.currentTime = 0; laserSound.play().catch(e => console.warn("Laser sound play failed:", e)); } activeLasers.push({ fromX: this.x, fromY: this.y, toX: this.targetUnit.x, toY: this.targetUnit.y, endTime: performance.now() + SATELLITE_LASER_DURATION, ownerColor: this.parentNode.getColor() }); const targetX = this.targetUnit.x; const targetY = this.targetUnit.y; const targetColor = this.targetUnit.getColor(); this.targetUnit.toBeRemoved = true; spawnExplosion(targetX, targetY, targetColor, EXPLOSION_PARTICLE_COUNT / 2, 1.3); this.targetUnit = null; this.fireCooldown = this.fireRate; } draw() { ctx.fillStyle = this.parentNode.getColor(); ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)'; ctx.lineWidth = 1.5 / cameraZoom; const useShadow = cameraZoom >= SHADOW_MIN_ZOOM; if(useShadow){ ctx.shadowBlur = 10; ctx.shadowColor = this.parentNode.getColor().replace('1)', '0.7)'); } ctx.beginPath(); ctx.arc(this.x, this.y, SATELLITE_RADIUS, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); if(useShadow) ctx.shadowBlur = 0; } }
            class Unit { constructor(startX, startY, targetNode, owner) { this.x = startX; this.y = startY; this.owner = owner; this.radius = UNIT_RADIUS; this.targetNode = targetNode; this.interceptTargetUnit = null; this.toBeRemoved = false; this.vx = 0; this.vy = 0; if (this.targetNode) { const targetX = this.targetNode.x; const targetY = this.targetNode.y; const dx = targetX - startX; const dy = targetY - startY; const dist = Math.sqrt(dx * dx + dy * dy); if (dist !== 0) { this.vx = (dx / dist) * UNIT_SPEED; this.vy = (dy / dist) * UNIT_SPEED; } } else { this.toBeRemoved = true; } } getColor() { if (this.owner === PLAYER) return PLAYER_COLOR; if (this.owner === NEUTRAL) return NEUTRAL_COLOR; const aiIndex = this.owner - 2; return AI_COLORS[aiIndex % AI_COLORS.length]; } getColorWithAlpha(alpha) { return this.getColor().replace(/, *1 *\)/, `, ${alpha})`); } draw() { const useShadow = cameraZoom >= SHADOW_MIN_ZOOM; if (useShadow) { ctx.shadowBlur = 8; ctx.shadowColor = this.getColor().replace('1)', '0.8)'); } ctx.fillStyle = this.getColor(); ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); if (useShadow) ctx.shadowBlur = 0; } update(deltaTime) { if (this.toBeRemoved || gamePaused) return; if (this.interceptTargetUnit) { if (!this.interceptTargetUnit || this.interceptTargetUnit.toBeRemoved || !units.includes(this.interceptTargetUnit)) { this.interceptTargetUnit = null; if (this.targetNode) { const dx = this.targetNode.x - this.x; const dy = this.targetNode.y - this.y; const dist = Math.sqrt(dx*dx + dy*dy); if (dist > 0) { this.vx = (dx / dist) * UNIT_SPEED; this.vy = (dy / dist) * UNIT_SPEED; } else { this.vx = 0; this.vy = 0; } } else { this.vx = 0; this.vy = 0; } } else { const dx = this.interceptTargetUnit.x - this.x; const dy = this.interceptTargetUnit.y - this.y; const dist = Math.sqrt(dx * dx + dy * dy); if (dist > 0) { this.vx = (dx / dist) * UNIT_SPEED; this.vy = (dy / dist) * UNIT_SPEED; } } } else if (!this.vx && !this.vy && this.targetNode) { const dx = this.targetNode.x - this.x; const dy = this.targetNode.y - this.y; const dist = Math.sqrt(dx*dx + dy*dy); if (dist > 0) { this.vx = (dx / dist) * UNIT_SPEED; this.vy = (dy / dist) * UNIT_SPEED; } } this.x += this.vx * deltaTime; this.y += this.vy * deltaTime; } onArrival() { if (!gameRunning || gamePaused || this.toBeRemoved || !this.targetNode) return; const targetNode = this.targetNode; let stationDestroyedThisHit = false; if (targetNode.owner === this.owner) { targetNode.unitCount++; this.toBeRemoved = true; } else { if (targetNode.owner !== NEUTRAL) { targetNode.isUnderAttack = true; targetNode.attackTimer = ATTACK_INDICATOR_DURATION; } if (targetNode.hasSpaceStation && targetNode.stationObject && targetNode.stationObject.unitCount > 0) { targetNode.stationObject.unitCount--; if (targetNode.stationObject.unitCount <= 0) { stationDestroyedThisHit = true; const stationColor = targetNode.stationObject.getColor(); const stationX = targetNode.stationObject.x; const stationY = targetNode.stationObject.y; console.log(`Station destroyed at (${targetNode.x.toFixed(0)}, ${targetNode.y.toFixed(0)}) by owner ${this.owner}`); spawnExplosion(stationX, stationY, stationColor, EXPLOSION_PARTICLE_COUNT, 1.8); targetNode.hasSpaceStation = false; targetNode.stationObject = null; if (targetNode.owner === PLAYER) updateMessage(); } this.toBeRemoved = true; } else { targetNode.unitCount--; this.toBeRemoved = true; } if (targetNode.unitCount < 0 && !targetNode.hasSpaceStation) { const oldOwner = targetNode.owner; targetNode.owner = this.owner; targetNode.unitCount = 1; targetNode.resetOnCapture(); const indexInSelection = selectedEntities.findIndex(e => e === targetNode); if (indexInSelection > -1) { selectedEntities.splice(indexInSelection, 1); updateMessage(); } checkWinCondition(); } } } }
            class SpatialGrid { constructor(worldWidth, worldHeight, cellSize) { this.cellSize = cellSize; this.cols = Math.ceil(worldWidth / cellSize); this.rows = Math.ceil(worldHeight / cellSize); this.grid = []; for (let i = 0; i < this.cols; i++) { this.grid[i] = []; for (let j = 0; j < this.rows; j++) { this.grid[i][j] = new Set(); } } } clear() { for (let i = 0; i < this.cols; i++) { for (let j = 0; j < this.rows; j++) { this.grid[i][j].clear(); } } } getCellCoords(x, y) { const col = Math.max(0, Math.min(this.cols - 1, Math.floor(x / this.cellSize))); const row = Math.max(0, Math.min(this.rows - 1, Math.floor(y / this.cellSize))); return { col, row }; } add(unit) { const { col, row } = this.getCellCoords(unit.x, unit.y); if(this.grid[col]?.[row]) { this.grid[col][row].add(unit); } } getNearbyUnits(entity) { const nearby = new Set(); const { col: centerCol, row: centerRow } = this.getCellCoords(entity.x, entity.y); for (let i = Math.max(0, centerCol - 1); i <= Math.min(this.cols - 1, centerCol + 1); i++) { for (let j = Math.max(0, centerRow - 1); j <= Math.min(this.rows - 1, centerRow + 1); j++) { if(this.grid[i]?.[j]) { this.grid[i][j].forEach(otherUnit => { if (entity !== otherUnit) { nearby.add(otherUnit); } }); } } } return nearby; } }

            // --- Funciones de Juego Principales ---
            function spawnExplosion(x, y, color, count, speedMultiplier = 1.0) { for (let i = 0; i < count; i++) { const p = new Particle(x, y, color, 'explosion'); p.vx *= speedMultiplier; p.vy *= speedMultiplier; particles.push(p); } }
            function startGameLogic() { if (!stationImagePlayer || !stationImageAI) { console.error("Station images not loaded! Cannot start game."); alert("Error: Failed to load critical game assets (stations). Please refresh."); initializeApp(); return; } showBackgroundSetting = backgroundCheckbox.checked; if (showBackgroundSetting && backgroundImages.length > 0) { currentBackgroundImage = backgroundImages[Math.floor(Math.random() * backgroundImages.length)]; console.log("Selected background:", currentBackgroundImage.src); } else { currentBackgroundImage = null; if (showBackgroundSetting) console.warn("No background images loaded despite setting being enabled."); } switch (aiDifficultySetting) { case 'basic': AI_ACTION_INTERVAL = 1300; AI_UPGRADE_CHANCE = 0.10; break; case 'expert': AI_ACTION_INTERVAL = 650; AI_UPGRADE_CHANCE = 0.45; break; case 'normal': default: AI_ACTION_INTERVAL = 950; AI_UPGRADE_CHANCE = 0.25; break; } console.log(`--- Start Game: ${NUM_NEUTRAL_NODES_SETTING} Nodes, ${NUM_ENEMIES_SETTING} Enemies (${aiDifficultySetting} AI), Show BG: ${showBackgroundSetting} ---`); console.log(`AI Params: Interval=${AI_ACTION_INTERVAL}, UpgradeChance=${AI_UPGRADE_CHANCE}`); resizeCanvas(); spatialGrid = new SpatialGrid(WORLD_WIDTH, WORLD_HEIGHT, GRID_CELL_SIZE); nodes = []; units = []; selectedEntities = []; particles = []; activeLasers = []; activeNodeButtons = []; gameRunning = true; gamePaused = false; interaction = { pointers: new Map(), lastTapTime: 0, lastTappedNodeForDoubleTap: null, isInteractingNode: false, isPanning: false, isPinching: false, isBoxSelecting: false, pinchInitialDistance: 0, currentPointerScreenPos: { x: null, y: null }, boxStartScreenX: 0, boxStartScreenY: 0 }; ambientPointerScreenPos = { x: null, y: null }; gameOverMessageDiv.style.display = 'none'; currentSendPercentage = 0.50; setActivePercentageButton(); gameSpeedMultiplier = 1.0; setActiveSpeedButton(); updatePauseButton(); stars = []; for (let i = 0; i < NUM_STARS; i++) { stars.push({ x: Math.random() * WORLD_WIDTH, y: Math.random() * WORLD_HEIGHT, depth: 0.05 + Math.random() * 0.75, size: 0.7 + Math.random() * 1.2, alpha: 0.5 + Math.random() * 0.4 }); } stars.sort((a, b) => a.depth - b.depth); const maxInitialUnits = 35; const maxPossibleBaseRadius = NODE_RADIUS_BASE * (1.0 + NODE_RADIUS_RANDOM_FACTOR / 2); const maxInitialRadius = maxPossibleBaseRadius + (1 * NODE_RADIUS_PER_LEVEL) + maxInitialUnits * NODE_RADIUS_PER_UNIT + 10; const worldMargin = maxInitialRadius * 1.5; const startingPlayers = 1 + NUM_ENEMIES_SETTING; const playerPositions = []; playerPositions.push({ x: worldMargin + Math.random() * (WORLD_WIDTH - 2 * worldMargin), y: worldMargin + Math.random() * (WORLD_HEIGHT - 2 * worldMargin), owner: PLAYER }); for (let i = 0; i < NUM_ENEMIES_SETTING; i++) { let placed = false; let attempts = 0; const maxPlacementAttempts = 600; const minDistSq = Math.pow(Math.min(WORLD_WIDTH, WORLD_HEIGHT) / (startingPlayers * 1.2), 2); while (!placed && attempts < maxPlacementAttempts) { attempts++; const potentialX = worldMargin + Math.random() * (WORLD_WIDTH - 2 * worldMargin); const potentialY = worldMargin + Math.random() * (WORLD_HEIGHT - 2 * worldMargin); let tooClose = false; for (const p of playerPositions) { const dx = potentialX - p.x; const dy = potentialY - p.y; if (dx * dx + dy * dy < minDistSq) { tooClose = true; break; } } if (!tooClose) { playerPositions.push({ x: potentialX, y: potentialY, owner: 2 + i }); placed = true; } } if (!placed) console.warn(`Could not place AI ${i+1} far apart after ${maxPlacementAttempts} attempts.`); } let playerNodeRef = null; playerPositions.forEach(p => { const newNode = new Node(p.x, p.y, p.owner, maxInitialUnits); nodes.push(newNode); if (p.owner === PLAYER) playerNodeRef = newNode; }); let neutralCount = 0; let attempts = 0; const maxAttempts = 250; while (neutralCount < NUM_NEUTRAL_NODES_SETTING && attempts < maxAttempts * NUM_NEUTRAL_NODES_SETTING) { attempts++; const nx = worldMargin + Math.random() * (WORLD_WIDTH - 2 * worldMargin); const ny = worldMargin + Math.random() * (WORLD_HEIGHT - 2 * worldMargin); const newNode = new Node(nx, ny, NEUTRAL, 15 + Math.floor(Math.random() * 21)); let tooClose = false; for (const existingNode of nodes) { const dx = newNode.x - existingNode.x; const dy = newNode.y - existingNode.y; const effectiveMinDist = MIN_NODE_DISTANCE + newNode.radius + existingNode.radius; if (dx * dx + dy * dy < effectiveMinDist * effectiveMinDist) { tooClose = true; break; } } if (!tooClose) { nodes.push(newNode); neutralCount++; } } if(neutralCount < NUM_NEUTRAL_NODES_SETTING) console.warn(`Placed only ${neutralCount}/${NUM_NEUTRAL_NODES_SETTING} neutral nodes.`); const zoomFitW = canvas.width / WORLD_WIDTH; const zoomFitH = canvas.height / WORLD_HEIGHT; minZoomToFitWorld = Math.max(zoomFitW, zoomFitH); cameraZoom = Math.max(minZoomToFitWorld, INITIAL_CAMERA_ZOOM); console.log(`Initial Zoom set to: ${cameraZoom.toFixed(3)} (Fixed target: ${INITIAL_CAMERA_ZOOM}, MinFit: ${minZoomToFitWorld.toFixed(3)})`); if (playerNodeRef) { const initialScreenW = canvas.width; const initialScreenH = canvas.height; cameraX = playerNodeRef.x - (initialScreenW / 2) / cameraZoom; cameraY = playerNodeRef.y - (initialScreenH / 2) / cameraZoom; } else { cameraX = (WORLD_WIDTH - canvas.width / cameraZoom) / 2; cameraY = (WORLD_HEIGHT - canvas.height / cameraZoom) / 2; } clampCamera(); lastUpdateTime = performance.now(); lastAiActionTime = lastUpdateTime; if (animationFrameId) { cancelAnimationFrame(animationFrameId); } updateMessage(); controlSound(); gameLoop(); }
            function resizeCanvas() { const controlsHeight = document.getElementById('controls').offsetHeight; const availableHeight = window.innerHeight - controlsHeight - 5; const availableWidth = window.innerWidth; canvas.width = availableWidth; canvas.height = availableHeight; canvas.style.marginTop = `${controlsHeight}px`; const zoomFitW = canvas.width / WORLD_WIDTH; const zoomFitH = canvas.height / WORLD_HEIGHT; minZoomToFitWorld = Math.max(zoomFitW, zoomFitH); console.log(`Canvas resized: ${canvas.width}x${canvas.height}. New Min Zoom: ${minZoomToFitWorld.toFixed(3)}`); cameraZoom = Math.max(minZoomToFitWorld, cameraZoom); clampCamera(); if (spatialGrid) { spatialGrid = new SpatialGrid(WORLD_WIDTH, WORLD_HEIGHT, GRID_CELL_SIZE); } }
            function transferUnitsToStation(sourceNode, targetStation, percentage) { if (gamePaused) return; if (!sourceNode || !targetStation || sourceNode !== targetStation.parentNode || sourceNode.unitCount < 1) return; let unitsToTransfer = 0; if (percentage === 1.0 && sourceNode.unitCount > 1) { unitsToTransfer = sourceNode.unitCount - 1; } else { unitsToTransfer = Math.floor(sourceNode.unitCount * percentage); if (unitsToTransfer === 0 && sourceNode.unitCount >= 1 && percentage > 0) unitsToTransfer = 1; } unitsToTransfer = Math.min(unitsToTransfer, Math.floor(sourceNode.unitCount)); if (unitsToTransfer <= 0) return; console.log(`Transferring ${unitsToTransfer} units from Node to its Station`); sourceNode.unitCount -= unitsToTransfer; targetStation.unitCount += unitsToTransfer; if(sourceNode.owner === PLAYER) updateMessage(); }
            function sendUnits(sourceNode, targetNode) { if (gamePaused) return; if (!sourceNode || !targetNode || sourceNode === targetNode || sourceNode.unitCount < 1) return; let unitsToSend = 0; if (currentSendPercentage === 1.0 && sourceNode.unitCount > 1) { unitsToSend = sourceNode.unitCount - 1; } else { unitsToSend = Math.floor(sourceNode.unitCount * currentSendPercentage); if (unitsToSend === 0 && sourceNode.unitCount >= 1 && currentSendPercentage > 0) unitsToSend = 1; } unitsToSend = Math.min(unitsToSend, Math.floor(sourceNode.unitCount)); if (unitsToSend <= 0) return; sourceNode.unitCount -= unitsToSend; for (let i = 0; i < unitsToSend; i++) { const angle = Math.random() * Math.PI * 2; const radiusOffset = Math.random() * sourceNode.radius * 0.5; const startX = sourceNode.x + Math.cos(angle) * radiusOffset; const startY = sourceNode.y + Math.sin(angle) * radiusOffset; units.push(new Unit(startX, startY, targetNode, sourceNode.owner)); } if(sourceNode.owner === PLAYER) updateMessage(); }
            function sendUnitsFromStation(sourceStation, targetNode) { if (gamePaused) return; if (!sourceStation || !targetNode || sourceStation.parentNode === targetNode || sourceStation.unitCount < 1) return; let unitsToSend = 0; if (currentSendPercentage === 1.0 && sourceStation.unitCount > 1) { unitsToSend = sourceStation.unitCount - 1; } else { unitsToSend = Math.floor(sourceStation.unitCount * currentSendPercentage); if (unitsToSend === 0 && sourceStation.unitCount >= 1 && currentSendPercentage > 0) unitsToSend = 1; } unitsToSend = Math.min(unitsToSend, Math.floor(sourceStation.unitCount)); if (unitsToSend <= 0) return; sourceStation.unitCount -= unitsToSend; for (let i = 0; i < unitsToSend; i++) { const angle = Math.random() * Math.PI * 2; const radiusOffset = Math.random() * sourceStation.radius * 0.6; const startX = sourceStation.x + Math.cos(angle) * radiusOffset; const startY = sourceStation.y + Math.sin(angle) * radiusOffset; units.push(new Unit(startX, startY, targetNode, sourceStation.owner)); } if(sourceStation.owner === PLAYER) updateMessage(); }
            function clearSelection(keepInteractionState = false) { [...selectedEntities].forEach(entity => entity.isSelected = false); if (selectedEntities.length > 0) { console.warn("clearSelection: selectedEntities not empty after setting isSelected=false on all items.", selectedEntities); selectedEntities = []; } if (!keepInteractionState) { interaction.isInteractingNode = false; canvas.classList.remove('interacting-node'); canvas.style.cursor = 'default'; } activeNodeButtons = []; updateMessage(); }
            function setActivePercentageButton() { percentageButtonsContainer.querySelectorAll('button').forEach(button => { if (parseFloat(button.getAttribute('data-percent')) === currentSendPercentage) button.classList.add('active'); else button.classList.remove('active'); }); updateMessage(); }
            function setActiveSpeedButton() { speedControlsContainer.querySelectorAll('button').forEach(button => { if (parseFloat(button.getAttribute('data-speed')) === gameSpeedMultiplier) button.classList.add('active'); else button.classList.remove('active'); }); }
            function runAIForPlayer(aiOwnerId, currentTime) { const aiNodes = nodes.filter(n => n.owner === aiOwnerId); const enemyNodes = nodes.filter(n => n.owner === PLAYER || (n.owner >= 2 && n.owner !== aiOwnerId)); const neutralNodes = nodes.filter(n => n.owner === NEUTRAL); if (aiNodes.length === 0) return; const nonAiOwnedNodes = enemyNodes.concat(neutralNodes); let potentialActions = []; const isExpert = aiDifficultySetting === 'expert'; const isBasic = aiDifficultySetting === 'basic'; const upgradeCostMultiplier = isBasic ? 2.2 : (isExpert ? 1.4 : 1.7); const upgradeNearCapacityThreshold = isBasic ? 0.85 : (isExpert ? 0.65 : 0.75); const satelliteCostMultiplier = isBasic ? 2.0 : (isExpert ? 1.3 : 1.6); const satelliteNearCapacityThreshold = isBasic ? 0.7 : (isExpert ? 0.45 : 0.55); const stationCostMultiplier = isBasic ? 2.5 : (isExpert ? 1.1 : 1.4); const stationBuildChance = isBasic ? 0.05 : (isExpert ? 0.4 : 0.15); const minAttackUnits = isBasic ? 25 : (isExpert ? 12 : 18); const attackAdvantageRequired = isBasic ? 1.5 : (isExpert ? 1.05 : 1.25); const neutralAttackScoreBonus = isBasic ? -20 : (isExpert ? 50 : 10); const distancePenaltyFactor = isBasic ? 0.22 : (isExpert ? 0.12 : 0.17); const reinforceThreshold = isBasic ? 0.8 : (isExpert ? 0.55 : 0.7); const reinforceRangeFactor = isBasic ? 4.5 : (isExpert ? 3.0 : 3.8); const aiUpgradeChance = isBasic ? 0.10 : (isExpert ? 0.50 : 0.25); aiNodes.forEach(node => { if (!node) return; if (node.level < MAX_NODE_LEVEL) { const cost = calculateUpgradeCost(node); if (cost !== Infinity && node.unitCount >= cost && (node.unitCount >= cost * upgradeCostMultiplier || node.unitCount > node.getMaxCapacity() * upgradeNearCapacityThreshold)) { let score = (isExpert ? 15 : 10) + node.level * 6 - (cost / node.getMaxCapacity()) * 8; potentialActions.push({ type: 'upgrade', node: node, score: score }); } } const satCost = calculateSatelliteCost(node); if (node.satellites.length < MAX_SATELLITES_PER_NODE && node.unitCount >= satCost && (node.unitCount >= satCost * satelliteCostMultiplier || node.unitCount > node.getMaxCapacity() * satelliteNearCapacityThreshold)) { let score = (isExpert? 20:15) + (MAX_SATELLITES_PER_NODE - node.satellites.length) * 7 - (satCost / 40); potentialActions.push({ type: 'build_satellite', node: node, score: score }); } if (!node.hasSpaceStation && node.level >= SPACE_STATION_MIN_LEVEL && node.unitCount >= SPACE_STATION_COST && node.unitCount >= SPACE_STATION_COST * stationCostMultiplier) { let score = (isExpert ? 180 : 80) + (node.unitCount - SPACE_STATION_COST) * 0.03; potentialActions.push({ type: 'build_station', node: node, score: score }); } }); aiNodes.forEach(sourceNode => { if (!sourceNode || sourceNode.unitCount < minAttackUnits) return; const availableUnits = sourceNode.unitCount; if (availableUnits < minAttackUnits) return; nonAiOwnedNodes.forEach(targetNode => { if (!targetNode) return; const unitsToSendIA = Math.floor(availableUnits * (isExpert ? 0.6 : 0.5)); if (unitsToSendIA <= 0) return; const dist = Math.hypot(sourceNode.x - targetNode.x, sourceNode.y - targetNode.y); const distPenalty = dist * distancePenaltyFactor; const targetStrength = targetNode.unitCount + (targetNode.stationObject ? targetNode.stationObject.unitCount + SPACE_STATION_DEFENSE_BONUS : 0) + (targetNode.owner === PLAYER ? targetNode.level * (isExpert ? 18 : 12) : (targetNode.owner >= 2 ? targetNode.level * 8 : 0)); const advantageRatio = unitsToSendIA / Math.max(1, targetStrength); let score = 0; if (targetNode.owner === NEUTRAL) { score = 150 + neutralAttackScoreBonus - targetStrength * 1.5 - distPenalty; } else { if (advantageRatio > attackAdvantageRequired) { score = 120 + (unitsToSendIA - targetStrength) * (isExpert ? 1.9 : 1.5) - distPenalty; } else if (advantageRatio > 0.8) { score = (isExpert ? 45 : 30) - distPenalty * 1.2; } if (targetNode.owner === PLAYER) score *= (isExpert ? 1.4 : 1.1); if (targetNode.hasSpaceStation) score *= 1.5; } if (score > (isBasic ? 20 : (isExpert ? 5 : 10))) { potentialActions.push({ type: 'attack', source: sourceNode, target: targetNode, score: score }); } }); if (availableUnits > sourceNode.getMaxCapacity() * reinforceThreshold) { aiNodes.forEach(targetNode => { if (!targetNode || sourceNode === targetNode) return; const needsHelp = targetNode.isUnderAttack || targetNode.unitCount < targetNode.getMaxCapacity() * (isExpert ? 0.3 : 0.45); if (needsHelp) { const dist = Math.hypot(sourceNode.x - targetNode.x, sourceNode.y - targetNode.y); const reinforceRange = WORLD_WIDTH / reinforceRangeFactor; if (dist < reinforceRange) { let score = (isExpert? 35:25) + (targetNode.isUnderAttack ? 20 : 0) - dist * (isExpert ? 0.01 : 0.02); potentialActions.push({ type: 'reinforce', source: sourceNode, target: targetNode, score: score }); } } }); } }); if (potentialActions.length > 0) { potentialActions.sort((a, b) => b.score - a.score); let choiceRandomness = isBasic ? 5 : (isExpert ? 2 : 3); const choiceIndex = Math.floor(Math.random() * Math.min(potentialActions.length, choiceRandomness)); const chosenAction = potentialActions[choiceIndex]; try { if (chosenAction.type === 'upgrade') { if (Math.random() < aiUpgradeChance || choiceIndex === 0) chosenAction.node.attemptUpgrade(); } else if (chosenAction.type === 'build_satellite') { chosenAction.node.attemptBuildSatellite(); } else if (chosenAction.type === 'build_station') { if (Math.random() < stationBuildChance || choiceIndex === 0) chosenAction.node.attemptBuildSpaceStation(); } else if (chosenAction.type === 'attack' || chosenAction.type === 'reinforce') { if (chosenAction.source && chosenAction.target) { const sourceNode = chosenAction.source; const unitsToSendIA = Math.floor(sourceNode.unitCount * (isExpert ? 0.6 : 0.5)); if (unitsToSendIA > 0 && sourceNode.unitCount >= unitsToSendIA) { sourceNode.unitCount -= unitsToSendIA; for (let i = 0; i < unitsToSendIA; i++) { const angle = Math.random()*Math.PI*2; const rOff = Math.random()*sourceNode.radius*0.5; const startX = sourceNode.x + Math.cos(angle) * rOff; const startY = sourceNode.y + Math.sin(angle) * rOff; units.push(new Unit(startX, startY, chosenAction.target, aiOwnerId)); } } } } } catch (error) { console.error(`AI ${aiOwnerId}: Error executing action ${chosenAction.type}:`, error); } } }
            function updateAI(currentTime) { if (gamePaused) return; const effectiveAiInterval = AI_ACTION_INTERVAL / gameSpeedMultiplier; if (currentTime - lastAiActionTime >= effectiveAiInterval) { lastAiActionTime = currentTime; for (let i = 0; i < NUM_ENEMIES_SETTING; i++) { runAIForPlayer(2 + i, currentTime); } } }
            function checkWinCondition() { if (!gameRunning) return; const playerNodesExist = nodes.some(n => n.owner === PLAYER); const aiNodesExist = nodes.some(n => n.owner >= 2); let titleKey = ''; if (!aiNodesExist && playerNodesExist) { titleKey = 'victory'; } else if (!playerNodesExist && aiNodesExist) { titleKey = 'defeat'; } else if (!playerNodesExist && !aiNodesExist && nodes.some(n => n.owner === NEUTRAL)) { titleKey = 'tie'; } if (titleKey) { console.log(`--- Game Over: ${titleKey} ---`); gameOverTitle.textContent = getText(titleKey); gameOverMessageDiv.style.display = 'block'; gameRunning = false; gamePaused = false; clearSelection(); controlSound(); updatePauseButton(); } }
            function update(currentTime) { if (!gameRunning || !spatialGrid) { lastUpdateTime = currentTime; return; } const deltaTime = currentTime - (lastUpdateTime || currentTime); if (deltaTime <= 0) { lastUpdateTime = currentTime; return; } lastUpdateTime = currentTime; if (!gamePaused) { const effectiveDeltaTime = deltaTime * gameSpeedMultiplier; spatialGrid.clear(); for (const unit of units) { if (!unit.toBeRemoved) { unit.update(effectiveDeltaTime); spatialGrid.add(unit); } } nodes.forEach(node => node.update(effectiveDeltaTime)); for (let i = units.length - 1; i >= 0; i--) { const unit = units[i]; if (!unit || unit.toBeRemoved) continue; const nearbyUnitsForCollision = spatialGrid.getNearbyUnits(unit); for (const otherUnit of nearbyUnitsForCollision) { if (!otherUnit || otherUnit === unit || otherUnit.owner === unit.owner || otherUnit.owner === NEUTRAL || otherUnit.toBeRemoved || unit.toBeRemoved) continue; const dx = otherUnit.x - unit.x; const dy = otherUnit.y - unit.y; const distSq = dx * dx + dy * dy; if (distSq <= UNIT_COLLISION_DIST_SQ) { spawnExplosion((unit.x + otherUnit.x)/2, (unit.y + otherUnit.y)/2, unit.getColor(), EXPLOSION_PARTICLE_COUNT / 2, 1.0); spawnExplosion((unit.x + otherUnit.x)/2, (unit.y + otherUnit.y)/2, otherUnit.getColor(), EXPLOSION_PARTICLE_COUNT / 2, 1.0); otherUnit.toBeRemoved = true; unit.toBeRemoved = true; break; } } if (unit.toBeRemoved) continue; if (unit.targetNode && !unit.interceptTargetUnit) { const dx = unit.targetNode.x - unit.x; const dy = unit.targetNode.y - unit.y; const distSq = dx * dx + dy * dy; const arrivalRadiusSq = Math.pow(unit.targetNode.radius * 1.05, 2); if (distSq <= arrivalRadiusSq) { unit.onArrival(); } } if (unit.interceptTargetUnit && !unit.interceptTargetUnit.toBeRemoved) { const dx = unit.interceptTargetUnit.x - unit.x; const dy = unit.interceptTargetUnit.y - unit.y; const distSq = dx * dx + dy * dy; if (distSq <= UNIT_COLLISION_DIST_SQ * 0.8) { spawnExplosion((unit.x + unit.interceptTargetUnit.x)/2, (unit.y + unit.interceptTargetUnit.y)/2, unit.getColor(), EXPLOSION_PARTICLE_COUNT / 2, 1.0); spawnExplosion((unit.x + unit.interceptTargetUnit.x)/2, (unit.y + unit.interceptTargetUnit.y)/2, unit.interceptTargetUnit.getColor(), EXPLOSION_PARTICLE_COUNT / 2, 1.0); unit.interceptTargetUnit.toBeRemoved = true; unit.toBeRemoved = true; unit.interceptTargetUnit = null; } } if (!unit.targetNode && !unit.interceptTargetUnit && !unit.toBeRemoved) { unit.toBeRemoved = true; } } units = units.filter(unit => unit && !unit.toBeRemoved); updateAI(currentTime); } const particleDeltaTime = gamePaused ? deltaTime : deltaTime * gameSpeedMultiplier; for (let i = particles.length - 1; i >= 0; i--) { if (particles[i].update(particleDeltaTime)) { particles.splice(i, 1); } } activeLasers = activeLasers.filter(laser => laser.endTime > currentTime); }
            // *** CORRECTED: drawStars calculates screen coordinates ***
            function drawStars() {
                ctx.save(); // Save context before drawing stars (as it modifies globalAlpha)
                ctx.fillStyle = 'white';
                stars.forEach(star => {
                    // Calculate screen position directly, incorporating parallax
                    const screenX = (star.x - cameraX * star.depth) * cameraZoom;
                    const screenY = (star.y - cameraY * star.depth) * cameraZoom;

                    // Scale alpha based on zoom and depth
                    const alphaScale = Math.max(0.25, Math.min(1.0, cameraZoom * 1.2));
                    ctx.globalAlpha = star.alpha * alphaScale * (1 - star.depth * 0.5);

                    // Scale size based on zoom
                    const sizeScale = Math.max(0.6, Math.min(1.5, cameraZoom * 1.0));
                    const finalSize = star.size * sizeScale;

                    // Check if potentially visible before drawing
                    if (screenX >= -finalSize && screenX <= canvas.width + finalSize &&
                        screenY >= -finalSize && screenY <= canvas.height + finalSize) {
                        ctx.beginPath();
                        ctx.arc(screenX, screenY, finalSize, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                ctx.restore(); // Restore context (including globalAlpha)
            }
            function drawMinimap() { if (!MINIMAP_ENABLED) return; ctx.save(); const mapX = canvas.width - MINIMAP_WIDTH - MINIMAP_MARGIN; const mapY = MINIMAP_MARGIN; const scaleX = MINIMAP_WIDTH / WORLD_WIDTH; const scaleY = MINIMAP_HEIGHT / WORLD_HEIGHT; ctx.fillStyle = 'rgba(10, 10, 30, 0.75)'; ctx.fillRect(mapX - 2, mapY - 2, MINIMAP_WIDTH + 4, MINIMAP_HEIGHT + 4); ctx.strokeStyle = 'rgba(100, 120, 180, 0.7)'; ctx.lineWidth = 1.5; ctx.strokeRect(mapX - 2, mapY - 2, MINIMAP_WIDTH + 4, MINIMAP_HEIGHT + 4); nodes.forEach(node => { const nodeMapX = mapX + node.x * scaleX; const nodeMapY = mapY + node.y * scaleY; ctx.fillStyle = node.getColor(); ctx.beginPath(); ctx.arc(nodeMapX, nodeMapY, MINIMAP_NODE_SIZE, 0, Math.PI * 2); ctx.fill(); if (node.hasSpaceStation) { ctx.strokeStyle = node.getColor(); ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(nodeMapX, nodeMapY, MINIMAP_NODE_SIZE * 1.8, 0, Math.PI*2); ctx.stroke(); } }); const viewMapX = mapX + cameraX * scaleX; const viewMapY = mapY + cameraY * scaleY; const viewMapW = (canvas.width / cameraZoom) * scaleX; const viewMapH = (canvas.height / cameraZoom) * scaleY; ctx.strokeStyle = MINIMAP_CAMERA_COLOR; ctx.lineWidth = 2.0; ctx.strokeRect(viewMapX, viewMapY, viewMapW, viewMapH); ctx.restore(); }
            function drawInteractionIndicatorsAndButtons() { activeNodeButtons = []; let targetScreenX = null; let targetScreenY = null; let drawLinesAndMarker = false; if (interaction.isInteractingNode && interaction.pointers.size > 0 && !interaction.isPanning && interaction.currentPointerScreenPos.x !== null) { targetScreenX = interaction.currentPointerScreenPos.x; targetScreenY = interaction.currentPointerScreenPos.y; drawLinesAndMarker = selectedEntities.length > 0; } else if (interaction.isInteractingNode && selectedEntities.length > 0 && ambientPointerScreenPos.x !== null) { targetScreenX = ambientPointerScreenPos.x; targetScreenY = ambientPointerScreenPos.y; drawLinesAndMarker = true; } if (drawLinesAndMarker) { ctx.save(); ctx.strokeStyle = SELECTED_COLOR; ctx.lineWidth = SELECTION_LINE_WIDTH; ctx.setLineDash([6, 6]); selectedEntities.forEach(entity => { const sourcePos = worldToScreen(entity.x, entity.y); ctx.beginPath(); ctx.moveTo(sourcePos.x, sourcePos.y); ctx.lineTo(targetScreenX, targetScreenY); ctx.stroke(); }); ctx.setLineDash([]); ctx.fillStyle = SELECTED_COLOR; ctx.shadowBlur = 0; ctx.beginPath(); ctx.arc(targetScreenX, targetScreenY, POINTER_MARKER_RADIUS, 0, Math.PI * 2); ctx.fill(); ctx.restore(); } else if (interaction.isBoxSelecting && interaction.currentPointerScreenPos.x !== null) { ctx.save(); ctx.fillStyle = BOX_SELECT_COLOR; ctx.strokeStyle = SELECTED_COLOR; ctx.lineWidth = 1.5; ctx.setLineDash([4, 4]); const sx = interaction.boxStartScreenX; const sy = interaction.boxStartScreenY; const cx = interaction.currentPointerScreenPos.x; const cy = interaction.currentPointerScreenPos.y; ctx.fillRect(sx, sy, cx - sx, cy - sy); ctx.strokeRect(sx, sy, cx - sx, cy - sy); ctx.restore(); } if (selectedEntities.length === 1 && selectedEntities[0] instanceof Node && selectedEntities[0].owner === PLAYER) { const node = selectedEntities[0]; const nodeScreenPos = worldToScreen(node.x, node.y); const standardScreenRadius = node.radius * cameraZoom; const actualScreenRadius = Math.max(MIN_NODE_SCREEN_RADIUS, standardScreenRadius); const nodeScreenRadius = actualScreenRadius; const buttonSize = 46; const buttonRadius = buttonSize / 2; const buttonMargin = 14; const buttonExtraSpacing = 22; const costTextHeightEstimate = buttonSize * 0.3 * 1.5; const totalButtonHeight = buttonSize + costTextHeightEstimate; const baseButtonYOffset = nodeScreenRadius + buttonMargin + buttonExtraSpacing + buttonRadius; let initialButtonY = nodeScreenPos.y + baseButtonYOffset; const buttonTopMargin = 5; const buttonSideMargin = 5; const buttonsToDrawInfo = []; const upgradeCost = calculateUpgradeCost(node); const canUpgrade = upgradeCost !== Infinity && node.unitCount >= upgradeCost; if (upgradeCost !== Infinity) { buttonsToDrawInfo.push({ action: 'upgrade', icon: '⬆️', enabled: canUpgrade, color: canUpgrade ? BUTTON_ENABLED_COLOR : BUTTON_DISABLED_COLOR, costText: `(${upgradeCost})` }); } const satCost = calculateSatelliteCost(node); const canBuildSatellite = node.satellites.length < MAX_SATELLITES_PER_NODE && node.unitCount >= satCost; if (node.satellites.length < MAX_SATELLITES_PER_NODE) { buttonsToDrawInfo.push({ action: 'build_satellite', icon: '🛰️', enabled: canBuildSatellite, color: canBuildSatellite ? BUTTON_ENABLED_COLOR : BUTTON_DISABLED_COLOR, costText: `(${satCost})` }); } const canBuildStation = node.level >= SPACE_STATION_MIN_LEVEL && node.unitCount >= SPACE_STATION_COST && !node.hasSpaceStation; if (!node.hasSpaceStation && node.level >= SPACE_STATION_MIN_LEVEL) { buttonsToDrawInfo.push({ action: 'build_station', icon: '🌟', enabled: canBuildStation, color: canBuildStation ? BUTTON_ENABLED_COLOR : BUTTON_DISABLED_COLOR, costText: `(${SPACE_STATION_COST})` }); } if (buttonsToDrawInfo.length > 0) { let finalButtonY = initialButtonY; if (finalButtonY + buttonRadius + costTextHeightEstimate > canvas.height) { finalButtonY = nodeScreenPos.y - baseButtonYOffset - costTextHeightEstimate; if (finalButtonY - buttonRadius < buttonTopMargin) { finalButtonY = buttonTopMargin + buttonRadius; } } const totalWidth = buttonsToDrawInfo.length * buttonSize + (buttonsToDrawInfo.length - 1) * buttonMargin; let startX = nodeScreenPos.x - totalWidth / 2; if (startX + totalWidth > canvas.width - buttonSideMargin) { startX = canvas.width - buttonSideMargin - totalWidth; } if (startX < buttonSideMargin) { startX = buttonSideMargin; } ctx.save(); ctx.lineWidth = 2.0; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; let currentButtonX = startX + buttonRadius; buttonsToDrawInfo.forEach(buttonInfo => { ctx.fillStyle = buttonInfo.color; ctx.strokeStyle = buttonInfo.enabled ? 'rgba(230, 230, 230, 0.9)' : 'rgba(140, 140, 140, 0.7)'; ctx.beginPath(); ctx.arc(currentButtonX, finalButtonY, buttonRadius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); ctx.globalAlpha = buttonInfo.enabled ? 1.0 : 0.6; ctx.fillStyle = 'white'; ctx.font = `${buttonSize * 0.55}px sans-serif`; ctx.fillText(buttonInfo.icon, currentButtonX, finalButtonY + buttonSize * 0.02); if (buttonInfo.costText) { ctx.font = `bold ${buttonSize * 0.28}px 'Exo 2', sans-serif`; ctx.fillStyle = buttonInfo.enabled ? 'rgba(255, 255, 255, 0.9)' : 'rgba(180, 180, 180, 0.8)'; const costTextY = finalButtonY + buttonRadius + buttonSize * 0.18; ctx.fillText(buttonInfo.costText, currentButtonX, costTextY); } ctx.globalAlpha = 1.0; if (buttonInfo.enabled) { activeNodeButtons.push({ cx: currentButtonX, cy: finalButtonY, radius: buttonRadius, action: buttonInfo.action, node: node }); } currentButtonX += buttonSize + buttonMargin; }); ctx.restore(); } } }
            function drawLasers() { if (activeLasers.length === 0) return; ctx.save(); ctx.lineWidth = 2.5; ctx.globalAlpha = 0.85; activeLasers.forEach(laser => { ctx.strokeStyle = laser.ownerColor; const startScreen = worldToScreen(laser.fromX, laser.fromY); const endScreen = worldToScreen(laser.toX, laser.toY); ctx.shadowBlur = 8; ctx.shadowColor = laser.ownerColor.replace('1)', '0.6)'); ctx.beginPath(); ctx.moveTo(startScreen.x, startScreen.y); ctx.lineTo(endScreen.x, endScreen.y); ctx.stroke(); ctx.shadowBlur = 0; }); ctx.restore(); }
            // *** CORRECTED: draw function with proper layering for parallax stars ***
            function draw() {
                 ctx.fillStyle = '#03030A'; // Fallback color
                 ctx.fillRect(0, 0, canvas.width, canvas.height);

                 // 1. Draw Background (if enabled and loaded), transformed by camera
                 ctx.save();
                 ctx.scale(cameraZoom, cameraZoom);
                 ctx.translate(-cameraX, -cameraY);
                 if (showBackgroundSetting && currentBackgroundImage && currentBackgroundImage.complete) {
                     try { ctx.drawImage(currentBackgroundImage, 0, 0, WORLD_WIDTH, WORLD_HEIGHT); }
                     catch (e) { console.error("Error drawing background image:", e); }
                 }
                 ctx.restore(); // Restore from background transform

                 // 2. Draw Stars (calculates screen coords with parallax directly) - Drawn *after* background, *before* main transform
                 drawStars();

                 // 3. Draw Game Elements (within camera transform)
                 ctx.save();
                 ctx.scale(cameraZoom, cameraZoom);
                 ctx.translate(-cameraX, -cameraY);
                 particles.forEach(p => p.draw());
                 units.forEach(unit => unit.draw());
                 nodes.forEach(node => node.draw());
                 ctx.restore(); // End camera transform for game elements

                 // 4. Draw UI on top (lasers, interaction lines, minimap, buttons) - Outside transforms
                 drawLasers();
                 drawInteractionIndicatorsAndButtons();
                 drawMinimap();
             }
            function gameLoop(timestamp) { update(timestamp || 0); draw(); animationFrameId = requestAnimationFrame(gameLoop); }

            // --- Funciones de Coordenadas y Cámara ---
            function screenToWorld(screenX, screenY) { const worldX = (screenX / cameraZoom) + cameraX; const worldY = (screenY / cameraZoom) + cameraY; return { x: worldX, y: worldY }; }
            function worldToScreen(worldX, worldY) { const screenX = (worldX - cameraX) * cameraZoom; const screenY = (worldY - cameraY) * cameraZoom; return { x: screenX, y: screenY }; }
            function clampCamera() { const viewWidthWorld = canvas.width / cameraZoom; const viewHeightWorld = canvas.height / cameraZoom; cameraX = Math.max(0, Math.min(cameraX, WORLD_WIDTH - viewWidthWorld)); cameraY = Math.max(0, Math.min(cameraY, WORLD_HEIGHT - viewHeightWorld)); if (isNaN(cameraX)) cameraX = 0; if (isNaN(cameraY)) cameraY = 0; }
            function zoomAtPoint(screenX, screenY, zoomFactor) { const worldPos = screenToWorld(screenX, screenY); const currentMinZoom = Math.max(minZoomToFitWorld, ABSOLUTE_MIN_ZOOM); const newZoom = Math.max(currentMinZoom, Math.min(MAX_ZOOM, cameraZoom * zoomFactor)); if (newZoom === cameraZoom) return; cameraX = worldPos.x - (screenX / newZoom); cameraY = worldPos.y - (screenY / newZoom); cameraZoom = newZoom; clampCamera(); }

            // --- Funciones de Interacción ---
            function findNearestValidTarget(worldX, worldY, maxDistance, sourceEntities) { let closestTargetNode = null; let minDistSq = maxDistance * maxDistance; const sourceNodeObjects = new Set(); sourceEntities.forEach(entity => { if (entity instanceof Node) { sourceNodeObjects.add(entity); } else if (entity instanceof SpaceStation && entity.parentNode) { sourceNodeObjects.add(entity.parentNode); } }); nodes.forEach(node => { if (node.owner !== NEUTRAL && !sourceNodeObjects.has(node)) { const dx = node.x - worldX; const dy = node.y - worldY; const distSq = dx * dx + dy * dy; if (distSq < minDistSq) { minDistSq = distSq; closestTargetNode = node; } } }); return closestTargetNode; }
            function findClosestEntity(worldX, worldY) { let closestEntity = null; let minDistanceSqScreen = Infinity; const screenPos = worldToScreen(worldX, worldY); nodes.forEach(node => { const nodeScreenPos = worldToScreen(node.x, node.y); const dxScreen = screenPos.x - nodeScreenPos.x; const dyScreen = screenPos.y - nodeScreenPos.y; const distSqScreen = dxScreen * dxScreen + dyScreen * dyScreen; const standardScreenRadius = node.radius * cameraZoom; const actualScreenRadius = Math.max(MIN_NODE_SCREEN_RADIUS, standardScreenRadius); const nodeClickRadiusSqScreen = actualScreenRadius * actualScreenRadius; if (distSqScreen < nodeClickRadiusSqScreen) { if (distSqScreen < minDistanceSqScreen) { closestEntity = node; minDistanceSqScreen = distSqScreen; } } if (node.stationObject) { const stationScreenPos = worldToScreen(node.stationObject.x, node.stationObject.y); const sdxScreen = screenPos.x - stationScreenPos.x; const sdyScreen = screenPos.y - stationScreenPos.y; const sDistSqScreen = sdxScreen * sdxScreen + sdyScreen * sdyScreen; const standardStationScreenRadius = node.stationObject.radius * cameraZoom; const actualStationScreenRadius = Math.max(MIN_STATION_SCREEN_RADIUS, standardStationScreenRadius); const stationClickRadiusSqScreen = actualStationScreenRadius * actualStationScreenRadius; if (sDistSqScreen < stationClickRadiusSqScreen) { if (sDistSqScreen < minDistanceSqScreen) { closestEntity = node.stationObject; minDistanceSqScreen = sDistSqScreen; } } } }); if (!closestEntity) { const searchRadiusScreen = TOUCH_SEARCH_RADIUS_WORLD * cameraZoom; const searchRadiusSqScreen = searchRadiusScreen * searchRadiusScreen; minDistanceSqScreen = searchRadiusSqScreen; nodes.forEach(node => { const nodeScreenPos = worldToScreen(node.x, node.y); const dxScreen = screenPos.x - nodeScreenPos.x; const dyScreen = screenPos.y - nodeScreenPos.y; const distSqScreen = dxScreen * dxScreen + dyScreen * dyScreen; if (distSqScreen < minDistanceSqScreen) { closestEntity = node; minDistanceSqScreen = distSqScreen; } if (node.stationObject) { const stationScreenPos = worldToScreen(node.stationObject.x, node.stationObject.y); const sdxScreen = screenPos.x - stationScreenPos.x; const sdyScreen = screenPos.y - stationScreenPos.y; const sDistSqScreen = sdxScreen * sdxScreen + sdyScreen * sdyScreen; if (sDistSqScreen < minDistanceSqScreen) { closestEntity = node.stationObject; minDistanceSqScreen = sDistSqScreen; } } }); } return closestEntity; }
            function getPointerInfo(event) { const rect = canvas.getBoundingClientRect(); const pointers = []; const id = event.pointerId ?? 0; const screenX = event.clientX - rect.left; const screenY = event.clientY - rect.top; if (event.clientX === undefined || event.clientY === undefined) { console.warn("Pointer event missing clientX/clientY:", event); return pointers; } pointers.push({ id: id, screenX: screenX, screenY: screenY, ...screenToWorld(screenX, screenY), pointerType: event.pointerType || 'mouse', button: event.button }); return pointers; }
            function getDistance(p1, p2) { const dx = p1.screenX - p2.screenX; const dy = p1.screenY - p2.screenY; return Math.sqrt(dx * dx + dy * dy); }
            function getMidpoint(p1, p2) { return { screenX: (p1.screenX + p2.screenX) / 2, screenY: (p1.screenY + p2.screenY) / 2 }; }
            function handleAmbientPointerMove(event) { if (!gameRunning && startScreenDiv.style.display === 'flex') return; const rect = canvas.getBoundingClientRect(); ambientPointerScreenPos.x = event.clientX - rect.left; ambientPointerScreenPos.y = event.clientY - rect.top; }
            function handleAmbientPointerLeave(event) { ambientPointerScreenPos.x = null; ambientPointerScreenPos.y = null; }
            function handlePointerDown(event) { if (!gameRunning && interaction.pointers.size === 0 && startScreenDiv.style.display === 'flex') return; handleFirstInteraction(); event.preventDefault(); canvas.setPointerCapture?.(event.pointerId); const currentPointers = getPointerInfo(event); if (!currentPointers || currentPointers.length === 0) { console.warn("handlePointerDown: No pointer info generated."); return; } const time = performance.now(); const pointer = currentPointers[0]; const screenX = pointer.screenX; const screenY = pointer.screenY; let clickedButton = null; if (selectedEntities.length === 1 && selectedEntities[0] instanceof Node) { for (const button of activeNodeButtons) { const dx = screenX - button.cx; const dy = screenY - button.cy; if (dx * dx + dy * dy <= button.radius * button.radius) { clickedButton = button; break; } } } if (clickedButton) { interaction.pointers.set(pointer.id, { id: pointer.id, isButtonPress: true, downTime: time }); if (clickedButton.action === 'upgrade') clickedButton.node.attemptUpgrade(); else if (clickedButton.action === 'build_satellite') clickedButton.node.attemptBuildSatellite(); else if (clickedButton.action === 'build_station') clickedButton.node.attemptBuildSpaceStation(); return; } const targetEntity = findClosestEntity(pointer.x, pointer.y); if (interaction.isInteractingNode && targetEntity) { if (selectedEntities.length === 1 && selectedEntities[0] instanceof Node && targetEntity instanceof SpaceStation && selectedEntities[0] === targetEntity.parentNode) { transferUnitsToStation(selectedEntities[0], targetEntity, currentSendPercentage); } else { selectedEntities.forEach(sourceEntity => { const finalTargetNode = (targetEntity instanceof SpaceStation) ? targetEntity.parentNode : targetEntity; if (sourceEntity !== finalTargetNode && !(sourceEntity instanceof SpaceStation && sourceEntity.parentNode === finalTargetNode)) { if (sourceEntity instanceof Node) { sendUnits(sourceEntity, finalTargetNode); } else if (sourceEntity instanceof SpaceStation) { sendUnitsFromStation(sourceEntity, finalTargetNode); } } }); } clearSelection(); interaction.pointers.set(pointer.id, { id: pointer.id, downTime: time }); return; } else if (interaction.isInteractingNode && !targetEntity) { clearSelection(); interaction.pointers.set(pointer.id, { id: pointer.id, downTime: time }); return; } interaction.isPanning = false; interaction.isPinching = false; interaction.isBoxSelecting = false; interaction.isInteractingNode = false; canvas.classList.remove('grabbing', 'panning', 'box-selecting', 'interacting-node'); currentPointers.forEach(p => { if (!interaction.pointers.has(p.id)) { const downEntity = findClosestEntity(p.x, p.y); interaction.pointers.set(p.id, { id: p.id, screenX: p.screenX, screenY: p.screenY, initialScreenX: p.screenX, initialScreenY: p.screenY, x: p.x, y: p.y, downTime: time, downEntity: downEntity, pointerType: p.pointerType, button: p.button, isButtonPress: false }); interaction.currentPointerScreenPos = { x: p.screenX, y: p.screenY }; interaction.boxStartScreenX = p.screenX; interaction.boxStartScreenY = p.screenY; } }); const numActivePointers = Array.from(interaction.pointers.values()).filter(p => !p.isButtonPress).length; if (numActivePointers === 1) { const firstPointerData = interaction.pointers.get(pointer.id); interaction.lastTapTime = time; interaction.lastTappedNodeForDoubleTap = (firstPointerData?.downEntity instanceof Node) ? firstPointerData.downEntity : null; } else if (numActivePointers === 2) { const pointersArray = Array.from(interaction.pointers.values()).filter(p => !p.isButtonPress); interaction.pinchInitialDistance = getDistance(pointersArray[0], pointersArray[1]); interaction.isPinching = true; interaction.isPanning = true; clearSelection(); canvas.classList.add('panning', 'grabbing'); } }
            function handlePointerMove(event) { if ((!gameRunning && startScreenDiv.style.display === 'flex') || interaction.pointers.size === 0) return; event.preventDefault(); const currentPointers = getPointerInfo(event); if (!currentPointers) return; currentPointers.forEach(p => { if (interaction.pointers.has(p.id)) { const storedPointer = interaction.pointers.get(p.id); if(storedPointer.isButtonPress) return; storedPointer.screenX = p.screenX; storedPointer.screenY = p.screenY; storedPointer.x = p.x; storedPointer.y = p.y; if(p.id === Array.from(interaction.pointers.keys())[0]) { interaction.currentPointerScreenPos = { x: p.screenX, y: p.screenY }; } } }); const activePointers = Array.from(interaction.pointers.values()).filter(p => !p.isButtonPress); const numActivePointers = activePointers.length; if (numActivePointers === 1) { const pointer = activePointers[0]; const dxScreen = pointer.screenX - pointer.initialScreenX; const dyScreen = pointer.screenY - pointer.initialScreenY; const distSqScreen = dxScreen * dxScreen + dyScreen * dyScreen; const hasMovedSignificantly = distSqScreen >= DRAG_THRESHOLD_FOR_ACTION * DRAG_THRESHOLD_FOR_ACTION; if (!interaction.isPanning && !interaction.isBoxSelecting && !interaction.isInteractingNode && hasMovedSignificantly) { const downEntity = pointer.downEntity; if (pointer.button === 2) { interaction.isPanning = true; clearSelection(); } else if (downEntity && downEntity.owner === PLAYER) { interaction.isInteractingNode = true; if (!selectedEntities.includes(downEntity)) { clearSelection(true); downEntity.isSelected = true; updateMessage(); } } else { if (pointer.pointerType === 'touch') { interaction.isPanning = true; clearSelection(); } else { interaction.isBoxSelecting = true; clearSelection(); } } if(interaction.isPanning) { canvas.classList.add('panning', 'grabbing'); canvas.classList.remove('interacting-node', 'box-selecting'); } else if(interaction.isInteractingNode) { canvas.classList.add('interacting-node'); canvas.classList.remove('panning', 'grabbing', 'box-selecting'); } else if(interaction.isBoxSelecting) { canvas.classList.add('box-selecting'); canvas.classList.remove('panning', 'grabbing', 'interacting-node'); } } if (interaction.isPanning) { const deltaXScreen = pointer.screenX - pointer.initialScreenX; const deltaYScreen = pointer.screenY - pointer.initialScreenY; cameraX -= deltaXScreen / cameraZoom; cameraY -= deltaYScreen / cameraZoom; clampCamera(); pointer.initialScreenX = pointer.screenX; pointer.initialScreenY = pointer.screenY; if (!canvas.classList.contains('grabbing')) canvas.classList.add('grabbing'); } else if (interaction.isInteractingNode) { const entityUnderPointer = findClosestEntity(pointer.x, pointer.y); if (entityUnderPointer && entityUnderPointer.owner === PLAYER && !selectedEntities.includes(entityUnderPointer)) { entityUnderPointer.isSelected = true; updateMessage(); } canvas.classList.add('interacting-node'); } else if (interaction.isBoxSelecting) { canvas.classList.add('box-selecting'); } } else if (numActivePointers === 2) { interaction.isInteractingNode = false; interaction.isBoxSelecting = false; interaction.isPanning = true; const p1 = activePointers[0]; const p2 = activePointers[1]; const newDist = getDistance(p1, p2); const midPoint = getMidpoint(p1, p2); if (interaction.pinchInitialDistance > 0 && newDist > 0) { const zoomFactor = newDist / interaction.pinchInitialDistance; zoomAtPoint(midPoint.screenX, midPoint.screenY, zoomFactor); } const p1Start = interaction.pointers.get(p1.id); const p2Start = interaction.pointers.get(p2.id); if (!p1Start || !p2Start) return; const initialMidPoint = getMidpoint(p1Start, p2Start); const deltaXScreen = midPoint.screenX - initialMidPoint.screenX; const deltaYScreen = midPoint.screenY - initialMidPoint.screenY; cameraX -= deltaXScreen / cameraZoom; cameraY -= deltaYScreen / cameraZoom; clampCamera(); interaction.pinchInitialDistance = newDist; p1Start.initialScreenX = p1.screenX; p1Start.initialScreenY = p1.screenY; p2Start.initialScreenX = p2.screenX; p2Start.initialScreenY = p2.screenY; canvas.classList.add('panning', 'grabbing'); canvas.classList.remove('interacting-node', 'box-selecting'); } }
            function handlePointerUp(event) { if (!gameRunning && gameOverMessageDiv.style.display === 'block') { initializeApp(); return; } handleFirstInteraction(); event.preventDefault(); const pointerId = event.pointerId ?? 0; const pointerData = interaction.pointers.get(pointerId); if (pointerData) { if (pointerData.isButtonPress) { interaction.pointers.delete(pointerId); } else { const time = performance.now(); const duration = time - pointerData.downTime; const dx = pointerData.screenX - pointerData.initialScreenX; const dy = pointerData.screenY - pointerData.initialScreenY; const distSq = dx * dx + dy * dy; const hasMovedSignificantly = distSq >= TAP_MOVEMENT_THRESHOLD * TAP_MOVEMENT_THRESHOLD; const isTap = !interaction.isPanning && !interaction.isBoxSelecting && !interaction.isInteractingNode && duration < TAP_DURATION_THRESHOLD && !hasMovedSignificantly; const isDragEnd = interaction.isInteractingNode && !interaction.isPanning; const isBoxSelectEnd = interaction.isBoxSelecting; const entityAtPointerUp = findClosestEntity(pointerData.x, pointerData.y); if (isBoxSelectEnd) { const boxP1World = screenToWorld(interaction.boxStartScreenX, interaction.boxStartScreenY); const boxP2World = screenToWorld(pointerData.screenX, pointerData.screenY); const minX = Math.min(boxP1World.x, boxP2World.x); const maxX = Math.max(boxP1World.x, boxP2World.x); const minY = Math.min(boxP1World.y, boxP2World.y); const maxY = Math.max(boxP1World.y, boxP2World.y); clearSelection(true); nodes.forEach(node => { if (node.owner === PLAYER && node.x >= minX && node.x <= maxX && node.y >= minY && node.y <= maxY) { node.isSelected = true; } if (node.stationObject && node.stationObject.owner === PLAYER && node.stationObject.x >= minX && node.stationObject.x <= maxX && node.stationObject.y >= minY && node.stationObject.y <= maxY) { node.stationObject.isSelected = true; } }); console.log(`Box select finished, selected ${selectedEntities.length} entities.`); interaction.isInteractingNode = selectedEntities.length > 0; updateMessage(); } else if (isDragEnd) { if (entityAtPointerUp && selectedEntities.length > 0) { console.log("Drag ended on target:", entityAtPointerUp); if (selectedEntities.length === 1 && selectedEntities[0] instanceof Node && entityAtPointerUp instanceof SpaceStation && selectedEntities[0] === entityAtPointerUp.parentNode) { transferUnitsToStation(selectedEntities[0], entityAtPointerUp, currentSendPercentage); } else { selectedEntities.forEach(sourceEntity => { const finalTargetNode = (entityAtPointerUp instanceof SpaceStation) ? entityAtPointerUp.parentNode : entityAtPointerUp; if (sourceEntity !== finalTargetNode && !(sourceEntity instanceof SpaceStation && sourceEntity.parentNode === finalTargetNode)) { if (sourceEntity instanceof Node) { sendUnits(sourceEntity, finalTargetNode); } else if (sourceEntity instanceof SpaceStation) { sendUnitsFromStation(sourceEntity, finalTargetNode); } } }); } clearSelection(); } else { const nearestTargetNode = findNearestValidTarget(pointerData.x, pointerData.y, TOUCH_SEARCH_RADIUS_WORLD * SMART_DROP_SEARCH_RADIUS_FACTOR, selectedEntities); if (nearestTargetNode && selectedEntities.length > 0) { console.log(`Smart drop: Found nearest target node at (${nearestTargetNode.x.toFixed(0)}, ${nearestTargetNode.y.toFixed(0)})`); selectedEntities.forEach(sourceEntity => { if (sourceEntity instanceof Node) { sendUnits(sourceEntity, nearestTargetNode); } else if (sourceEntity instanceof SpaceStation) { sendUnitsFromStation(sourceEntity, nearestTargetNode); } }); clearSelection(); } else { console.log("Drag ended on empty space, no near target found."); interaction.isInteractingNode = selectedEntities.length > 0; } } } else if (isTap) { const downEntity = pointerData.downEntity; if (downEntity && entityAtPointerUp === downEntity) { if (downEntity.owner === PLAYER) { if (selectedEntities.includes(downEntity)) { clearSelection(); } else { clearSelection(true); downEntity.isSelected = true; } interaction.isInteractingNode = selectedEntities.length > 0; activeNodeButtons = []; updateMessage(); } else { clearSelection(); } } else { clearSelection(); } interaction.lastTapTime = time; interaction.lastTappedNodeForDoubleTap = (downEntity instanceof Node) ? downEntity : null; } interaction.pointers.delete(pointerId); } canvas.releasePointerCapture?.(pointerId); } const remainingPointersData = Array.from(interaction.pointers.values()).filter(p => !p.isButtonPress); const remainingActivePointers = remainingPointersData.length; if (remainingActivePointers === 0) { interaction.isPanning = false; interaction.isPinching = false; interaction.isBoxSelecting = false; interaction.pinchInitialDistance = 0; interaction.isInteractingNode = selectedEntities.length > 0; canvas.classList.remove('grabbing', 'panning', 'box-selecting'); if (!interaction.isInteractingNode) { interaction.currentPointerScreenPos = { x: null, y: null }; canvas.classList.remove('interacting-node'); canvas.style.cursor = 'default'; activeNodeButtons = []; } else { canvas.classList.add('interacting-node'); canvas.style.cursor = 'crosshair'; } } else if (remainingActivePointers === 1) { interaction.isPinching = false; interaction.pinchInitialDistance = 0; interaction.isBoxSelecting = false; const remainingPointerData = remainingPointersData[0]; if (remainingPointerData) { remainingPointerData.initialScreenX = remainingPointerData.screenX; remainingPointerData.initialScreenY = remainingPointerData.screenY; const entityUnderRemaining = findClosestEntity(remainingPointerData.x, remainingPointerData.y); if ((remainingPointerData.pointerType === 'touch' && (!entityUnderRemaining || entityUnderRemaining.owner !== PLAYER)) || remainingPointerData.button === 2) { interaction.isPanning = true; interaction.isInteractingNode = false; clearSelection(); canvas.classList.add('panning', 'grabbing'); canvas.classList.remove('interacting-node', 'box-selecting'); } else { interaction.isPanning = false; interaction.isInteractingNode = selectedEntities.length > 0; canvas.classList.remove('panning', 'grabbing', 'box-selecting'); if(interaction.isInteractingNode) canvas.classList.add('interacting-node'); else canvas.style.cursor = 'default'; } } else { interaction.isPanning = false; interaction.isInteractingNode = selectedEntities.length > 0; canvas.classList.remove('panning', 'grabbing', 'box-selecting'); if(interaction.isInteractingNode) canvas.classList.add('interacting-node'); else canvas.style.cursor = 'default'; } } }
            function handlePointerOut(e) { const pointerData = interaction.pointers.get(e.pointerId ?? 0); if (pointerData && pointerData.button !== 2 && !pointerData.isButtonPress) { handlePointerUp(e); } }
            function preventContextMenu(e) { e.preventDefault(); }
            function handleWheel(e) { if (!gameRunning && startScreenDiv.style.display === 'flex') return; handleFirstInteraction(); e.preventDefault(); const zoomFactor = e.deltaY < 0 ? 1.15 : 1 / 1.15; const rect = canvas.getBoundingClientRect(); const screenX = e.clientX - rect.left; const screenY = e.clientY - rect.top; zoomAtPoint(screenX, screenY, zoomFactor); }
            function handleResize() { console.log("Window resized."); if (canvas) { resizeCanvas(); if(gameRunning) { updateMessage(); } } else { console.warn("Canvas not ready during resize event."); } }
            function handleGameOverClick() { if (gameOverMessageDiv.style.display === 'block') { console.log("Game over message clicked - Restarting."); initializeApp(); } }
            function toggleFullScreen() { if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement && !document.msFullscreenElement) { const el = document.documentElement; const requestMethod = el.requestFullscreen || el.mozRequestFullScreen || el.webkitRequestFullscreen || el.msRequestFullscreen; if (requestMethod) { requestMethod.call(el).then(() => { console.log("Entered fullscreen"); setTimeout(handleResize, 50); }).catch(err => { console.error(`Error attempting full-screen: ${err.message} (${err.name})`); }); } else { console.warn("Fullscreen API not supported."); } } else { const exitMethod = document.exitFullscreen || document.mozCancelFullScreen || document.webkitExitFullscreen || document.msExitFullscreen; if (exitMethod) { exitMethod.call(document).then(() => { console.log("Exited fullscreen"); setTimeout(handleResize, 50); }).catch(err => { console.error(`Error attempting exit full-screen: ${err.message} (${err.name})`); }); } else { console.warn("Fullscreen API not supported (cannot exit)."); } } }
            function togglePause() { if (!gameRunning) return; gamePaused = !gamePaused; console.log("Game Paused:", gamePaused); updatePauseButton(); if (gamePaused && currentAmbientTrack && !currentAmbientTrack.paused) { currentAmbientTrack.pause(); } else if (!gamePaused && currentAmbientTrack && currentAmbientTrack.paused && soundEnabled && firstInteractionDone) { currentAmbientTrack.play().catch(e => console.warn("Could not resume audio on unpause:", e)); } }
            function updatePauseButton() { if (gamePaused) { pauseButton.textContent = getText('resumeButton'); pauseButton.classList.add('paused'); } else { pauseButton.textContent = getText('pauseButton'); pauseButton.classList.remove('paused'); } }

            // --- Inicialización y Listeners ---
            function initializeApp() {
                gameContainer.style.display = 'none'; introVideoContainer.style.display = 'none'; startScreenDiv.style.display = 'flex';
                if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; }
                gameRunning = false; gamePaused = false;
                removeGameListeners();
                interaction = { pointers: new Map(), isPanning: false, isPinching: false, isInteractingNode: false, isBoxSelecting: false, currentPointerScreenPos: { x: null, y: null } };
                selectedEntities = []; activeNodeButtons = []; activeLasers = []; particles = []; units = []; nodes = [];
                ambientPointerScreenPos = { x: null, y: null }; spatialGrid = null; gameOverMessageDiv.style.display = 'none';
                currentBackgroundImage = null;
                console.log("App initialized, showing start screen.");
                firstInteractionDone = false; document.removeEventListener('pointerdown', handleFirstInteraction); document.removeEventListener('keydown', handleFirstInteraction); document.addEventListener('pointerdown', handleFirstInteraction, { once: true }); document.addEventListener('keydown', handleFirstInteraction, { once: true });
                currentLanguage = languageSelect.value || 'ca'; updateLanguage();
                soundEnabled = soundCheckbox.checked; controlSound();
                if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) { const exitMethod = document.exitFullscreen || document.mozCancelFullScreen || document.webkitExitFullscreen || document.msExitFullscreen; if (exitMethod) { exitMethod.call(document).catch(err => console.warn("Exit fullscreen error on init:", err)); } }
                if(introVideo) { introVideo.pause(); introVideo.currentTime = 0; }
                gameSpeedMultiplier = 1.0; setActiveSpeedButton();
                updatePauseButton();
                startButton.disabled = !imagesLoaded;
                if (imagesLoaded && (!stationImagePlayer || !stationImageAI)) { startButton.textContent = getText('startGame') + " (No Stations)"; console.warn("Station images failed to load, game will start without them."); }
                else if (imagesLoaded && backgroundImages.length === 0) { startButton.textContent = getText('startGame') + " (No BG)"; console.warn("Background images failed to load.");}
                else if (imagesLoaded) { startButton.textContent = getText('startGame'); }
                else { startButton.textContent = getText('loading'); }
            }
            function addGameListeners() { canvas.addEventListener('pointerdown', handlePointerDown); canvas.addEventListener('pointermove', handlePointerMove); canvas.addEventListener('pointerup', handlePointerUp); canvas.addEventListener('pointercancel', handlePointerUp); canvas.addEventListener('pointerout', handlePointerOut); canvas.addEventListener('contextmenu', preventContextMenu); canvas.addEventListener('wheel', handleWheel, { passive: false }); window.addEventListener('resize', handleResize); gameOverMessageDiv.addEventListener('click', handleGameOverClick); canvas.addEventListener('pointermove', handleAmbientPointerMove); canvas.addEventListener('pointerleave', handleAmbientPointerLeave); fullscreenButton.addEventListener('click', toggleFullScreen); speedControlsContainer.addEventListener('click', handleSpeedButtonClick); pauseButton.addEventListener('click', togglePause); menuButton.addEventListener('click', handleRestartClick); }
            function handleSpeedButtonClick(event) { if (event.target.tagName === 'BUTTON') { const speed = parseFloat(event.target.getAttribute('data-speed')); if (!isNaN(speed)) { gameSpeedMultiplier = speed; setActiveSpeedButton(); } } }
            function removeGameListeners() { canvas.removeEventListener('pointerdown', handlePointerDown); canvas.removeEventListener('pointermove', handlePointerMove); canvas.removeEventListener('pointerup', handlePointerUp); canvas.removeEventListener('pointercancel', handlePointerUp); canvas.removeEventListener('pointerout', handlePointerOut); canvas.removeEventListener('contextmenu', preventContextMenu); canvas.removeEventListener('wheel', handleWheel); window.removeEventListener('resize', handleResize); gameOverMessageDiv.removeEventListener('click', handleGameOverClick); canvas.removeEventListener('pointermove', handleAmbientPointerMove); canvas.removeEventListener('pointerleave', handleAmbientPointerLeave); fullscreenButton.removeEventListener('click', toggleFullScreen); speedControlsContainer.removeEventListener('click', handleSpeedButtonClick); pauseButton.removeEventListener('click', togglePause); menuButton.removeEventListener('click', handleRestartClick); }
            function handleRestartClick() { if (confirm(getText('restartConfirm'))) { console.log("Restart confirmed."); initializeApp(); } else { console.log("Restart cancelled."); } }
            function playIntroVideoFullScreen() { if (!introVideo || !introVideoContainer) return; introVideoContainer.style.display = 'block'; const requestFullScreen = introVideoContainer.requestFullscreen || introVideoContainer.mozRequestFullScreen || introVideoContainer.webkitRequestFullscreen || introVideoContainer.msRequestFullscreen; if (requestFullScreen) { requestFullScreen.call(introVideoContainer).then(() => { introVideo.play().catch(e => console.error("Video play error after fullscreen:", e)); }).catch(err => { console.warn(`Error attempting fullscreen: ${err.message}. Playing inline.`); introVideo.play().catch(e => console.error("Video play error (inline):", e)); }); } else { console.warn("Fullscreen API not supported. Playing inline."); introVideo.play().catch(e => console.error("Video play error (no fullscreen API):", e)); } }

            // --- Setup Inicial y Listeners Permanentes ---
            startButton.addEventListener('click', () => { console.log(`Start button clicked. imagesLoaded: ${imagesLoaded}`); if (!imagesLoaded) { console.log("Still loading..."); return; } if (!stationImagePlayer || !stationImageAI) { console.warn("Starting game without station images!"); } if (backgroundImages.length === 0) { console.warn("Starting game without background images!");}
             showBackgroundSetting = backgroundCheckbox.checked; const numNodesVal = parseInt(numNodesInput.value); const numEnemiesVal = parseInt(numEnemiesInput.value); aiDifficultySetting = aiDifficultySelect.value; if (isNaN(numNodesVal) || numNodesVal < parseInt(numNodesInput.min) || numNodesVal > parseInt(numNodesInput.max)) { alert(getText('invalidNodes', numNodesInput.min, numNodesInput.max)); return; } if (isNaN(numEnemiesVal) || numEnemiesVal < parseInt(numEnemiesInput.min) || numEnemiesVal > parseInt(numEnemiesInput.max)) { alert(getText('invalidEnemies', numEnemiesInput.min, numEnemiesInput.max)); return; } if (!['basic', 'normal', 'expert'].includes(aiDifficultySetting)) { aiDifficultySetting = 'normal'; } NUM_NEUTRAL_NODES_SETTING = numNodesVal; NUM_ENEMIES_SETTING = numEnemiesVal; startScreenDiv.style.display = 'none'; playIntroVideoFullScreen(); });
            introVideo.addEventListener('ended', () => { console.log("Intro video finished."); if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) { const exitMethod = document.exitFullscreen || document.mozCancelFullScreen || document.webkitExitFullscreen || document.msExitFullscreen; if (exitMethod) { exitMethod.call(document).catch(err => console.warn("Exit fullscreen error after video:", err)); } } introVideoContainer.style.display = 'none'; gameContainer.style.display = 'flex'; canvas.style.display = 'block'; addGameListeners(); startGameLogic(); });
            percentageButtonsContainer.addEventListener('click', (event) => { if (event.target.tagName === 'BUTTON') { const percent = parseFloat(event.target.getAttribute('data-percent')); if (!isNaN(percent)) { currentSendPercentage = percent; setActivePercentageButton(); } } });
            soundCheckbox.addEventListener('change', () => { controlSound(); });
            languageSelect.addEventListener('change', (e) => { currentLanguage = e.target.value; updateLanguage(); });
            document.addEventListener('fullscreenchange', handleResize); document.addEventListener('webkitfullscreenchange', handleResize); document.addEventListener('mozfullscreenchange', handleResize); document.addEventListener('MSFullscreenChange', handleResize);

            // --- Inicio ---
            console.log("Starting image preloading...");
            preloadImages(() => {
                console.log("Preload callback executed.");
                initializeApp();
            });

        }); // *** FIN DEL LISTENER DOMContentLoaded ***
    </script>

</body>
</html>
