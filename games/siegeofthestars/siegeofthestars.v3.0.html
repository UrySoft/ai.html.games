<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Siege of the Stars</title>
    <style>
        :root {
            --color-primary: #89ddff; /* Starfleet Blue */
            --color-accent: #ff8f8f; /* Starfleet Red */
            --color-success: #8fff7f; /* Soft Green */
            --color-danger: #ff6666; /* Alert Red */
            --color-warning: #ffee7f; /* Warning Yellow */
            --glow-primary: 0 0 5px var(--color-primary), 0 0 10px var(--color-primary);
            --glow-success: 0 0 5px var(--color-success), 0 0 10px var(--color-success);
            --glow-danger: 0 0 5px var(--color-danger), 0 0 10px var(--color-danger);
            --glow-warning: 0 0 5px var(--color-warning), 0 0 10px var(--color-warning);
        }
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: var(--color-primary);
            font-family: 'Consolas', 'Menlo', 'Monaco', monospace;
            text-shadow: 0 0 3px var(--color-primary);
            overscroll-behavior: none;
        }
        
        #splash-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 2000;
            transition: opacity 0.5s ease-out;
            padding: 20px;
            box-sizing: border-box;
        }
        #splash-screen.paused {
            background-color: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(5px);
        }
        #splash-screen h1 {
            font-size: clamp(2.5rem, 8vw, 5rem);
            margin: 0;
            color: #fff;
            text-shadow: var(--glow-primary), 0 0 20px var(--color-primary);
        }
        .epic-description {
            font-size: clamp(1rem, 2.5vw, 1.2rem);
            max-width: 600px;
            margin: 20px 0;
            line-height: 1.6;
        }
        .credits {
            font-size: 1rem;
            color: var(--color-warning);
            text-shadow: var(--glow-warning);
            margin-top: 40px;
        }
        .credits a {
            color: inherit;
            text-decoration: none;
            transition: all 0.2s;
        }
        .credits a:hover {
            color: #fff;
            text-shadow: 0 0 5px #fff;
        }
        #play-button, #resume-button {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 1.5rem;
            width: auto;
            height: auto;
        }

        canvas, #ui {
            display: none;
        }
        
        canvas {
            display: block;
            background-color: #000;
            cursor: crosshair;
            touch-action: none;
        }
        #ui {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
        }
        .ui-panel {
            background-color: rgba(10, 20, 40, 0.4);
            padding: 10px;
            border: 1px solid var(--color-primary);
            box-shadow: var(--glow-primary), inset 0 0 10px rgba(137, 221, 255, 0.2);
            pointer-events: all;
            backdrop-filter: blur(3px);
        }
        #resources { position: absolute; top: 10px; left: 10px; display: flex; gap: 20px; }
        
        #top-right-ui {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: flex-end;
        }
        #top-right-ui > * {
            pointer-events: all;
        }
        
        #build-menu {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .build-btn {
            padding: 5px;
            cursor: pointer;
            border: 1px solid var(--color-primary);
            background: transparent;
            color: var(--color-primary);
            font-family: inherit;
            font-size: 14px;
            text-shadow: inherit;
            transition: all 0.2s ease;
            box-shadow: var(--glow-primary);
            width: 50px;
            height: 50px;
            box-sizing: border-box;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .build-btn:hover:not(:disabled) {
            background: rgba(137, 221, 255, 0.1);
            color: #fff;
            text-shadow: 0 0 5px #fff;
            box-shadow: 0 0 8px var(--color-primary), 0 0 15px var(--color-primary);
        }
        .build-btn.selected {
            border-color: var(--color-success);
            color: var(--color-success);
            text-shadow: 0 0 5px var(--color-success);
            box-shadow: var(--glow-success), 0 0 15px var(--color-success);
        }
        .build-btn > canvas {
            pointer-events: none;
        }

        #game-controls { display: flex; flex-direction: column; gap: 8px; width: 150px; }
        #game-controls .build-btn { text-align: center; width: 100%; height: auto; }

        #wave-info { position: absolute; top: 60px; left: 10px; }
        #selection-panel {
            position: absolute;
            bottom: 10px;
            left: 10px;
            width: 260px;
            display: none;
        }
        #selection-header {
            display: flex;
            align-items: center;
            gap: 10px;
            border-bottom: 1px solid var(--color-primary);
            padding-bottom: 5px;
            margin-bottom: 5px;
        }
        #selection-icon {
            width: 40px;
            height: 40px;
            flex-shrink: 0;
        }
        #selection-panel h4 { margin: 0; border-bottom: none; padding-bottom: 0; color: #fff; }
        #selection-panel p { margin: 5px 0; font-size: 14px; }
        #upgrade-buttons-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-top: 10px;
        }
        .upgrade-btn {
            width: 100%;
            height: auto;
            font-size: 12px;
            padding: 6px;
            box-sizing: border-box;
            border-color: var(--color-warning); 
            color: var(--color-warning); 
            box-shadow: var(--glow-warning); 
            text-shadow: 0 0 3px var(--color-warning);
        }
        .upgrade-btn:hover:not(:disabled) { 
            background: rgba(255, 238, 127, 0.1); 
            box-shadow: 0 0 8px var(--color-warning), 0 0 15px var(--color-warning); 
        }
        .upgrade-btn:disabled {
            color: #777;
            border-color: #555;
            box-shadow: none;
            text-shadow: none;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        #destroy-btn { 
            border-color: var(--color-danger); 
            color: var(--color-danger); 
            box-shadow: var(--glow-danger); 
            text-shadow: 0 0 3px var(--color-danger); 
            width: 100%; height: auto; 
            margin-top: 10px;
        }
        #destroy-btn:hover { background: rgba(255, 102, 102, 0.1); box-shadow: 0 0 8px var(--color-danger), 0 0 15px var(--color-danger); }

        #build-confirm-dialog { position: absolute; display: none; flex-direction: column; gap: 8px; background-color: rgba(0, 0, 0, 0.85); border: 1px solid #fff; box-shadow: 0 0 10px #fff; pointer-events: all; z-index: 10; padding: 5px; }
        #confirm-build-btn { border-color: var(--color-success); color: var(--color-success); box-shadow: var(--glow-success); }
        #cancel-build-btn { border-color: var(--color-danger); color: var(--color-danger); box-shadow: var(--glow-danger); }
        #game-over { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 40px; text-align: center; font-size: 2em; display: none; z-index: 100; border: 2px solid var(--color-danger); color: var(--color-danger); text-shadow: var(--glow-danger); box-shadow: var(--glow-danger), inset 0 0 20px var(--color-danger); background: rgba(20,0,0,0.8); }
        #tooltip { position: absolute; display: none; padding: 8px; background-color: rgba(0, 0, 0, 0.9); border: 1px solid var(--color-primary); box-shadow: var(--glow-primary); max-width: 200px; font-size: 12px; pointer-events: none; z-index: 1000; }
        
        @media (max-width: 768px) and (orientation: portrait) {
            #resources { flex-direction: column; gap: 5px; }
            #wave-info { top: 80px; left: 10px; transform: none; max-width: 140px; }
            .build-btn { width: 45px; height: 45px; }
            #build-menu { gap: 5px; }
            #selection-panel { width: 220px; }
            #game-controls { width: 120px; }
            #game-controls .build-btn { font-size: 12px; padding: 8px 5px; }
            #upgrade-buttons-container { flex-direction: row; flex-wrap: wrap; justify-content: space-between; gap: 5px; }
            #selection-panel .upgrade-btn { flex: 1 0 48%; height: auto; width: auto; padding: 4px; line-height: 1.3; font-size: 11px; }
        }
        @media (orientation: landscape) { #build-menu { flex-direction: row; } }
    </style>
</head>
<body>
    
    <div id="splash-screen">
        <h1>Siege of the Stars</h1>
        <p class="epic-description">En la vasta oscuridad del cosmos, tu base es el último bastión de la humanidad. Resiste las oleadas incesantes del enemigo. Construye, defiende, sobrevive.</p>
        <button id="play-button" class="build-btn" disabled>CARGANDO...</button>
        <button id="resume-button" class="build-btn" style="display: none;">Reanudar</button>
        <p class="credits">Un juego creado por <a href="https://www.linkedin.com/in/oriol-badia/" target="_blank">Oriol Badia Campanera</a></p>
    </div>

    <canvas id="gameCanvas"></canvas>
    <div id="ui">
        <div id="resources" class="ui-panel">
            <span id="minerals"></span>
        </div>
        <div id="selection-panel" class="ui-panel">
            <div id="selection-header">
                <div id="selection-icon"></div>
                <h4 id="selection-type"></h4>
            </div>
            <p id="selection-health"></p>
            <p id="selection-shield"></p>
            <p id="selection-status"></p>
            <div id="upgrade-buttons-container"></div>
            <button id="destroy-btn" class="build-btn">Desmantelar</button>
        </div>
        
        <div id="top-right-ui">
            <div id="game-controls" class="ui-panel">
                <button id="menuBtn" class="build-btn">Menú</button>
                <button id="fullscreenBtn" class="build-btn">P. Completa</button>
            </div>
        </div>
        
        <div id="wave-info" class="ui-panel">
            <span id="wave-timer"></span>
        </div>
        
        <div id="build-menu" class="ui-panel">
            <button class="build-btn" data-type="Turret"></button>
            <button class="build-btn" data-type="Miner"></button>
            <button class="build-btn" data-type="SolarPanel"></button>
            <button class="build-btn" data-type="Pylon"></button>
            <button class="build-btn" data-type="Barracks"></button>
            <button class="build-btn" data-type="SwarmTower"></button>
            <button class="build-btn" data-type="ShieldGenerator"></button>
            <button class="build-btn" data-type="Starbase"></button> 
        </div>

        <div id="tooltip"></div>
    </div>
    <div id="build-confirm-dialog">
        <button id="confirm-build-btn" class="build-btn">✓</button>
        <button id="cancel-build-btn" class="build-btn">✕</button>
    </div>
    <div id="game-over">
        MISIÓN FALLIDA<br>BASE ESTELAR DESTRUIDA<br>
        <button onclick="sessionStorage.removeItem('sots_gamestate'); window.location.reload()" style="margin-top:20px; padding: 15px 30px; font-size: 20px;" class="build-btn">REINICIAR MISIÓN</button>
    </div>

<script>
const UI_COLORS = {};
const MAX_UPGRADE_LEVEL = 5;
const UPGRADE_NAMES = { damage: "Daño", fireRate: "Cadencia", range: "Alcance", droneCapacity: "Cap. Drones", spawnRate: "Vel. Creación", power: "Energía", connectionRange: "Alcance Red", repairRate: "Tasa Reparación", shieldAmount: "Pot. Escudo", shieldRegenRate: "Regen. Escudo" };

window.addEventListener('load', function() {
    const splashScreen = document.getElementById('splash-screen');
    const playButton = document.getElementById('play-button');
    const resumeButton = document.getElementById('resume-button');
    const credits = document.querySelector('#splash-screen .credits');
    const epicDescription = document.querySelector('#splash-screen .epic-description');

    const gameCanvas = document.getElementById('gameCanvas');
    const uiContainer = document.getElementById('ui');

    const computedStyles = getComputedStyle(document.body);
    UI_COLORS.primary = computedStyles.getPropertyValue('--color-primary').trim();
    UI_COLORS.success = computedStyles.getPropertyValue('--color-success').trim();
    UI_COLORS.danger = computedStyles.getPropertyValue('--color-danger').trim();
    UI_COLORS.warning = computedStyles.getPropertyValue('--color-warning').trim();

    const ctx = gameCanvas.getContext('2d');
    gameCanvas.width = window.innerWidth;
    gameCanvas.height = window.innerHeight;

    const WORLD_WIDTH = 3000;
    const WORLD_HEIGHT = 3000;

    const BUILDING_SPECS = {
        Core:         { name: "Base Principal", cost: 0, size: 50, health: 10000, color: '#f0f8ff', power: 50, connectionRange: 150, passiveIncome: 0.5, droneCapacity: 1, upgrades:['droneCapacity'], upgradeCosts:{droneCapacity:500}, description: "El centro de mando. Despliega drones de construcción." },
        Turret:       { name: "Torreta Fáser", cost: 50, size: 10, health: 50, color: '#ff8f8f', power: -10, range: 150, fireRate: 1000, damage: 10, upgrades:['damage', 'fireRate', 'range'], upgradeCosts:{damage:25, fireRate:35, range:20}, description: "Dispara rayos fáser a naves hostiles." },
        Miner:        { name: "Estación Minera", cost: 75, size: 15, health: 150, color: '#8fff7f', power: -25, range: 100, droneCapacity: 1, droneSpawnRate: 6000, upgrades:['droneCapacity', 'range'], upgradeCosts:{droneCapacity:50, range:30}, description: "Despliega drones para extraer minerales." },
        SolarPanel:   { name: "Reactor de Fusión", cost: 100, size: 20, health: 100, color: '#89ddff', power: 50, connectionRange: 150, upgrades:['power'], upgradeCosts:{power:75}, description: "Genera energía para la red de la base." },
        Pylon:        { name: "Relé Subespacial", cost: 25, size: 5, health: 25, color: '#ffffff', power: -5, connectionRange: 150, upgrades:['connectionRange'], upgradeCosts:{connectionRange:15}, description: "Extiende el alcance de la red de energía." },
        SwarmTower:   { name: "Bahía de Reparación", cost: 200, size: 25, health: 150, color: '#00e5e5', power: -100, range: 150, droneCapacity: 2, droneSpawnRate: 5000, repairRate: 4, upgrades:['droneCapacity', 'range', 'repairRate'], upgradeCosts:{droneCapacity:150, range:100, repairRate:125}, description: "Despliega drones de reparación autónomos." },
        Barracks:     { name: "Hangar de Cazas", cost: 200, size: 25, health: 150, color: '#af8fff', power: -100, spawnRate: 5000, range: 400, droneCapacity: 2, upgrades:['range', 'droneCapacity'], upgradeCosts:{range: 100, droneCapacity: 175}, description: "Construye Cazas de Defensa que operan en un radio limitado. Capacidad inicial de 5 cazas." },
        Starbase:     { name: "Base Secundaria", cost: 2500, size: 40, health: 1000, color: '#d8a4ff', power: 25, connectionRange: 150, droneCapacity: 1, upgrades:['droneCapacity', 'connectionRange'], upgradeCosts:{droneCapacity:200, connectionRange: 150}, description: "Centro de mando avanzado que extiende la red." },
        ShieldGenerator: { name: "Generador de Escudo", cost: 500, size: 20, health: 50, color: '#4d94ff', power: -200, range: 150, shieldAmount: 200, shieldRegenRate: 10, shieldRegenDelay: 3000, upgrades:['shieldAmount', 'range', 'shieldRegenRate'], upgradeCosts:{shieldAmount:125, range:100, shieldRegenRate:150}, description: "Proyecta un escudo de energía sobre las unidades y estructuras cercanas." },
        Infantry:     { name: "Caza de Defensa", size: 6, health: 30, color: '#00ff7f', speed: 100, range: 200, fireRate: 500, damage: 5 },
        RepairDrone:  { name: "Dron de Reparación", size: 5, health: 15, color: '#39ff14', speed: 30, repairRate: 5, isFlying: true },
        CollectorDrone: { name: "Dron Recolector", size: 8, health: 20, color: '#ffff7f', speed: 30, carryCapacity: 5, isFlying: true },
        ConstructionDrone: { name: "Dron de Construcción", size: 8, health: 20, color: '#ffee7f', speed: 70, buildRate: 20 },
        Grunt:        { name: "Nave Hostil", size: 6, health: 75, color: '#ff6666', speed: 30, damage: 15, range: 50, fireRate: 2000, points: 3 },
        Flier:        { name: "Caza Hostil", size: 8, health: 35, color: '#ffdd00', speed: 60, damage: 5, range: 150, fireRate: 500, isFlying: true, points: 4 }
    };

    const AssetManager = {
        images: {}, loadedCount: 0, errorCount: 0, totalCount: 0,
        loadAssets(callback) {
            const imagePath = 'https://urysoft.github.io/ai.html.games/general/assets/images/';
            const typesToLoad = Object.keys(BUILDING_SPECS).filter(type => ['Core', 'Turret', 'Miner', 'SolarPanel', 'Pylon', 'SwarmTower', 'Barracks', 'Starbase', 'ShieldGenerator'].includes(type));
            this.totalCount = typesToLoad.length; if (this.totalCount === 0) { if(callback) callback(); return; }
            typesToLoad.forEach(type => {
                const img = new Image(); this.images[type] = img;
                img.onload = () => { this.loadedCount++; if (this.loadedCount + this.errorCount >= this.totalCount) { if(callback) callback(); } };
                img.onerror = () => { this.errorCount++; this.images[type] = null; if (this.loadedCount + this.errorCount >= this.totalCount) { if(callback) callback(); } };
                img.src = `${imagePath}${type}.png`;
            });
        }
    };
    
    function getRandomEdgePosition(worldW, worldH) { const margin = 50; const side = Math.floor(Math.random() * 4); switch (side) { case 0: return { x: Math.random() * worldW, y: -margin }; case 1: return { x: worldW + margin, y: Math.random() * worldH }; case 2: return { x: Math.random() * worldW, y: worldH + margin }; case 3: return { x: -margin, y: Math.random() * worldH }; } }
    function distance(x1, y1, x2, y2) { const dx = x2 - x1, dy = y2 - y1; return Math.sqrt(dx*dx + dy*dy); }
    
    function applySeparation(unit, allUnits, allEnemies, dt) {
        const separationForce = 0.5;
        let separationVector = { x: 0, y: 0 };
        const checkSeparation = (other) => {
            if (unit === other) return;
            const dist = distance(unit.x, unit.y, other.x, other.y);
            const desiredSeparation = unit.size + other.size + 2; 
            if (dist > 0 && dist < desiredSeparation) {
                const pushForce = 1 - (dist / desiredSeparation);
                separationVector.x += (unit.x - other.x) / dist * pushForce;
                separationVector.y += (unit.y - other.y) / dist * pushForce;
            }
        };
        allUnits.forEach(checkSeparation);
        allEnemies.forEach(checkSeparation);
        if (separationVector.x !== 0 || separationVector.y !== 0) {
            const moveSpeed = unit.specs.speed * separationForce * (dt / 1000);
            unit.x += separationVector.x * moveSpeed;
            unit.y += separationVector.y * moveSpeed;
        }
    }

    class ParallaxBackground {
        constructor(worldW, worldH) { this.layers = [ { speed: 0.2, count: 150, size: 0.5, color: '#446', stars: [] }, { speed: 0.4, count: 200, size: 1.0, color: '#779', stars: [] }, { speed: 0.6, count: 250, size: 1.5, color: '#bbc', stars: [] } ]; this.layers.forEach(layer => this.generateStars(layer, worldW, worldH)); }
        generateStars(layer, worldW, worldH) { for (let i = 0; i < layer.count; i++) { layer.stars.push({ x: Math.random() * worldW, y: Math.random() * worldH }); } }
        draw(ctx, camera, canvas) { ctx.save(); ctx.fillStyle = '#050510'; ctx.fillRect(0, 0, canvas.width, canvas.height); this.layers.forEach(layer => { ctx.save(); ctx.fillStyle = layer.color; const pX = (canvas.width / 2) - camera.x * layer.speed; const pY = (canvas.height / 2) - camera.y * layer.speed; ctx.translate(pX, pY); layer.stars.forEach(star => { ctx.beginPath(); ctx.arc(star.x, star.y, layer.size, 0, 2*Math.PI); ctx.fill(); }); ctx.restore(); }); ctx.restore(); }
    }
    
    class GameEntity {
        constructor(x, y, type) {
            this.x = x; this.y = y; this.type = type;
            this.baseSpecs = {...BUILDING_SPECS[type]}; this.attackers = 0;
            this.upgradeLevels = {};
            if (this.baseSpecs.upgrades) { this.baseSpecs.upgrades.forEach(upg => { this.upgradeLevels[upg] = 1; }); }
            this.shieldHealth = 0; this.maxShieldHealth = 0; this.shieldRegenTimer = 0;
            if (this.type === 'Core' || this.type === 'Starbase') {
                this.gridProduction = 0;
                this.gridConsumption = 0;
            }
            this.applyLevelStats();
        }
        applyLevelStats() {
            this.specs = { ...this.baseSpecs }; this.size = this.specs.size;
            this.maxHealth = this.baseSpecs.health;
            if (!this.health) { this.health = this.maxHealth; }
            for (const upg in this.upgradeLevels) {
                const level = this.upgradeLevels[upg];
                if (level > 1) {
                    const factor = 1 + (level - 1) * 0.25;
                    if (['fireRate', 'spawnRate', 'droneSpawnRate'].includes(upg)) { this.specs[upg] = this.baseSpecs[upg] / factor; } 
                    else if (upg === 'droneCapacity') { this.specs[upg] = this.baseSpecs[upg] + (level - 1); } 
                    else { this.specs[upg] = this.baseSpecs[upg] * factor; }
                }
            }
        }
        takeDamage(damage) {
            this.shieldRegenTimer = this.specs.shieldRegenDelay || 3000;
            if (this.shieldHealth > 0) {
                const damageToShield = Math.min(damage, this.shieldHealth);
                this.shieldHealth -= damageToShield;
                damage -= damageToShield;
            }
            if (damage > 0) { this.health -= damage; }
        }
        drawShield(ctx) {
            if (this.shieldHealth > 0 && this.maxShieldHealth > 0) {
                ctx.save();
                const shieldPct = this.shieldHealth / this.maxShieldHealth;
                ctx.globalAlpha = 0.2 + 0.5 * shieldPct;
                ctx.beginPath();
                ctx.strokeStyle = UI_COLORS.primary;
                ctx.lineWidth = 1 + 2 * shieldPct;
                ctx.shadowColor = UI_COLORS.primary;
                ctx.shadowBlur = 10 + 5 * shieldPct;
                ctx.arc(this.x, this.y, this.size + 4, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.restore();
            }
        }
        drawNeon(ctx, shape='circle') {
            const c = this.specs.color; ctx.save(); ctx.strokeStyle = c; ctx.fillStyle = c.startsWith('#') ? c+'1A' : c.replace('rgb','rgba').replace(')',',0.1)'); ctx.lineWidth =2; ctx.shadowColor=c; ctx.shadowBlur=15; ctx.beginPath();
            if (shape==='circle') ctx.arc(this.x,this.y,this.size,0,2*Math.PI);
            else { ctx.moveTo(this.x, this.y - this.size); ctx.lineTo(this.x + this.size*0.7, this.y); ctx.lineTo(this.x, this.y + this.size); ctx.lineTo(this.x - this.size*0.7, this.y); ctx.closePath(); }
            ctx.stroke(); ctx.fill(); ctx.restore();
        }
        drawHealthBar(ctx) {
            if (this.health < this.maxHealth) {
                const hp = this.health/this.maxHealth; const barY = this.y - this.size - 10;
                ctx.fillStyle='#333'; ctx.fillRect(this.x-this.size, barY, this.size*2, 4);
                ctx.fillStyle = hp>0.5 ? UI_COLORS.success : hp>0.2 ? UI_COLORS.warning : UI_COLORS.danger;
                ctx.fillRect(this.x-this.size, barY, this.size*2*hp, 4);
            }
        }
    }

    function drawBuildingPath(ctx, type, size, x, y) { const s = size; ctx.beginPath(); switch (type) { case 'Pylon': ctx.rect(x - s, y - s, s * 2, s * 2); break; case 'SolarPanel': ctx.moveTo(x, y - s); ctx.lineTo(x - s, y + s * 0.8); ctx.lineTo(x + s, y + s * 0.8); ctx.closePath(); break; case 'Turret': ctx.moveTo(x, y - s); ctx.lineTo(x + s, y); ctx.lineTo(x, y + s); ctx.lineTo(x - s, y); ctx.closePath(); break; case 'Miner': for (let i = 0; i < 6; i++) { ctx.lineTo(x + s * Math.cos(i * 2 * Math.PI / 6), y + s * Math.sin(i * 2 * Math.PI / 6)); } ctx.closePath(); break; case 'Barracks': for (let i = 0; i < 8; i++) { ctx.lineTo(x + s * Math.cos(i * 2 * Math.PI / 8), y + s * Math.sin(i * 2 * Math.PI / 8)); } ctx.closePath(); break; case 'Starbase': for (let i = 0; i < 10; i++) { ctx.lineTo(x + s * Math.cos(i * 2 * Math.PI / 10), y + s * Math.sin(i * 2 * Math.PI / 10)); } ctx.closePath(); break; case 'SwarmTower': const arm = s * 0.35; ctx.moveTo(x - arm, y - s); ctx.lineTo(x + arm, y - s); ctx.lineTo(x + arm, y - arm); ctx.lineTo(x + s, y - arm); ctx.lineTo(x + s, y + arm); ctx.lineTo(x + arm, y + arm); ctx.lineTo(x + arm, y + s); ctx.lineTo(x - arm, y + s); ctx.lineTo(x - arm, y + arm); ctx.lineTo(x - s, y + arm); ctx.lineTo(x - s, y - arm); ctx.lineTo(x - arm, y - arm); ctx.closePath(); break; case 'ShieldGenerator': for (let i = 0; i < 3; i++) { const angle = i * 2 * Math.PI / 3; ctx.moveTo(x, y); ctx.arc(x, y, s, angle, angle + Math.PI / 3); } ctx.closePath(); break; default: ctx.arc(x, y, s, 0, 2 * Math.PI); } }
    function createIconCanvas(type, width, height) { const c = document.createElement('canvas'); c.width = width; c.height = height; const iCtx = c.getContext('2d'); const img = AssetManager.images[type]; if (img && img.complete && img.naturalHeight !== 0) { iCtx.drawImage(img, 0, 0, width, height); } else { const s = BUILDING_SPECS[type]; if (!s) return c; const col = s.color; iCtx.strokeStyle=col; iCtx.fillStyle=col.startsWith('#')?col+'2A':col.replace('rgb','rgba').replace(')',',0.15)'); iCtx.lineWidth=2; iCtx.shadowColor=col; iCtx.shadowBlur=8; const sSize = Math.min(width, height) * 0.4; drawBuildingPath(iCtx, type, sSize, width / 2, height / 2); iCtx.stroke(); iCtx.fill(); } return c; }
    function populateUiIcons() { document.querySelectorAll('#build-menu .build-btn[data-type]').forEach(btn => { btn.innerHTML = ''; const type = btn.dataset.type; const canvas = createIconCanvas(type, 40, 40); btn.appendChild(canvas); }); }

    class Building extends GameEntity {
        constructor(x,y,type) { super(x,y,type); this.isPowered=false; this.isConstructing = true; this.health = 1; this.assignedDrone = null; }
        performUpgrade(upgradeType) { if (!this.baseSpecs.upgrades.includes(upgradeType) || this.upgradeLevels[upgradeType] >= MAX_UPGRADE_LEVEL) return false; const cost = this.getUpgradeCost(upgradeType); if (game.minerals >= cost) { game.minerals -= cost; this.upgradeLevels[upgradeType]++; this.applyLevelStats(); return true; } return false; }
        getUpgradeCost(upgradeType) { const baseCost = this.baseSpecs.upgradeCosts[upgradeType]; const level = this.upgradeLevels[upgradeType]; return Math.floor(baseCost * Math.pow(1.8, level - 1)); }
        draw(ctx) {
            const isUnpoweredConsumer = !this.isPowered && this.specs.power < 0 && !this.isConstructing;
            const img = AssetManager.images[this.type]; const isRenderableImage = img && img.complete && img.naturalHeight !== 0;
            ctx.save();
            if (isUnpoweredConsumer) { ctx.filter = isRenderableImage ? 'grayscale(1) brightness(0.6)' : 'none'; }
            if (this.isConstructing) { ctx.globalAlpha = 0.2 + 0.8 * (this.health / this.maxHealth); }
            if (isRenderableImage) { ctx.drawImage(img, this.x - this.size, this.y - this.size, this.size * 2, this.size * 2); } 
            else { const col = isUnpoweredConsumer ? '#555' : this.specs.color; ctx.strokeStyle=col; ctx.fillStyle=col.startsWith('#')?col+'2A':col.replace('rgb','rgba').replace(')',',0.15)'); ctx.lineWidth=2; ctx.shadowColor=col; ctx.shadowBlur=15; drawBuildingPath(ctx, this.type, this.size, this.x, this.y); ctx.stroke(); ctx.fill(); }
            ctx.restore();
            if (isUnpoweredConsumer && Math.floor(Date.now()/250)%2===0) { const icon = this.size*0.5; ctx.save(); ctx.strokeStyle = UI_COLORS.warning; ctx.lineWidth=2; ctx.shadowColor = UI_COLORS.warning; ctx.shadowBlur=10; ctx.beginPath(); ctx.moveTo(this.x-icon*0.2, this.y-icon); ctx.lineTo(this.x+icon*0.6, this.y); ctx.lineTo(this.x+icon*0.2, this.y+icon); ctx.stroke(); ctx.restore(); }
            this.drawHealthBar(ctx);
            this.drawShield(ctx);
        }
        update(game,dt){}
    }
    class Unit extends GameEntity { constructor(x,y,type){ super(x,y,type); this.target=null; this.health = this.maxHealth; } update(game,dt){} draw(ctx){ this.drawNeon(ctx); this.drawHealthBar(ctx); this.drawShield(ctx); } }
    
    class Core extends Building { constructor(x,y){ super(x,y,'Core'); this.isConstructing = false; this.health = this.maxHealth; this.drones=[]; } update(game, dt) { this.drones = this.drones.filter(d => d.health > 0); if (this.drones.length < this.specs.droneCapacity) { const drone = new ConstructionDrone(this.x, this.y, this); this.drones.push(drone); game.units.push(drone); } } }
    class Starbase extends Building { constructor(x, y) { super(x, y, 'Starbase'); this.drones = []; } update(game, dt) { if (this.isConstructing) return; this.drones = this.drones.filter(d => d.health > 0); if (this.isPowered && this.drones.length < this.specs.droneCapacity) { const drone = new ConstructionDrone(this.x, this.y, this); this.drones.push(drone); game.units.push(drone); } } }
    class Pylon extends Building { constructor(x,y){ super(x,y,'Pylon'); } }
    class SolarPanel extends Building { constructor(x,y){ super(x,y,'SolarPanel'); } }
    class ShieldGenerator extends Building { constructor(x,y) { super(x,y,'ShieldGenerator');} }
    class Miner extends Building { constructor(x,y){ super(x,y,'Miner'); this.drones=[]; this.spawnCooldown=0; } update(game,dt){ if(this.isConstructing) return; this.drones = this.drones.filter(d => d.health > 0); if (!this.isPowered) { this.drones.forEach(d => d.parentPowered = false); return; } this.drones.forEach(d => d.parentPowered = true); this.spawnCooldown -= dt; if(this.drones.length < this.specs.droneCapacity && this.spawnCooldown <= 0){ const drone = new CollectorDrone(this.x, this.y); drone.parentMiner = this; this.drones.push(drone); game.units.push(drone); this.spawnCooldown = this.specs.droneSpawnRate; } } draw(ctx) { super.draw(ctx); if (!this.isConstructing && (game.selectedBuilding === this || game.buildingToPlace?.type === 'Miner')) { ctx.beginPath(); ctx.strokeStyle = this.specs.color + '40'; ctx.lineWidth = 1; ctx.arc(this.x, this.y, this.specs.range, 0, 2 * Math.PI); ctx.stroke(); } } }
    class Turret extends Building { constructor(x,y){ super(x,y,'Turret'); this.cooldown=0; this.target=null; } update(game,dt){ if(this.isConstructing || !this.isPowered){ this.target=null; return; } this.cooldown -= dt; if(!this.target || (this.target.health<=0 && this.target.shieldHealth <= 0) || distance(this.x,this.y,this.target.x,this.target.y)>this.specs.range){ this.findTarget(game.enemies); } if(this.target && this.cooldown<=0){ game.projectiles.push(new Projectile(this.x,this.y,this.target,this.specs.damage,this.specs.color)); this.cooldown = this.specs.fireRate; } } findTarget(enemies){ this.target = null; let dmax = this.specs.range; for(const e of enemies){ const d = distance(this.x,this.y,e.x,e.y); if(d<dmax){ dmax = d; this.target = e; } } } }
    class Barracks extends Building { 
        constructor(x,y){ super(x,y,'Barracks'); this.spawnCooldown=0; this.rallyPoint={x,y:y+50}; this.fighters=[]; } 
        update(game,dt){ 
            if(this.isConstructing || !this.isPowered) return;
            this.fighters = this.fighters.filter(f => f.health > 0);
            this.spawnCooldown -= dt; 
            if(this.fighters.length < this.specs.droneCapacity && this.spawnCooldown<=0){ 
                const u = new Infantry(this.x,this.y); 
                u.rallyPoint = {...this.rallyPoint};
                u.parentBarracks = this;
                game.units.push(u); 
                this.fighters.push(u); 
                this.spawnCooldown = this.specs.spawnRate; 
            } 
        } 
        draw(ctx){ super.draw(ctx); if(!this.isConstructing && game.selectedBuilding===this){ ctx.beginPath(); ctx.strokeStyle = '#00ff7f'; ctx.setLineDash([5,5]); ctx.moveTo(this.x,this.y); ctx.lineTo(this.rallyPoint.x,this.rallyPoint.y); ctx.stroke(); ctx.setLineDash([]); ctx.beginPath(); ctx.arc(this.rallyPoint.x,this.rallyPoint.y,10,0,2*Math.PI); ctx.stroke(); } } 
    }
    class SwarmTower extends Building { constructor(x,y){ super(x,y,'SwarmTower'); this.drones=[]; this.spawnCooldown=0; } update(game,dt){ if(this.isConstructing) return; this.drones = this.drones.filter(d=>d.health>0); if(!this.isPowered){ this.drones.forEach(d=>d.parentPowered=false); return; } this.drones.forEach(d=>d.parentPowered=true); this.spawnCooldown -= dt; if(this.drones.length < this.specs.droneCapacity && this.spawnCooldown<=0){ const d = new RepairDrone(this.x,this.y); d.parentTower = this; this.drones.push(d); game.units.push(d); this.spawnCooldown = this.specs.droneSpawnRate; } } }
    
    class Infantry extends Unit { 
        constructor(x,y){ 
            super(x,y,'Infantry'); 
            this.cooldown=0; 
            this.rallyPoint={x,y}; 
            this.parentBarracks = null;
            this.state='movingToRally'; 
        } 
        update(game,dt){
            applySeparation(this, game.units, game.enemies, dt);
            if (!this.parentBarracks || this.parentBarracks.health <= 0) { this.health = 0; return; }
            this.cooldown -= dt;
            const operationalRange = this.parentBarracks.specs.range;
            if (this.target) {
                const targetIsInvalid = this.target.health <= 0 && this.target.shieldHealth <= 0;
                const targetOutOfRange = distance(this.target.x, this.target.y, this.parentBarracks.x, this.parentBarracks.y) > operationalRange + 50; 
                if (targetIsInvalid || targetOutOfRange) { this.target = null; this.state = 'movingToRally'; }
            }
            if (!this.target) {
                let closestTarget = null;
                let minDistance = Infinity;
                const enemiesInOpRange = game.enemies.filter(e => distance(e.x, e.y, this.parentBarracks.x, this.parentBarracks.y) <= operationalRange);
                for (const enemy of enemiesInOpRange) { const d = distance(this.x, this.y, enemy.x, enemy.y); if (d < minDistance) { minDistance = d; closestTarget = enemy; } }
                if (closestTarget) { this.target = closestTarget; this.state = 'fighting'; }
            }
            if (this.state === 'fighting' && this.target) {
                const distToTarget = distance(this.x, this.y, this.target.x, this.target.y);
                if (distToTarget > this.specs.range * 0.9) {
                    const dx = (this.target.x - this.x) / distToTarget; const dy = (this.target.y - this.y) / distToTarget; 
                    this.x += dx * this.specs.speed * dt / 1000; this.y += dy * this.specs.speed * dt / 1000;
                }
                if (this.cooldown <= 0) { game.projectiles.push(new Projectile(this.x, this.y, this.target, this.specs.damage, this.specs.color)); this.cooldown = this.specs.fireRate; }
            } else { 
                this.state = 'movingToRally';
                const distToRally = distance(this.x, this.y, this.rallyPoint.x, this.rallyPoint.y);
                if (distToRally > 10) {
                    const dx = (this.rallyPoint.x - this.x) / distToRally; const dy = (this.rallyPoint.y - this.y) / distToRally;
                    this.x += dx * this.specs.speed * dt / 1000; this.y += dy * this.specs.speed * dt / 1000;
                } else { this.state = 'patrolling'; }
            }
        } 
    }
    
    class RepairDrone extends Unit { 
        constructor(x,y){ super(x,y,'RepairDrone'); this.parentTower=null; this.parentPowered=true; } 
        update(game,dt){ 
            applySeparation(this, game.units, game.enemies, dt);
            if (!this.parentTower || this.parentTower.health <= 0) { this.health = 0; return; }
            if(!this.parentPowered){ this.target=null; return; } 
            if(!this.target || this.target.health>=this.target.maxHealth || this.target.health<=0){ this.findTarget(game); } 
            if(this.target){ 
                const d = distance(this.x,this.y,this.target.x,this.target.y); 
                if(d> this.target.size+10){ const dx = (this.target.x - this.x)/d; const dy = (this.target.y - this.y)/d; this.x += dx * this.specs.speed * dt/1000; this.y += dy * this.specs.speed * dt/1000; } 
                else { this.target.health += this.specs.repairRate * dt/1000; if(this.target.health > this.target.maxHealth) this.target.health = this.target.maxHealth; } 
            } else { 
                const dp = distance(this.x,this.y,this.parentTower.x,this.parentTower.y); 
                if(dp>50){ const dx = (this.parentTower.x - this.x)/dp; const dy = (this.parentTower.y - this.y)/dp; this.x += dx * this.specs.speed*0.5 * dt/1000; this.y += dy * this.specs.speed*0.5 * dt/1000; } 
            } 
        } 
        findTarget(game){ this.target=null; let lowPct=1; const all = [...game.buildings,...game.units]; for(const t of all){ if(t.health > 0 && t.health < t.maxHealth && distance(this.parentTower.x,this.parentTower.y,t.x,t.y)<this.parentTower.specs.range){ const pct = t.health/t.maxHealth; if(pct<lowPct){ lowPct=pct; this.target=t; } } } } 
        draw(ctx){ super.draw(ctx); if(this.target && this.parentPowered){ ctx.beginPath(); ctx.moveTo(this.x,this.y); ctx.lineTo(this.target.x,this.target.y); ctx.strokeStyle=this.specs.color; ctx.lineWidth=1; ctx.setLineDash([2,2]); ctx.shadowColor=this.specs.color; ctx.shadowBlur=10; ctx.stroke(); ctx.setLineDash([]); ctx.shadowBlur=0; } } 
    }

    class CollectorDrone extends Unit { 
        constructor(x, y) { super(x, y, 'CollectorDrone'); this.parentMiner = null; this.parentPowered = true; this.state = 'seeking'; this.heldMinerals = 0; this.collectionTime = 1000; this.collectionTimer = 0; } 
        update(game, dt) { 
            applySeparation(this, game.units, game.enemies, dt);
            if (!this.parentMiner || this.parentMiner.health <= 0) { this.health = 0; return; }
            if (!this.parentPowered) { this.state = 'returning'; }
            if (this.state === 'seeking') { if (!this.target || this.target.minerals <= 0) this.findTarget(game); if (this.target) { this.moveTo(this.target.x, this.target.y, dt); if (distance(this.x, this.y, this.target.x, this.target.y) < this.target.size) { this.state = 'collecting'; this.collectionTimer = this.collectionTime; } } else { this.state = 'returning'; } } else if (this.state === 'collecting') { if (!this.target || this.target.minerals <= 0) { this.state = 'returning'; return; } this.collectionTimer -= dt; const mineralsToTake = (this.specs.carryCapacity / (this.collectionTime/1000)) * (dt/1000); const actualTaken = Math.min(mineralsToTake, this.target.minerals); this.heldMinerals += actualTaken; this.target.minerals -= actualTaken; if (this.collectionTimer <= 0 || this.heldMinerals >= this.specs.carryCapacity) { this.state = 'returning'; } } else if (this.state === 'returning') { this.moveTo(this.parentMiner.x, this.parentMiner.y, dt); if (distance(this.x, this.y, this.parentMiner.x, this.parentMiner.y) < this.parentMiner.size) { game.minerals += this.heldMinerals; this.heldMinerals = 0; this.target = null; this.state = 'seeking'; } } 
        } 
        moveTo(tx, ty, dt) { const d = distance(this.x, this.y, tx, ty); if (d < 1) return; const dx = (tx - this.x) / d; const dy = (ty - this.y) / d; this.x += dx * this.specs.speed * dt / 1000; this.y += dy * this.specs.speed * dt / 1000; } 
        findTarget(game) { this.target = null; let closestDist = this.parentMiner.specs.range; for (const well of game.asteroidFields) { if (well.minerals > 0) { const d = distance(this.parentMiner.x, this.parentMiner.y, well.x, well.y); if (d < closestDist) { closestDist = d; this.target = well; } } } } 
        draw(ctx) { super.draw(ctx); if (this.heldMinerals > 0) { ctx.fillStyle = '#ffff00'; ctx.beginPath(); ctx.arc(this.x, this.y, this.size * 0.5 * (this.heldMinerals / this.specs.carryCapacity), 0, 2 * Math.PI); ctx.fill(); } } 
    }
    
    class ConstructionDrone extends Unit {
        constructor(x, y, parentBase) { super(x, y, 'ConstructionDrone'); this.parentBase = parentBase; this.targetBuilding = null; }
        update(game, dt) {
            applySeparation(this, game.units, game.enemies, dt);
            if (!this.parentBase || this.parentBase.health <= 0) { this.targetBuilding = null; this.health = 0; return; }
            if (this.targetBuilding) {
                if (this.targetBuilding.health <= 0) { this.targetBuilding = null; return; }
                const d = distance(this.x, this.y, this.targetBuilding.x, this.targetBuilding.y);
                if (d > this.targetBuilding.size + 10) { const dx = (this.targetBuilding.x - this.x) / d; const dy = (this.targetBuilding.y - this.y) / d; this.x += dx * this.specs.speed * dt / 1000; this.y += dy * this.specs.speed * dt / 1000; } 
                else {
                    this.targetBuilding.health += this.specs.buildRate * dt / 1000;
                    if (this.targetBuilding.health >= this.targetBuilding.maxHealth) {
                        this.targetBuilding.health = this.targetBuilding.maxHealth; this.targetBuilding.isConstructing = false;
                        this.targetBuilding.assignedDrone = null; this.targetBuilding = null;
                        game.constructionQueue = game.constructionQueue.filter(b => b.health < b.maxHealth);
                    }
                }
            } else { const dp = distance(this.x, this.y, this.parentBase.x, this.parentBase.y); if (dp > 50) { const dx = (this.parentBase.x - this.x) / dp; const dy = (this.parentBase.y - this.y) / dp; this.x += dx * this.specs.speed * 0.5 * dt / 1000; this.y += dy * this.specs.speed * 0.5 * dt / 1000; } }
        }
        draw(ctx) { super.draw(ctx); if (this.targetBuilding) { ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.targetBuilding.x, this.targetBuilding.y); ctx.strokeStyle = this.specs.color; ctx.lineWidth = 1.5; ctx.setLineDash([3, 3]); ctx.shadowColor = this.specs.color; ctx.shadowBlur = 10; ctx.stroke(); ctx.setLineDash([]); ctx.shadowBlur = 0; } }
    }
    class Enemy extends Unit {
        constructor(x, y, type) { super(x, y, type); this.baseHealth = this.specs.health; this.baseDamage = this.specs.damage; this.cooldown = Math.random() * 1000; }
        applyWaveBonus(n) { const hb = 1 + (n - 1) * 0.08, db = 1 + (n - 1) * 0.05; this.maxHealth = Math.floor(this.baseHealth * hb); this.health = this.maxHealth; this.specs.damage = Math.floor(this.baseDamage * db); }
        update(game, dt) { 
            applySeparation(this, game.units, game.enemies, dt);
            if (this.target && (this.target.health <= 0 && this.target.shieldHealth <= 0)) { this.target.attackers--; this.target = null; } if (!this.target) this.findTarget(game); this.cooldown -= dt; if (this.target) { const d = distance(this.x, this.y, this.target.x, this.target.y); if (d > this.specs.range) { const dx = (this.target.x - this.x) / d, dy = (this.target.y - this.y) / d; this.x += dx * this.specs.speed * dt / 1000; this.y += dy * this.specs.speed * dt / 1000; } else if (this.cooldown <= 0) { game.projectiles.push(new Projectile(this.x, this.y, this.target, this.specs.damage, this.specs.color)); this.cooldown = this.specs.fireRate; } } 
        }
        findTarget(game) { const all = [...game.buildings, ...game.units].filter(t => !t.isConstructing); if(all.length === 0) return; const core = game.buildings.find(b => b.type === 'Core'); if (!core) return; all.sort((a, b) => distance(this.x, this.y, a.x, a.y) - distance(this.x, this.y, b.x, b.y)); let best = null; for (let i = 0; i < all.length && i < 5; i++) { const t = all[i]; if (t.attackers < 3) { best = t; break; } if (Math.random() > 0.75) { best = t; break; } } if (!best) best = all[0] || core; if (this.target) this.target.attackers--; this.target = best; if (this.target) this.target.attackers++; }
    }
    class Grunt extends Enemy { constructor(x,y){ super(x,y,'Grunt'); } }
    class Flier extends Enemy { constructor(x,y){ super(x,y,'Flier'); } }
    class Projectile { constructor(x,y,target,damage,color){ this.x=x; this.y=y; this.target=target; this.damage=damage; this.color=color; this.speed=400; this.size=3; this.shouldBeRemoved=false; } update(dt){ if(!this.target||(this.target.health<=0 && this.target.shieldHealth <= 0)){ this.shouldBeRemoved=true; return; } const dx=this.target.x-this.x, dy=this.target.y-this.y; const dist=Math.sqrt(dx*dx+dy*dy); if(dist<this.size+this.target.size){ this.target.takeDamage(this.damage); this.shouldBeRemoved=true; } else { this.x += dx/dist * this.speed * dt/1000; this.y += dy/dist * this.speed * dt/1000; } } draw(ctx){ ctx.beginPath(); ctx.fillStyle=this.color; ctx.shadowColor=this.color; ctx.shadowBlur=10; ctx.arc(this.x,this.y,this.size,0,2*Math.PI); ctx.fill(); ctx.shadowBlur=0; } }
    class AsteroidField { constructor(x, y, size, amount) { this.x = x; this.y = y; this.size = size; this.initialMinerals = amount; this.minerals = amount; this.asteroids = []; for (let i = 0; i < 5 + (size / 5); i++) { this.asteroids.push({ ox: (Math.random() - 0.5) * size * 1.5, oy: (Math.random() - 0.5) * size * 1.5, s: Math.random() * (size / 4) + (size / 5), c: `rgb(${100+Math.random()*20}, ${90+Math.random()*20}, ${80+Math.random()*20})` }); } } draw(ctx) { const op = (this.minerals / this.initialMinerals) * 0.8 + 0.2; ctx.save(); ctx.globalAlpha = op; this.asteroids.forEach(a => { ctx.fillStyle = a.c; ctx.beginPath(); ctx.arc(this.x + a.ox, this.y + a.oy, a.s, 0, 2 * Math.PI); ctx.fill(); }); const pulse = Math.sin(Date.now() / 500) * 5 + 5; ctx.shadowColor = '#ffffaa'; ctx.shadowBlur = pulse + 10; ctx.fillStyle = `rgba(200, 200, 150, ${op*0.1})`; ctx.beginPath(); ctx.arc(this.x, this.y, this.size * 1.5, 0, 2 * Math.PI); ctx.fill(); ctx.restore(); } }
    
    class WaveManager { 
        constructor(game){ 
            this.game=game; this.waveNumber=0; 
            this.baseTimeToNextWave=90000; 
            this.timeReductionPerWave=2000; 
            this.minTimeBetweenWaves=45000; 
            this.timeToNextWave=15000; 
            this.waveInProgress=false; 
        } 
        update(dt){ if(this.waveInProgress){ if(this.game.enemies.length===0) this.endWave(); } else { this.timeToNextWave -= dt; if(this.timeToNextWave<=0) this.startNextWave(); } } 
        startNextWave(){ this.waveNumber++; this.waveInProgress=true; const comp = this.calculateWaveComposition(); for(const t of comp){ const pos = getRandomEdgePosition(this.game.worldWidth, this.game.worldHeight); let ne=null; if(t==='Grunt') ne=new Grunt(pos.x,pos.y); if(t==='Flier') ne=new Flier(pos.x,pos.y); if(ne){ ne.applyWaveBonus(this.waveNumber); this.game.enemies.push(ne); } } } 
        endWave(){ this.waveInProgress=false; this.game.minerals += 100 + this.waveNumber*25; this.timeToNextWave = Math.max(this.minTimeBetweenWaves, this.baseTimeToNextWave - this.waveNumber*this.timeReductionPerWave); } 
        calculateWaveComposition(){ let comp=[]; let points = this.waveNumber*5 + Math.pow(this.waveNumber,1.8)*0.8; let types = [{type:'Grunt',cost:3},{type:'Flier',cost:4}]; if(this.waveNumber<3) types.pop(); while(points>0){ const avail = types.filter(e=>e.cost<=points); if(!avail.length) break; const e = avail[Math.floor(Math.random()*avail.length)]; comp.push(e.type); points -= e.cost; } return comp; } 
    }
    
    const AllClasses = { Core, Starbase, Pylon, SolarPanel, ShieldGenerator, Miner, Turret, Barracks, SwarmTower, Infantry, RepairDrone, CollectorDrone, ConstructionDrone, Grunt, Flier };

    class Game {
        constructor(width,height){
            this.width = width;
            this.height = height;
            this.worldWidth = WORLD_WIDTH;
            this.worldHeight = WORLD_HEIGHT;
            this.saveInterval = 2000;
            this.lastSaveTime = 0;
            this.isPaused = false;
        }
        
        init(isReload = false){
            Object.assign(this, { minerals: 250, buildings: [], units: [], enemies: [], projectiles: [], asteroidFields: [], buildingToPlace: null, selectedBuilding: null, isGameOver: false, isPaused: false, camera: { x: this.worldWidth/2, y: this.worldHeight/2, zoom:1 }, mouse: { screenX:0, screenY:0, worldX:0, worldY:0, down:false, lastDownTime:0, startX:0, startY:0, lastMoveX:0, lastMoveY:0 }, pointers: [], initialPinchDistance: null, pendingBuildConfirmation: null, constructionQueue: [] });
            this.background = new ParallaxBackground(this.worldWidth, this.worldHeight);
            this.waveManager = new WaveManager(this);
            if (isReload) return;
            document.getElementById('game-over').style.display='none';
            const core = new Core(this.worldWidth/2, this.worldHeight/2); this.buildings.push(core);
            const numPatches = 50, safeZone = 300;
            for(let i=0; i<numPatches; i++){ let x, y, d; do { x = Math.random() * this.worldWidth; y = Math.random() * this.worldHeight; d = distance(x, y, core.x, core.y); } while (d < safeZone); this.asteroidFields.push(new AsteroidField(x, y, 20 + Math.random()*15, 2000+Math.random()*3000)); }
            this.updatePowerGrid();
            this.updateSelectionPanel();
        }

        update(dt, timestamp){
            if(this.isGameOver || !dt) return;
            if(BUILDING_SPECS.Core.passiveIncome){ this.minerals += BUILDING_SPECS.Core.passiveIncome * dt/1000; }
            this.updateShields(dt);
            this.dispatchConstructionDrones(); this.waveManager.update(dt);
            [...this.buildings, ...this.units, ...this.enemies].forEach(e => e.update(this, dt));
            this.projectiles.forEach(p => p.update(dt));
            this.buildings = this.buildings.filter(b=>b.health>0); this.units = this.units.filter(u=>u.health>0);
            this.enemies = this.enemies.filter(e=>(e.health > 0 || e.shieldHealth > 0));
            this.projectiles = this.projectiles.filter(p=>!p.shouldBeRemoved);
            this.asteroidFields = this.asteroidFields.filter(w=>w.minerals>0);
            this.updatePowerGrid();
            if(this.selectedBuilding && this.selectedBuilding.health <= 0) this.setSelectedBuilding(null);
            if(!this.buildings.some(b => ['Core', 'Starbase'].includes(b.type))) this.gameOver();
            this.updateUI();
            if (timestamp - this.lastSaveTime > this.saveInterval) { this.saveGameToSession(); this.lastSaveTime = timestamp; }
        }
        updateShields(dt) {
            const allEntities = [...this.buildings, ...this.units];
            allEntities.forEach(e => e.maxShieldHealth = 0);
            const shieldGens = this.buildings.filter(b => b.type === 'ShieldGenerator' && b.isPowered && !b.isConstructing);
            for (const gen of shieldGens) { for (const entity of allEntities) { if (distance(gen.x, gen.y, entity.x, entity.y) < gen.specs.range) { entity.maxShieldHealth = Math.max(entity.maxShieldHealth, gen.specs.shieldAmount); } } }
            allEntities.forEach(e => {
                if (e.maxShieldHealth === 0) { e.shieldHealth = 0; return; }
                if (e.shieldHealth > e.maxShieldHealth) { e.shieldHealth = e.maxShieldHealth; }
                if (e.shieldRegenTimer > 0) { e.shieldRegenTimer -= dt; }
                else if (e.shieldHealth < e.maxShieldHealth) {
                    const gen = shieldGens.find(g => distance(g.x, g.y, e.x, e.y) < g.specs.range);
                    if (gen) { e.shieldHealth += gen.specs.shieldRegenRate * (dt / 1000); if (e.shieldHealth > e.maxShieldHealth) e.shieldHealth = e.maxShieldHealth; }
                }
            });
        }
        dispatchConstructionDrones() { const idleDrones = this.units.filter(u => u.type === 'ConstructionDrone' && !u.targetBuilding); if (idleDrones.length === 0) return; const jobs = this.constructionQueue.filter(b => b.health > 0 && (!b.assignedDrone || b.assignedDrone.health <= 0)); if(jobs.length === 0) return; for (const job of jobs) { const drone = idleDrones.pop(); if (drone) { job.assignedDrone = drone; drone.targetBuilding = job; } else { break; } } }
        
        draw(){
            this.background.draw(ctx, this.camera, gameCanvas);
            ctx.save(); ctx.translate(this.width/2, this.height/2); ctx.scale(this.camera.zoom, this.camera.zoom); ctx.translate(-this.camera.x, -this.camera.y);
            // CORREGIDO: Error tipográfico en el nombre de la función.
            if (this.buildingToPlace) { this.drawBuildPlacementAids(); } 
            this.drawPowerNetwork();
            this.asteroidFields.forEach(p=>p.draw(ctx)); this.buildings.forEach(b=>b.draw(ctx)); this.units.forEach(u=>u.draw(ctx));
            this.enemies.forEach(e=>e.draw(ctx)); this.projectiles.forEach(p=>p.draw(ctx));
            this.buildings.forEach(b => {
                if(b.type === 'Core' || b.type === 'Starbase') {
                    ctx.save();
                    const textY = b.y - b.size - 20;
                    const powerText = `${b.gridConsumption || 0} / ${b.gridProduction || 0}`;
                    const color = (b.gridConsumption > b.gridProduction) ? UI_COLORS.danger : UI_COLORS.primary;
                    ctx.fillStyle = color;
                    ctx.font = `${14 / this.camera.zoom}px 'Consolas', 'Menlo', 'Monaco', monospace`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.shadowColor = color;
                    ctx.shadowBlur = 10;
                    ctx.fillText(powerText, b.x, textY);
                    ctx.restore();
                }
            });
            if(this.selectedBuilding){
                ctx.beginPath(); ctx.strokeStyle = UI_COLORS.primary; ctx.lineWidth=2/this.camera.zoom; ctx.shadowColor = UI_COLORS.primary; ctx.shadowBlur=15;
                ctx.arc(this.selectedBuilding.x,this.selectedBuilding.y,this.selectedBuilding.size+5,0,2*Math.PI); ctx.stroke();
                const specs = this.selectedBuilding.specs; const radius = specs.connectionRange || specs.range;
                if (radius > 0 && !this.selectedBuilding.isConstructing) { ctx.beginPath(); ctx.strokeStyle = 'rgba(137, 221, 255, 0.4)'; ctx.lineWidth = 1 / this.camera.zoom; ctx.arc(this.selectedBuilding.x, this.selectedBuilding.y, radius, 0, 2*Math.PI); ctx.stroke(); }
                ctx.shadowBlur=0;
            }
            if(this.buildingToPlace) this.drawBuildGhost();
            ctx.restore();
        }

        updatePowerGrid() {
            this.buildings.forEach(b => {
                b.isPowered = false;
                if (b.type === 'Core' || b.type === 'Starbase') { b.gridProduction = 0; b.gridConsumption = 0; }
            });
            const gridStarters = this.buildings.filter(b => (b.type === 'Core' || b.type === 'Starbase') && !b.isConstructing);
            const allProviders = this.buildings.filter(b => b.specs.connectionRange > 0 && !b.isConstructing);
            const visitedInAnyGrid = new Set();
            for (const startNode of gridStarters) {
                if (visitedInAnyGrid.has(startNode)) continue;
                const localNetworkNodes = new Set();
                const queue = [startNode];
                const localVisited = new Set(queue);
                visitedInAnyGrid.add(startNode);
                while (queue.length > 0) {
                    const current = queue.shift();
                    localNetworkNodes.add(current);
                    for (const otherProvider of allProviders) {
                        if (!localVisited.has(otherProvider)) {
                            const d = distance(current.x, current.y, otherProvider.x, otherProvider.y);
                            if (d < current.specs.connectionRange && d < otherProvider.specs.connectionRange) {
                                localVisited.add(otherProvider); visitedInAnyGrid.add(otherProvider); queue.push(otherProvider);
                            }
                        }
                    }
                }
                let localProduction = 0; let localDemand = 0; const localConsumers = new Set();
                localNetworkNodes.forEach(node => { if (node.specs.power > 0) localProduction += node.specs.power; });
                this.buildings.forEach(b => {
                    if (b.specs.power < 0 && !b.isConstructing) {
                        for (const provider of localNetworkNodes) {
                            if (distance(b.x, b.y, provider.x, provider.y) < provider.specs.connectionRange) { localConsumers.add(b); break; }
                        }
                    }
                });
                localConsumers.forEach(c => { localDemand -= c.specs.power });
                startNode.gridProduction = localProduction; startNode.gridConsumption = localDemand;
                if (localProduction >= localDemand) {
                    localNetworkNodes.forEach(node => node.isPowered = true);
                    localConsumers.forEach(node => node.isPowered = true);
                }
            }
        }
        
        drawPowerNetwork() {
            ctx.save(); ctx.lineWidth = 2.5 / this.camera.zoom; ctx.shadowBlur = 10; ctx.globalAlpha = 0.7;
            const providers = this.buildings.filter(b => b.specs.connectionRange > 0 && !b.isConstructing);
            const consumers = this.buildings.filter(b => b.specs.power < 0 && !b.isConstructing);
            for (let i = 0; i < providers.length; i++) {
                for (let j = i + 1; j < providers.length; j++) {
                    const p1 = providers[i]; const p2 = providers[j]; const d = distance(p1.x, p1.y, p2.x, p2.y);
                    if (d < p1.specs.connectionRange && d < p2.specs.connectionRange) {
                        const lineColor = (p1.isPowered && p2.isPowered) ? UI_COLORS.primary : '#FFFFFF';
                        ctx.strokeStyle = lineColor; ctx.shadowColor = lineColor; ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
                    }
                }
            }
            consumers.forEach(consumer => {
                let closestProvider = null; let minDist = Infinity;
                providers.forEach(provider => { const d = distance(consumer.x, consumer.y, provider.x, provider.y); if (d < provider.specs.connectionRange && d < minDist) { minDist = d; closestProvider = provider; } });
                if (closestProvider) {
                    const lineColor = consumer.isPowered ? UI_COLORS.primary : '#FFFFFF';
                    ctx.strokeStyle = lineColor; ctx.shadowColor = lineColor; ctx.beginPath(); ctx.moveTo(consumer.x, consumer.y); ctx.lineTo(closestProvider.x, closestProvider.y); ctx.stroke();
                }
            });
            ctx.restore();
        }

        drawBuildPlacementAids() { ctx.save(); ctx.globalAlpha = 0.15; this.buildings.forEach(b => { if (b.isPowered && b.specs.connectionRange > 0) { ctx.fillStyle = b.specs.color; ctx.beginPath(); ctx.arc(b.x, b.y, b.specs.connectionRange, 0, 2 * Math.PI); ctx.fill(); } }); ctx.restore(); }
        
        drawBuildGhost() {
            const target = this.pendingBuildConfirmation || this.mouse;
            const worldX = target.x !== undefined ? target.x : target.worldX;
            const worldY = target.y !== undefined ? target.y : target.worldY;
            const isValid = this.isValidPlacement(worldX, worldY, this.buildingToPlace.type);
            const ghostColor = isValid ? UI_COLORS.success : UI_COLORS.danger;
            const specs = this.buildingToPlace.specs;
            ctx.save();
            const radius = specs.range || specs.connectionRange;
            if (radius > 0) { ctx.beginPath(); ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)'; ctx.lineWidth = 1 / this.camera.zoom; ctx.setLineDash([5 / this.camera.zoom, 5 / this.camera.zoom]); ctx.arc(worldX, worldY, radius, 0, 2 * Math.PI); ctx.stroke(); ctx.setLineDash([]); }
            ctx.globalAlpha = 0.6; ctx.fillStyle = ghostColor; ctx.strokeStyle = ghostColor; ctx.lineWidth = 2; ctx.shadowColor = ghostColor; ctx.shadowBlur = 15;
            drawBuildingPath(ctx, this.buildingToPlace.type, specs.size, worldX, worldY);
            ctx.fill(); ctx.stroke();
            ctx.restore();
        }

        screenToWorld(x, y) { const rect = gameCanvas.getBoundingClientRect(); return { x: (x - rect.left - this.width / 2) / this.camera.zoom + this.camera.x, y: (y - rect.top - this.height / 2) / this.camera.zoom + this.camera.y }; }
        worldToScreen(x, y) { return { x: (x - this.camera.x) * this.camera.zoom + this.width / 2, y: (y - this.camera.y) * this.camera.zoom + this.height / 2 }; }
        setupInputHandlers() {
            gameCanvas.addEventListener("pointerdown", e => this.handlePointerDown(e)); gameCanvas.addEventListener("pointermove", e => this.handlePointerMove(e));
            gameCanvas.addEventListener("pointerup", e => this.handlePointerUp(e)); gameCanvas.addEventListener("pointercancel", e => this.handlePointerUp(e));
            gameCanvas.addEventListener("wheel", e => { e.preventDefault(); this.handleWheel(e); });
            document.addEventListener("keydown", e => { if (e.key === "Escape") this.cancelAllActions(); });
            document.querySelectorAll(".ui-panel, #build-confirm-dialog").forEach(el => { el.addEventListener("pointerdown", e => e.stopPropagation()); });
            document.querySelectorAll(".build-btn[data-type]").forEach(btn => {
                btn.addEventListener("click", () => { const type = btn.dataset.type; this.setBuildingToPlace({ type: type, specs: BUILDING_SPECS[type] }); });
                btn.addEventListener("mouseenter", e => this.showTooltip(e, btn.dataset.type));
                btn.addEventListener("mouseleave", () => this.hideTooltip());
            });
            document.getElementById("menuBtn").addEventListener("click", () => this.togglePause());
            document.getElementById("fullscreenBtn").addEventListener("click", () => this.toggleFullscreen());
            document.getElementById("destroy-btn").addEventListener("click", () => {
                if(!this.selectedBuilding) return; const b = this.selectedBuilding; const refund = b.isConstructing ? b.baseSpecs.cost : 0.5 * b.baseSpecs.cost; this.minerals += refund;
                if(b.isConstructing) { this.constructionQueue = this.constructionQueue.filter(j => j !== b); if(b.assignedDrone) b.assignedDrone.targetBuilding = null; }
                if(b.drones) { b.drones.forEach(d => d.health = 0); }
                if(b.fighters) { b.fighters.forEach(f => f.health = 0); }
                b.health = 0; this.setSelectedBuilding(null);
            });
            document.getElementById("confirm-build-btn").addEventListener("click", () => this.confirmBuild());
            document.getElementById("cancel-build-btn").addEventListener("click", () => this.cancelBuild());
        }
        handlePointerDown(e) { e.preventDefault(); if (this.isPaused) return; this.mouse.down = true; this.mouse.lastDownTime = Date.now(); this.pointers.push(e); this.mouse.startX = e.clientX; this.mouse.startY = e.clientY; this.mouse.lastMoveX = e.clientX; this.mouse.lastMoveY = e.clientY; }
        handlePointerMove(e) { e.preventDefault(); if (this.isPaused) return; const pIndex = this.pointers.findIndex(p => p.pointerId === e.pointerId); if (pIndex >= 0) this.pointers[pIndex] = e; const world = this.screenToWorld(e.clientX, e.clientY); this.mouse.worldX = world.x; this.mouse.worldY = world.y; if (this.pendingBuildConfirmation) this.showConfirmationDialog(); if (this.pointers.length === 1 && this.mouse.down) { const dx = e.clientX - this.mouse.lastMoveX; const dy = e.clientY - this.mouse.lastMoveY; this.camera.x -= dx / this.camera.zoom; this.camera.y -= dy / this.camera.zoom; this.mouse.lastMoveX = e.clientX; this.mouse.lastMoveY = e.clientY; } else if (this.pointers.length === 2) { const p1 = this.pointers[0]; const p2 = this.pointers[1]; const pinchDist = distance(p1.clientX, p1.clientY, p2.clientX, p2.clientY); if (this.initialPinchDistance != null) this.zoomAtPoint((p1.clientX + p2.clientX) / 2, (p1.clientY + p2.clientY) / 2, pinchDist / this.initialPinchDistance); this.initialPinchDistance = pinchDist; } }
        handlePointerUp(e) { e.preventDefault(); if (this.isPaused) return; const dist = distance(this.mouse.startX, this.mouse.startY, e.clientX, e.clientY); if (this.mouse.down && Date.now() - this.mouse.lastDownTime < 250 && dist < 10) this.handleClick(); this.mouse.down = false; const pIndex = this.pointers.findIndex(p => p.pointerId === e.pointerId); if (pIndex >= 0) this.pointers.splice(pIndex, 1); if (this.pointers.length < 2) this.initialPinchDistance = null; }
        handleWheel(e) { if (this.isPaused) return; this.zoomAtPoint(e.clientX, e.clientY, 1 - 0.001 * e.deltaY); }
        zoomAtPoint(x, y, factor) { const worldPos1 = this.screenToWorld(x, y); this.camera.zoom = Math.max(0.2, Math.min(2.5, this.camera.zoom * factor)); const worldPos2 = this.screenToWorld(x, y); this.camera.x += worldPos1.x - worldPos2.x; this.camera.y += worldPos1.y - worldPos2.y; }
        
        handleClick() { 
            if (this.pendingBuildConfirmation) { this.cancelBuild(); return; } 
            if (this.buildingToPlace) { this.tryPlaceBuilding(); } 
            else { 
                const clicked = this.buildings.find(e => distance(this.mouse.worldX, this.mouse.worldY, e.x, e.y) < e.size + 3);
                if (clicked?.type === 'Barracks' && this.selectedBuilding === clicked) { clicked.rallyPoint = { x: this.mouse.worldX, y: this.mouse.worldY }; } 
                this.setSelectedBuilding(clicked || null); 
            } 
        }

        cancelAllActions() { this.setBuildingToPlace(null); this.setSelectedBuilding(null); this.hideConfirmationDialog(); }
        setBuildingToPlace(b) { if (this.buildingToPlace?.type === b?.type) { this.buildingToPlace = null; } else { this.buildingToPlace = b; this.setSelectedBuilding(null); } document.querySelectorAll(".build-btn.selected").forEach(btn => btn.classList.remove("selected")); if (this.buildingToPlace) { document.querySelector(`.build-btn[data-type="${b.type}"]`)?.classList.add("selected"); } }
        setSelectedBuilding(b) { this.selectedBuilding = b; if (b) { this.setBuildingToPlace(null); } this.updateSelectionPanel(); }
        tryPlaceBuilding() { if (this.buildingToPlace) { const { worldX, worldY } = this.mouse; if (this.isValidPlacement(worldX, worldY, this.buildingToPlace.type)) { this.pendingBuildConfirmation = { type: this.buildingToPlace.type, x: worldX, y: worldY }; this.showConfirmationDialog(); } } }
        
        isValidPlacement(x, y, type) {
            const specs = BUILDING_SPECS[type];
            if (this.minerals < specs.cost) return false;
            for (const b of this.buildings) { if (distance(x, y, b.x, b.y) < specs.size + b.size + 5) return false; }
            if (type === 'Starbase') return true;
            let isInRange = false;
            for (const b of this.buildings) { if (b.isPowered && b.specs.connectionRange > 0 && distance(x, y, b.x, b.y) < b.specs.connectionRange) { isInRange = true; break; } }
            return isInRange;
        }

        showConfirmationDialog() { if (this.pendingBuildConfirmation) { const dialog = document.getElementById("build-confirm-dialog"); const screenPos = this.worldToScreen(this.pendingBuildConfirmation.x, this.pendingBuildConfirmation.y); dialog.style.left = `${screenPos.x + 20}px`; dialog.style.top = `${screenPos.y - 20}px`; dialog.style.display = "flex"; } }
        hideConfirmationDialog() { document.getElementById("build-confirm-dialog").style.display = "none"; this.pendingBuildConfirmation = null; }
        confirmBuild() { if (this.pendingBuildConfirmation) { const { type, x, y } = this.pendingBuildConfirmation; this.minerals -= BUILDING_SPECS[type].cost; const BuildingClass = AllClasses[type]; if (BuildingClass) { const newBuilding = new BuildingClass(x, y); this.buildings.push(newBuilding); this.constructionQueue.push(newBuilding); } this.setBuildingToPlace(null); this.hideConfirmationDialog(); } }
        cancelBuild() { this.hideConfirmationDialog(); }
        showTooltip(e, type) {
            const tooltip = document.getElementById("tooltip"); const specs = BUILDING_SPECS[type]; if (!specs) return;
            tooltip.innerHTML = `<h4>${specs.name}</h4><p>${specs.description}</p><p>Coste: ${specs.cost} | Energía: ${specs.power||0}</p>`; tooltip.style.display = 'block';
            const rect = e.target.getBoundingClientRect(); const tooltipRect = tooltip.getBoundingClientRect();
            let top = rect.top; let left = rect.left - tooltipRect.width - 10;
            if (left < 0) { left = rect.right + 10; } if (top + tooltipRect.height > window.innerHeight) { top = window.innerHeight - tooltipRect.height - 10; }
            tooltip.style.left = `${left}px`; tooltip.style.top = `${top}px`;
        }
        hideTooltip() { document.getElementById("tooltip").style.display = "none"; }
        toggleFullscreen() { if (!document.fullscreenElement) { document.documentElement.requestFullscreen().catch(err => { alert(`Error al activar pantalla completa: ${err.message} (${err.name})`); }); } else { if (document.exitFullscreen) { document.exitFullscreen(); } } }
        
        togglePause() {
            this.isPaused = !this.isPaused;
            if (this.isPaused) {
                splashScreen.style.display = 'flex';
                splashScreen.style.opacity = '1'; // CORREGIDO: Asegura que el menú sea visible
                splashScreen.classList.add('paused');
                playButton.style.display = 'none';
                epicDescription.style.display = 'none';
                credits.style.display = 'none';
                resumeButton.style.display = 'flex';
            } else {
                splashScreen.style.opacity = '0';
                splashScreen.addEventListener('transitionend', () => {
                    if (!this.isPaused) splashScreen.style.display = 'none';
                }, { once: true });
            }
        }

        updateUI() { 
            document.getElementById("minerals").textContent = `Minerales: ${Math.floor(this.minerals)}`; 
            const waveEl = document.getElementById("wave-timer"); 
            if (this.waveManager.waveInProgress) { 
                waveEl.innerHTML = `> OLEADA HOSTIL <span style="color:var(--color-danger)">${this.waveManager.waveNumber}</span> | Hostiles: ${this.enemies.length}`; 
            } else { 
                waveEl.textContent = `Siguiente oleada en: ${Math.ceil(this.waveManager.timeToNextWave / 1000)}s`; 
            } 
        }
        updateSelectionPanel() {
            const panel = document.getElementById("selection-panel");
            const upgradeContainer = document.getElementById("upgrade-buttons-container");
            const shieldStatusEl = document.getElementById("selection-shield");
            upgradeContainer.innerHTML = ''; shieldStatusEl.style.display = 'none';
            if (this.selectedBuilding) {
                const b = this.selectedBuilding;
                document.getElementById('selection-icon').innerHTML = ''; document.getElementById('selection-icon').appendChild(createIconCanvas(b.type, 40, 40));
                document.getElementById("selection-type").textContent = `${b.baseSpecs.name}`;
                document.getElementById("selection-health").textContent = `Integridad: ${Math.ceil(b.health)} / ${b.maxHealth}`;
                if (b.maxShieldHealth > 0 || b.type === "ShieldGenerator") { shieldStatusEl.textContent = `Escudo: ${Math.ceil(b.shieldHealth)} / ${Math.ceil(b.maxShieldHealth)}`; shieldStatusEl.style.display = 'block'; }
                let statusText = "";
                if (b.isConstructing) { statusText = 'Estado: <span style="color:var(--color-warning)">En construcción</span>'; }
                else if (b.specs.power < 0) { statusText = b.isPowered ? 'Estado: <span style="color:var(--color-success)">En línea</span>' : 'Estado: <span style="color:var(--color-danger)">Sin energía</span>'; } 
                else if (b.specs.power > 0) { statusText = `Estado: <span style="color:#89ddff">Generando ${b.specs.power}</span>`; }
                else { statusText = 'Estado: <span style="color:white">Operativo</span>'; }
                document.getElementById("selection-status").innerHTML = statusText;
                if (b.baseSpecs.upgrades && !b.isConstructing) {
                    b.baseSpecs.upgrades.forEach(upgType => {
                        const level = b.upgradeLevels[upgType];
                        const btn = document.createElement('button'); btn.classList.add('build-btn', 'upgrade-btn');
                        if (level >= MAX_UPGRADE_LEVEL) { btn.innerHTML = `${UPGRADE_NAMES[upgType] || upgType}<br>(MAX)`; btn.disabled = true; } 
                        else { 
                            const cost = b.getUpgradeCost(upgType); btn.innerHTML = `${UPGRADE_NAMES[upgType]} (${level})<br>${cost}M`; 
                            btn.disabled = this.minerals < cost; 
                            btn.onclick = (e) => { e.stopPropagation(); b.performUpgrade(upgType); this.updateSelectionPanel(); }; 
                        }
                        upgradeContainer.appendChild(btn);
                    });
                }
                document.getElementById("destroy-btn").style.display = (b.type !== 'Core') ? 'block' : 'none';
                panel.style.display = "block";
            } else { panel.style.display = "none"; }
        }
        gameOver(){ if(!this.isGameOver){ this.isGameOver = true; sessionStorage.removeItem('sots_gamestate'); document.getElementById("game-over").style.display="flex"; } }

        saveGameToSession() {
            if (this.isGameOver) { sessionStorage.removeItem('sots_gamestate'); return; }
            const getEntityData = (entity) => {
                const data = { type: entity.type, x: entity.x, y: entity.y, health: entity.health, shieldHealth: entity.shieldHealth, upgradeLevels: entity.upgradeLevels, };
                if (entity.isConstructing !== undefined) data.isConstructing = entity.isConstructing;
                if (entity.rallyPoint) data.rallyPoint = entity.rallyPoint;
                return data;
            };
            const gameState = {
                minerals: this.minerals, camera: this.camera, waveManager: { waveNumber: this.waveManager.waveNumber, timeToNextWave: this.waveManager.timeToNextWave, waveInProgress: this.waveManager.waveInProgress, },
                buildings: this.buildings.map(getEntityData), enemies: this.enemies.map(getEntityData), asteroidFields: this.asteroidFields.map(a => ({ x: a.x, y: a.y, minerals: a.minerals, size: a.size, initialMinerals: a.initialMinerals })),
            };
            sessionStorage.setItem('sots_gamestate', JSON.stringify(gameState));
        }

        loadGameFromSession() {
            const savedStateJSON = sessionStorage.getItem('sots_gamestate');
            if (!savedStateJSON) return false;
            try {
                const savedState = JSON.parse(savedStateJSON);
                this.init(true);
                this.minerals = savedState.minerals; this.camera = savedState.camera;
                this.waveManager.waveNumber = savedState.waveManager.waveNumber; this.waveManager.timeToNextWave = savedState.waveManager.timeToNextWave; this.waveManager.waveInProgress = savedState.waveManager.waveInProgress;
                savedState.buildings.forEach(bData => {
                    const BuildingClass = AllClasses[bData.type];
                    if (BuildingClass) {
                        const newBuilding = new BuildingClass(bData.x, bData.y);
                        newBuilding.health = bData.health; newBuilding.shieldHealth = bData.shieldHealth || 0; newBuilding.isConstructing = bData.isConstructing; newBuilding.upgradeLevels = bData.upgradeLevels;
                        if (bData.rallyPoint) newBuilding.rallyPoint = bData.rallyPoint;
                        newBuilding.applyLevelStats();
                        if (newBuilding.isConstructing) { this.constructionQueue.push(newBuilding); }
                        this.buildings.push(newBuilding);
                    }
                });
                savedState.enemies.forEach(eData => {
                    const EnemyClass = AllClasses[eData.type];
                    if(EnemyClass) {
                        const enemy = new EnemyClass(eData.x, eData.y);
                        enemy.applyWaveBonus(this.waveManager.waveNumber);
                        enemy.health = eData.health; enemy.shieldHealth = eData.shieldHealth || 0;
                        this.enemies.push(enemy);
                    }
                });
                savedState.asteroidFields.forEach(aData => {
                    const field = new AsteroidField(aData.x, aData.y, aData.size, aData.initialMinerals);
                    field.minerals = aData.minerals; this.asteroidFields.push(field);
                });
                this.updatePowerGrid(); this.updateUI(); this.updateSelectionPanel();
                console.log("Game state successfully loaded from session.");
                return true;
            } catch (e) {
                console.error("Failed to load game from session storage:", e);
                sessionStorage.removeItem('sots_gamestate');
                return false;
            }
        }
    }

    let game; 
    let lastTime = 0;

    function gameLoop(timestamp){ 
        if (!game) { requestAnimationFrame(gameLoop); return; }
        if (!lastTime) lastTime = timestamp;
        if (game.isPaused) {
            game.draw();
            lastTime = timestamp;
            requestAnimationFrame(gameLoop);
            return;
        }
        const deltaTime = timestamp - lastTime; 
        lastTime = timestamp; 
        if (!game.isGameOver) { 
            game.update(deltaTime, timestamp); 
            game.draw(); 
        } 
        requestAnimationFrame(gameLoop); 
    }
    
    function initAndStartGame() {
        splashScreen.style.opacity = '0';
        splashScreen.addEventListener('transitionend', () => splashScreen.style.display = 'none', { once: true });
        gameCanvas.style.display = 'block';
        uiContainer.style.display = 'block';

        game = new Game(gameCanvas.width, gameCanvas.height); 
        
        if (!game.loadGameFromSession()) {
             console.log("No session data found, starting a new game.");
             game.init(); 
        }
        
        populateUiIcons(); 
        game.setupInputHandlers();
        
        requestAnimationFrame(gameLoop); 
    }

    AssetManager.loadAssets(() => { 
        playButton.disabled = false;
        playButton.textContent = 'Jugar';
    });
    
    playButton.addEventListener('click', initAndStartGame);
    resumeButton.addEventListener('click', () => game.togglePause());
    window.addEventListener('resize',()=>{ if (!game) return; gameCanvas.width = window.innerWidth; gameCanvas.height = window.innerHeight; game.width = gameCanvas.width; game.height = gameCanvas.height; });
    
});
</script>
</body>
</html>