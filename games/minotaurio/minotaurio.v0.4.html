<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minotaurio - Laberinto Subterráneo</title>
    <style>
        /* General Body and Game View Styles */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            touch-action: none;
            font-family: 'Palatino Linotype', 'Book Antiqua', 'Palatino', serif; /* Fuente principal con aire griego */
            color: #e0e0e0; /* Default text color for consistency */
        }
        canvas { display: block; width: 100%; height: 100%; }

        /* Functional UI Styles (Joystick, Action Buttons, Minimap - less aesthetic changes) */
        #joystick-area { position: absolute; width: 120px; height: 120px; background: rgba(200, 200, 200, 0.15); border-radius: 50%; display: none; justify-content: center; align-items: center; z-index: 10; pointer-events: none; transform: translate(-50%, -50%); }
        #joystick-thumb { width: 50px; height: 50px; background: rgba(200, 200, 200, 0.4); border-radius: 50%; }
        #action-buttons { position: absolute; bottom: 30px; right: 20px; display: flex; flex-direction: column; gap: 15px; z-index: 10; }
        .action-button {
            width: 60px; height: 60px;
            background: rgba(180, 40, 40, 0.7); /* Deep red */
            border-radius: 50%; display: flex; justify-content: center; align-items: center; color: white; font-weight: bold; font-size: 12px; text-align: center; user-select: none; border: 2px solid rgba(255, 255, 255, 0.3); cursor: pointer;
        }
        #message { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); background-color: rgba(20, 20, 20, 0.8); color: white; padding: 10px 20px; border-radius: 5px; display: none; z-index: 20; font-family: inherit;} /* Inherit font */
        #minimapCanvas { position: absolute; top: 15px; right: 15px; width: 160px; height: 160px; border: 1px solid rgba(255, 255, 255, 0.4); background-color: rgba(10, 10, 10, 0.6); z-index: 15; image-rendering: pixelated; }
        #pointer-lock-info { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.7); color: white; padding: 20px; border-radius: 10px; font-size: 1.2em; text-align: center; display: none; z-index: 100; font-family: inherit;} /* Inherit font */

        /* --- Loading Screen Styles --- */
        #loading-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: #111;
            color: #e0e0e0; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; transition: opacity 0.5s ease-out; z-index: 1000;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
            font-family: 'Palatino Linotype', 'Book Antiqua', 'Palatino', serif;
        }
        #loading-screen h1 {
            font-size: 4.8em;
            margin-bottom: 0.05em;
            color: #ffc107;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.6);
            border-bottom: 4px double #ffc107;
            padding-bottom: 10px;
        }
        #loading-screen .credits {
            font-size: 1em;
            color: #b0b0b0;
            margin-top: 0.5em;
            margin-bottom: 1em;
        }
        #loading-screen .credits a {
            color: #ffc107;
            text-decoration: none;
            font-weight: bold;
        }
        #loading-screen .credits a:hover {
            text-decoration: underline;
            color: #ffda6b;
        }
        #loading-screen p {
            font-size: 1.1em;
            color: #ccc;
            margin-bottom: 15px;
            max-width: 700px;
            line-height: 1.5;
        }
        #loading-screen .version {
            font-size: 0.9em;
            margin-top: 5px;
            margin-bottom: 20px;
            color: #aaa;
        }
        #loading-screen .legend-text {
             font-style: italic;
             color: #bbb;
             margin-bottom: 25px;
        }

        #loading-screen .loading-text {
            font-size: 1.5em;
            color: #ccc;
            margin-top: 20px;
        }
        #start-options {
             margin-top: 30px;
             display: flex;
             flex-direction: column;
             gap: 15px;
        }
        .menu-button {
            background-color: #ffc107;
            color: #1a1a1a;
            border: none;
            padding: 15px 30px;
            font-size: 1.2em;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.3s ease, transform 0.1s ease;
            min-width: 300px;
            text-transform: uppercase;
             letter-spacing: 1px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        .menu-button:hover {
            background-color: #ffda6b;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.4);
        }
         .menu-button:active {
             transform: translateY(0);
             box-shadow: 0 2px 3px rgba(0, 0, 0, 0.3);
         }
         .menu-button:disabled {
             background-color: #555;
             color: #999;
             cursor: not-allowed;
             box-shadow: none;
             transform: none;
         }


        /* --- Custom Game Screen Styles --- */
        #custom-game-screen, #scenario-editor-screen, #next-scenario-selection-screen {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: #151515;
            color: #e0e0e0; flex-direction: column; align-items: center; padding-top: 50px; z-index: 900; overflow-y: auto;
            box-sizing: border-box;
        }
        #custom-game-screen h2, #scenario-editor-screen h2, #next-scenario-selection-screen h2 {
            color: #ffc107;
            margin-bottom: 25px;
            border-bottom: 2px solid #ffc107;
            padding-bottom: 5px;
             font-size: 2em;
        }
        #custom-scenario-list-container, #next-scenario-list-container { width: 90%; max-width: 700px; margin-bottom: 20px; }
        #no-custom-scenarios, #no-next-scenarios { text-align: center; display: none; color: #aaa; }
        #custom-scenario-list, #next-scenario-list { list-style: none; padding: 0; width: 100%;}
        .scenario-item {
            background-color: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.15);
            padding: 12px 20px;
            margin-bottom: 10px;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
             flex-wrap: nowrap;
             gap: 15px;
        }
        .scenario-preview {
            width: 60px;
            height: 60px;
            display: grid;
            border: 1px solid #555;
            background-color: #222;
            flex-shrink: 0;
            image-rendering: pixelated;
        }
        .scenario-preview-cell {
            box-sizing: border-box;
        }
        .scenario-info {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        .scenario-info span {
            font-size: 1.1em;
        }

        .scenario-actions {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
        }
        .scenario-actions .action-btn {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 6px 10px;
            font-size: 0.85em;
            cursor: pointer;
            border-radius: 3px;
            transition: background-color 0.2s ease;
            min-width: auto;
             text-transform: none;
             letter-spacing: normal;
             box-shadow: none;
             height: auto;
             display: inline-flex;
             align-items: center;
             justify-content: center;
        }
        .scenario-actions .action-btn:hover { background-color: #0056b3; transform: none; box-shadow: none;}
        .scenario-actions .delete-scenario-btn { background-color: #dc3545; }
        .scenario-actions .delete-scenario-btn:hover { background-color: #c82333; }
        .menu-button.small-padding { padding: 8px 15px; font-size: 0.9em; min-width: auto; }


        /* --- Scenario Editor Styles --- */
        #scenario-editor-screen { background-color: #151515; z-index: 950; padding-top: 20px;}
        #editor-controls { margin-bottom: 15px; display: flex; flex-direction: column; align-items: center; gap: 10px; width: 90%; max-width: 700px;}
        #dimension-selector { display:none; margin-bottom:10px; align-items: center; gap: 10px; flex-wrap: wrap; justify-content: center; }
        #dimension-selector label { font-size: 1.1em;}
        #scenario-size-select {
            padding: 8px;
            border-radius: 3px;
             background-color: #333;
             color: white;
             border: 1px solid #555;
             font-family: inherit;
             font-size: 1em;
        }
        #confirm-size-btn { margin-left: 0; margin-top: 5px; }
        #brush-tools { margin-bottom:10px; display:none; flex-wrap: wrap; justify-content: center;}
        #brush-tools span { font-size: 1.1em; margin-right: 10px; margin-bottom: 5px; flex-shrink: 0;}
        .brush-btn {
            padding: 8px 12px; margin: 0 5px; border: 1px solid #ccc; background-color: #555; color:white; cursor:pointer; border-radius: 3px;
            transition: background-color 0.2s ease, border-color 0.2s ease;
            font-family: inherit;
            font-size: 0.9em;
            margin-bottom: 5px;
        }
        .brush-btn.active {
            background-color: #ffc107;
            color:#1a1a1a;
            border-color: #ffc107;
        }
        #scenario-name-input {
            padding: 10px; margin-bottom:10px; display:none; width: 80%; max-width: 300px; border-radius: 3px; border: 1px solid #555; background-color: #333; color: white;
             font-family: inherit;
             font-size: 1.1em;
        }
        #editor-grid-container {
            display: grid; border: 1px solid #444; margin-bottom: 15px;
            background-color: #222;
        }
        .grid-cell {
            width: 25px; height: 25px;
            background-color: #403a30;
             border: 1px solid #2a2a2a; box-sizing: border-box; cursor: pointer; display: flex; justify-content: center; align-items: center; font-size: 12px; font-weight: bold;
             color: rgba(255,255,255,0.8);
        }
        .grid-cell.path {
            background-color: #605548;
        }
        .grid-cell.start { background-color: #4CAF50; color: white; }
        .grid-cell.end { background-color: #F44336; color: white; }
        .grid-cell.pittrap { background-color: #8B4513; color: white; }
        .grid-cell.fallingblock { background-color: #708090; color: white; } 
        .grid-cell.spikes { background-color: #A9A9A9; color: black; }
        .grid-cell.minotaur { background-color: #800000; color: #ffdddd; } 
        .grid-cell.lava { background-color: #ff6600; color: #ffeecc; } 
        .grid-cell.border { cursor: not-allowed; background-color: #111 !important; color: #444 !important;}
        #editor-actions { display: flex; gap: 10px; margin-bottom: 15px; display:none; flex-wrap: wrap; justify-content: center;}
        #editor-message { color: #ffc107; margin-left:10px; align-self: center; font-size: 1em; margin-top: 5px; text-align: center;}

        #texture-selectors {
            border: 1px solid #444;
            padding: 10px;
            border-radius: 5px;
            background-color: rgba(255,255,255,0.05);
            text-align: left;
        }
        #texture-selectors h4 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #ffc107;
            text-align: center;
        }
        .texture-selector-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        #texture-selectors label {
            display: inline-block;
            width: 60px;
            text-align: right;
            margin-right: 10px;
            flex-shrink: 0;
        }
        #texture-selectors select {
            padding: 5px;
            background-color: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 3px;
            min-width: 150px;
            margin-right: 10px;
        }
        .texture-preview-img {
            width: 40px;
            height: 40px;
            border: 1px solid #777;
            background-color: #222;
            object-fit: cover;
        }
         #end-cell-options {
            border: 1px solid #444;
            padding: 10px;
            border-radius: 5px;
            background-color: rgba(255,255,255,0.05);
            margin-top: 10px;
            width: 90%;
            max-width: 400px;
        }
        #end-cell-options h4 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #ffc107;
            text-align: center;
        }
        #end-cell-options label {
            display: block;
            margin-bottom: 8px;
            cursor: pointer;
        }
        #end-cell-options input[type="radio"] {
            margin-right: 8px;
        }
        #specific-next-scenario-select {
            padding: 5px;
            background-color: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 3px;
            min-width: 200px;
            margin-left: 5px;
            display: inline-block;
            vertical-align: middle;
        }


        #back-to-main-menu-btn {
            background-color: #6c757d;
            color: white;
        }
         #back-to-main-menu-btn:hover {
            background-color: #5a6268;
         }
        #back-to-custom-screen-btn {
            background-color: #6c757d;
            color: white;
        }
         #back-to-custom-screen-btn:hover {
            background-color: #5a6268;
         }
    </style>
</head>
<body>
    <div id="loading-screen">
        <h1>Minotaurio</h1>
        <p class="credits">
            por <a href="https://www.linkedin.com/in/oriol-badia" target="_blank" rel="noopener noreferrer">Oriol Badia Campanera</a>
        </p>
        <p class="version">Versión <span id="game-version"></span></p>

        <p class="legend-text">
            En el corazón de la antigua Creta, reinaba el Rey Minos, pero la oscuridad acechaba.
            Nacido de una unión impía, el Minotauro, una bestia de hombre y toro, exigía sacrificio.
            Encerrado en un vasto e ineludible Laberinto diseñado por el ingenioso Dédalo,
            se alimentaba de la juventud de Atenas. Cada año, jóvenes valientes y doncellas
            eran enviados a las retorcidas profundidades, nunca para regresar, perdidos
            ante la bestia o el laberinto mismo. El miedo se apoderó de la tierra,
            pues ¿quién podría navegar la oscuridad? ¿Quién podría enfrentar el rugiente terror en su centro?
        </p>

        <div id="start-options">
            <button id="start-auto-game" class="menu-button">Iniciar Juego (Laberinto Aleatorio)</button>
            <button id="start-custom-game" class="menu-button">Juego Personalizado</button>
        </div>
        <p class="loading-text" id="loading-text-element" style="display: none;">Cargando texturas y laberinto...</p>
    </div>

    <div id="custom-game-screen">
        <h2>Juego Personalizado</h2>
        <div id="custom-scenario-list-container">
            <p id="no-custom-scenarios">No tienes escenarios guardados.</p>
            <ul id="custom-scenario-list"></ul>
        </div>
        <div id="custom-game-actions" style="display: flex; flex-wrap: wrap; justify-content: center; gap: 15px; margin-bottom: 20px;">
            <button id="create-new-scenario-btn" class="menu-button">Crear Nuevo Escenario</button>
            <button id="import-scenario-btn" class="menu-button">Importar Escenario</button>
            <input type="file" id="import-file-input" accept=".json" style="display: none;">
        </div>
        <button id="back-to-main-menu-btn" class="menu-button" style="background-color: #6c757d;">Volver al Menú Principal</button>
    </div>

    <div id="scenario-editor-screen">
        <h2>Editor de Escenarios</h2>
        <div id="editor-controls">
            <div id="dimension-selector">
                <label for="scenario-size-select">Tamaño del Laberinto:</label>
                <select id="scenario-size-select">
                    <option value="7x7">Pequeño (7x7)</option>
                    <option value="12x12" selected>Mediano (12x12)</option>
                    <option value="17x17">Grande (17x17)</option>
                </select>
                <button id="confirm-size-btn" class="menu-button small-padding">Confirmar Tamaño</button>
            </div>
            <input type="text" id="scenario-name-input" placeholder="Nombre del Escenario">
            <div id="brush-tools">
                <span>Herramienta: </span>
                <button class="brush-btn active" data-type="wall">Pared</button>
                <button class="brush-btn" data-type="path">Camino</button>
                <button class="brush-btn" data-type="start">Inicio</button>
                <button class="brush-btn" data-type="end">Fin</button>
                <button class="brush-btn" data-type="pittrap">Trampa Foso</button>
                <button class="brush-btn" data-type="fallingblock">Bloque Cae</button>
                <button class="brush-btn" data-type="spikes">Pinchos</button>
                <button class="brush-btn" data-type="minotaur">Minotauro</button> 
                <button class="brush-btn" data-type="lava">Lava</button> 
            </div>
             <div id="texture-selectors" style="display:none; margin-top: 15px;">
                <h4>Selección de Texturas:</h4>
                <div class="texture-selector-row">
                    <label for="wall-texture-select">Pared:</label>
                    <select id="wall-texture-select"></select>
                    <img id="wall-texture-preview" class="texture-preview-img" alt="Pared Preview">
                </div>
                <div class="texture-selector-row">
                    <label for="floor-texture-select">Suelo:</label>
                    <select id="floor-texture-select"></select>
                    <img id="floor-texture-preview" class="texture-preview-img" alt="Suelo Preview">
                </div>
                <div class="texture-selector-row">
                    <label for="ceiling-texture-select">Techo:</label>
                    <select id="ceiling-texture-select"></select>
                    <img id="ceiling-texture-preview" class="texture-preview-img" alt="Techo Preview">
                </div>
            </div>
            <div id="end-cell-options" style="display:none; margin-top: 10px; padding: 10px; border: 1px solid #555; background-color: rgba(255,255,255,0.05);">
                <h4>Comportamiento de Casilla Final:</h4>
                <label><input type="radio" name="end-behavior" value="terminate" checked> Terminar Partida</label>
                <label><input type="radio" name="end-behavior" value="specific_next_scenario"> Cargar Escenario Específico:</label>
                <select id="specific-next-scenario-select" style="display:none; margin-left: 5px;"></select>
            </div>
        </div>
        <div id="editor-grid-container"></div>
        <div id="editor-actions">
            <button id="save-scenario-btn" class="menu-button small-padding">Guardar</button>
            <button id="play-edited-scenario-btn" class="menu-button small-padding" disabled>Jugar</button>
            <span id="editor-message"></span>
        </div>
        <button id="back-to-custom-screen-btn" class="menu-button" style="background-color: #6c757d;">Volver a Escenarios</button>
    </div>


    <div id="pointer-lock-info">Haz clic para controlar la cámara con el ratón. Presiona ESC para liberar.</div>
    <div id="container"></div>
    <div id="joystick-area"><div id="joystick-thumb"></div></div>
    <div id="action-buttons">
        <div id="jump-button" class="action-button">SALTAR</div>
        <div id="action-button" class="action-button">VISTA</div>
    </div>
    <div id="message"></div>
    <canvas id="minimapCanvas"></canvas>

    <div id="next-scenario-selection-screen" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #151515; z-index: 2001; flex-direction: column; align-items: center; padding-top: 50px; overflow-y: auto; box-sizing: border-box;">
        <h2 style="color: #ffc107;">Elige el Siguiente Laberinto</h2>
        <div id="next-scenario-list-container" style="width: 90%; max-width: 700px; margin-bottom: 20px;">
            <p id="no-next-scenarios" style="text-align: center; color: #aaa;">No hay otros escenarios guardados.</p>
            <ul id="next-scenario-list" style="list-style: none; padding: 0; width: 100%;"></ul>
        </div>
        <button id="cancel-next-scenario" class="menu-button" style="background-color: #6c757d; margin-top:20px;">Cancelar y Volver al Menú</button>
    </div>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>


    <script>
        // --- Constantes y Configuración ---
        const GAME_VERSION = "v1.12.7-minotaur_scale_debug_logs"; 
        const MAX_RESOLUTION_DIMENSION = 1920;
        const MAX_RESOLUTION_DIMENSION_MOBILE = 1280;
        const DEFAULT_MAZE_WIDTH = 12;
        const DEFAULT_MAZE_HEIGHT = 12;
        const CELL_SIZE = 4; const WALL_HEIGHT = 7;
        const PLAYER_HEIGHT = 2.4; 
        const PLAYER_RADIUS = 0.4; 
		const PLAYER_SPEED = 4.5; 
		const SPRINT_SPEED = 8.0; 
		const SPRINT_THRESHOLD = 0.9; 
		const JUMP_VELOCITY = 10.5; 
		const GRAVITY = -18.0; 
		const CAMERA_DISTANCE = 6; 
		const CAMERA_HEIGHT_OFFSET = 2.5; 
		const PUSH_DISTANCE = 0.8; 
		const JOYSTICK_VISUAL_RADIUS = 60; 
		const JOYSTICK_EFFECTIVE_RADIUS = 50; 
		const JOYSTICK_DEADZONE = 0.1; 
        const CAMERA_SENSITIVITY = 0.002; 
        const CAMERA_SENSITIVITY_MOBILE_MULTIPLIER = 2.0; 
        const OBSTACLE_OPACITY = 0.20; 
		
       
        const TORCH_COLOR = 0xffa545; 
        const SPEAR_LIGHT_INTENSITY = 5.0; 
        const SPEAR_LIGHT_DISTANCE = 30; 
        const SPEAR_LIGHT_DECAY = 15;
        const SPEAR_FLAME_SIZE = 0.15; 

        const TORCH_STATIC_INTENSITY = 10.0; 
		const TORCH_STATIC_DISTANCE = 20; 
		const TORCH_STATIC_DECAY = 8;
        const STATIC_TORCH_FREQUENCY = 0.45;
		
		
		
        const TORCH_FLICKER_AMOUNT = 0.25; const TORCH_WALL_OFFSET = 0.25; 
        const FLAME_BASE_OPACITY = 0.8; 
        const FLAME_OPACITY_VAR = 0.3; 
        const FLAME_BASE_SCALE_Y = 0.4; 
        const FLAME_SCALE_Y_VAR = 0.15; 
        const MIN_CAMERA_Y_ABOVE_GROUND = 0.5;
        const MINIMAP_SIZE = 160; const MINIMAP_RADIUS_CELLS = 5; const MINIMAP_CELL_SIZE_PX = Math.floor(MINIMAP_SIZE / (MINIMAP_RADIUS_CELLS * 2 + 1)); const MINIMAP_PLAYER_COLOR = '#ff4444'; const MINIMAP_WALL_COLOR = '#505050'; const MINIMAP_PATH_COLOR = '#888888'; const MINIMAP_END_COLOR = '#F44336';
        const MINIMAP_END_LINK_COLOR = '#FF9800';
        const MINIMAP_PITTRAP_INTACT_COLOR = '#D2691E'; 
        const MINIMAP_PITTRAP_BROKEN_COLOR = '#111111';
        const MINIMAP_FALLING_BLOCK_COLOR = '#6A5ACD'; 
        const MINIMAP_SPIKES_COLOR = '#CD5C5C';
        const MINIMAP_MINOTAUR_COLOR = '#FF0000';
        const MINIMAP_LAVA_COLOR = '#ff6600'; 

        const PLAYER_VISION_RADIUS_CELLS = 4; const MINIMAP_UNSEEN_COLOR = '#181818';
        const FIRST_PERSON_EYE_HEIGHT_FACTOR = 0.85;
        const CAMERA_PITCH_OFFSET_FPS = Math.PI / 2;
        
        const PIT_TRAP_CELL_TYPE = 7;
        const BROKEN_PIT_TRAP_CELL_TYPE_LAYOUT = 8;
        const FALLING_BLOCK_TRAP_CELL_TYPE = 9;
        const SPIKE_TRAP_CELL_TYPE = 10;
        const MINOTAUR_CELL_TYPE = 11; 
        const LAVA_CELL_TYPE = 12; 
        const END_CELL_TERMINATE = 6;
        const END_CELL_SPECIFIC_NEXT = 61;


        const PIT_TRAP_TRIGGER_RADIUS_SQUARED = (CELL_SIZE * 0.30) * (CELL_SIZE * 0.30);
        const PIT_TRAP_BREAK_ANIMATION_TIME = 600;
        const PIT_FALL_DEPTH = -WALL_HEIGHT * 1.5;
        const PIT_HOLE_MATERIAL = new THREE.MeshStandardMaterial({ color: 0x101010, roughness: 0.9 });
        const PIT_COVER_THICKNESS = 0.05;
        const PLAYER_STEP_HEIGHT = 0.25;
        const FALLING_BLOCK_MATERIAL = new THREE.MeshStandardMaterial({ color: 0x605548, roughness: 0.9, metalness: 0.1 }); 
        const SPIKE_MATERIAL = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.8, roughness: 0.3 });
        const SPIKE_RISE_TIME = 200;
        const SPIKE_HEIGHT = PLAYER_HEIGHT * 0.8;
        const LAVA_SURFACE_OFFSET_Y = -0.15; 
        const LAVA_LIGHT_COLOR = 0xff4500;
        const LAVA_LIGHT_INTENSITY = 1.5;
        const LAVA_LIGHT_DISTANCE = CELL_SIZE * 1.5;
        const LAVA_FLOW_SPEED_U = 0.0007;
        const LAVA_FLOW_SPEED_V = 0.0005;


        // --- Minotaur Constants --- 
        const MINOTAUR_TARGET_HEIGHT = PLAYER_HEIGHT * 1.1; // MODIFIED FOR TESTING - Make it same height as player
        const MINOTAUR_COLLISION_HEIGHT = PLAYER_HEIGHT * 1.6; 
        const MINOTAUR_COLLISION_RADIUS = PLAYER_RADIUS * 1.6; 
        
        const MINOTAUR_PATROL_SPEED = PLAYER_SPEED * 0.6;
        const MINOTAUR_CHASE_SPEED = PLAYER_SPEED * 0.8;
        const MINOTAUR_TURN_SPEED = Math.PI * 1.5; 
        const MINOTAUR_VISION_RANGE_SQ = (CELL_SIZE * 5) * (CELL_SIZE * 5);
        const MINOTAUR_VISION_ANGLE_DOT = Math.cos( (Math.PI / 2.5) / 2 ); 
        const MINOTAUR_LOSE_SIGHT_TIME = 5000; // ms
        const MINOTAUR_ATTACK_RANGE_BUFFER = 0.2; 
        const MINOTAUR_ATTACK_RANGE_SQUARED = (MINOTAUR_COLLISION_RADIUS + PLAYER_RADIUS + MINOTAUR_ATTACK_RANGE_BUFFER) * (MINOTAUR_COLLISION_RADIUS + PLAYER_RADIUS + MINOTAUR_ATTACK_RANGE_BUFFER); 
        const MINOTAUR_PATROL_TURN_CHANCE = 0.1;
        const MINOTAUR_PATROL_NEW_TARGET_INTERVAL = 5000; // ms
        const MINOTAUR_TORCH_COLOR = 0xff8c00; 
		
        const MINOTAUR_TORCH_LIGHT_INTENSITY = 15.0;
        const MINOTAUR_TORCH_LIGHT_DISTANCE = 50;
        const MINOTAUR_TORCH_LIGHT_DECAY = 35.0;
        const MINOTAUR_TORCH_FLAME_SIZE = 0.35;
        const MINOTAUR_TORCH_OFFSET = new THREE.Vector3(MINOTAUR_COLLISION_RADIUS * 0.8, MINOTAUR_COLLISION_HEIGHT * 0.7, MINOTAUR_COLLISION_RADIUS * 0.4); 

        // --- Smoke Particle Constants --- 
        const MAX_SMOKE_PARTICLES = 0; 
        const SMOKE_SPAWN_INTERVAL = 0.02; 
        const SMOKE_PARTICLE_MIN_LIFE = 1.5; 
        const SMOKE_PARTICLE_MAX_LIFE = 2.5; 
        const SMOKE_PARTICLE_START_SIZE = 0.1;
        const SMOKE_PARTICLE_END_SIZE = 1.0; 
        const SMOKE_PARTICLE_START_OPACITY = 0.90; 
        const SMOKE_PARTICLE_COLOR = 0x050505; 

        // --- TEXTURAS ---
        const textureBaseURL = 'https://urysoft.github.io/ai.html.games/general/assets/images/';
        const BLOOD_SPLATTER_TEXTURE_URL = textureBaseURL + 'blood1.png';
        const textureURLs = [];
        for (let i = 1; i <= 26; i++) {
            textureURLs.push(`${textureBaseURL}textura${i}.jpeg`);
        }
        textureURLs.push(`${textureBaseURL}textura_lava1.jpg`); 
        const textureLoader = new THREE.TextureLoader();
        let loadedTextures = [];
        let floorTexture, wallTexture, ceilingTexture, crackedTexture, lavaTexture, bloodSplatterTexture; 
        let bloodSplatters = [];

        let scene, camera, renderer, player, clock;
        let maze = [];
        let currentMazeLayout = [];
        let initialPlayerPosition = new THREE.Vector3();
        let currentPlayingScenarioData = null;

        let currentMazeWidth, currentMazeHeight;
        let collidableObjects = []; let interactiveObjects = []; let playerVelocity = new THREE.Vector3(); let playerOnGround = false; let moveForward = 0, moveRight = 0; let cameraPhi = Math.PI / 3; let cameraTheta = 0; 
        let endZones = []; 
        let gameActive = true;
        const joystickArea = document.getElementById('joystick-area'); const joystickThumb = document.getElementById('joystick-thumb'); const jumpButton = document.getElementById('jump-button'); const actionButton = document.getElementById('action-button'); const messageDiv = document.getElementById('message'); const containerDiv = document.getElementById('container');
        let joystickPointerId = -1; let cameraPointerId = -1; let joystickStartPos = { x: 0, y: 0 }; let joystickCurrentPos = { x: 0, y: 0 }; let cameraTouchStartPos = { x: 0, y: 0 };
        let currentlyTransparentObjects = new Set(); 
        let staticTorches = [];
        let lavaCells = []; 
        
        let spearLight = null; 
        let spearFlameMesh = null; 
        let spearLightAndFlameGroup = null; 

        let minimapCanvas = null; let minimapCtx = null; let minimapWidth = MINIMAP_SIZE; let minimapHeight = MINIMAP_SIZE;
        let visibilityMaze = [];
        const loadingScreenElement = document.getElementById('loading-screen');
        const gameVersionSpan = document.getElementById('game-version');
        const pointerLockInfoDiv = document.getElementById('pointer-lock-info');
        let isFirstPersonView = false;
        let keyStates = {}; let isPointerLocked = false;
        let isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        const lightWorldPosHelper = new THREE.Vector3(); 
        const collisionCheckTempBox = new THREE.Box3();
        const playerCollisionBox = new THREE.Box3(); 
        const minotaurCollisionBox = new THREE.Box3(); 

        let pitTrapObjects = [];
        let fallingBlockTrapObjects = [];
        let spikeTrapObjects = [];
        let playerFallingIntoPit = null;

        // --- Minotaur Variables ---
        let minotaurEnemy = null; 
        let minotaurModelGLB = null; 
        let minotaurInitialGridPos = null;
        let minotaurState = 'patrolling';
        let minotaurTargetCell = null;
        let minotaurLastSawPlayerTime = 0;
        let minotaurPatrolNextTargetTime = 0;
        const minotaurRaycaster = new THREE.Raycaster();
        const minotaurToPlayerVec = new THREE.Vector3();
        const minotaurForwardVec = new THREE.Vector3();
        let minotaurTorch = null; 
        let minotaurCollisionCylinder = null; 

        // --- Player Model & Animation ---
        let playerModel = null; 
        let playerAnimations = [];
        let playerMixer = null;
        let idleAction = null, walkAction = null, runAction = null;
        let currentAction = null;

        // --- Smoke Particle Variables --- 
        let smokeParticles = [];
        let smokeParticleGeometry, smokeParticleMaterial;
        let timeSinceLastSmokeSpawn = 0;
        const smokeSpawnPosition = new THREE.Vector3(); 

        const startAutoGameButton = document.getElementById('start-auto-game');
        const startCustomGameButton = document.getElementById('start-custom-game');
        const loadingTextElement = document.getElementById('loading-text-element');
        const startOptionsDiv = document.getElementById('start-options');
        const customGameScreen = document.getElementById('custom-game-screen');
        const scenarioEditorScreen = document.getElementById('scenario-editor-screen');
        const customScenarioListUL = document.getElementById('custom-scenario-list');
        const noCustomScenariosMsg = document.getElementById('no-custom-scenarios');
        const createNewScenarioBtn = document.getElementById('create-new-scenario-btn');
        const importScenarioBtn = document.getElementById('import-scenario-btn');
        const importFileInput = document.getElementById('import-file-input');
        const backToMainMenuBtn = document.getElementById('back-to-main-menu-btn');
        const backToCustomScreenBtn = document.getElementById('back-to-custom-screen-btn');
        const dimensionSelectorDiv = document.getElementById('dimension-selector');
        const scenarioSizeSelect = document.getElementById('scenario-size-select');
        const confirmSizeBtn = document.getElementById('confirm-size-btn');
        const brushToolsDiv = document.getElementById('brush-tools');
        const scenarioNameInput = document.getElementById('scenario-name-input');
        const editorGridContainer = document.getElementById('editor-grid-container');
        const editorActionsDiv = document.getElementById('editor-actions');
        const saveScenarioBtn = document.getElementById('save-scenario-btn');
        const playEditedScenarioBtn = document.getElementById('play-edited-scenario-btn');
        const editorMessageSpan = document.getElementById('editor-message');
        const textureSelectorsDiv = document.getElementById('texture-selectors');
        const endCellOptionsDiv = document.getElementById('end-cell-options');
        const specificNextScenarioSelect = document.getElementById('specific-next-scenario-select');

        const nextScenarioSelectionScreen = document.getElementById('next-scenario-selection-screen');
        const nextScenarioListUL = document.getElementById('next-scenario-list');
        const noNextScenariosMsg = document.getElementById('no-next-scenarios');
        const cancelNextScenarioBtn = document.getElementById('cancel-next-scenario');


        let currentEditingScenario = null;
        let editorGridData = [];
        let selectedBrush = 'wall';
        let hasUnsavedChanges = false;
        let editorCellElements = [];


        const DB_NAME = "MinotaurioCustomScenariosDB";
        const DB_VERSION = 1;
        const STORE_NAME = "scenarios";
        let db;

        function initDB() {
            return new Promise((resolve, reject) => {
                if (!window.indexedDB) {
                    console.warn("IndexedDB no soportado por este navegador. Juego Personalizado no funcionará.");
                    alert("Tu navegador no soporta IndexedDB, necesario para guardar escenarios personalizados.");
                    reject("IndexedDB not supported");
                    return;
                }
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onupgradeneeded = (event) => {
                    const dbInstance = event.target.result;
                    if (!dbInstance.objectStoreNames.contains(STORE_NAME)) {
                        const store = dbInstance.createObjectStore(STORE_NAME, { keyPath: "id", autoIncrement: true });
                        store.createIndex("name", "name", { unique: false });
                    }
                    console.log("IndexedDB: Actualización/creación de base de datos completada.");
                };
                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log("IndexedDB: Conexión exitosa.");
                    resolve(db);
                };
                request.onerror = (event) => {
                    console.error("IndexedDB: Error al abrir la base de datos", event.target.error);
                    reject(event.target.error);
                };
            });
        }
        function saveScenarioDB(scenarioData) {
            return new Promise((resolve, reject) => {
                if (!db) { reject("DB no inicializada"); return; }
                const transaction = db.transaction([STORE_NAME], "readwrite");
                const store = transaction.objectStore(STORE_NAME);
                let request;
                let dataToStore;
                if (scenarioData.id !== null && scenarioData.id !== undefined) {
                     dataToStore = { ...scenarioData };
                     request = store.put(dataToStore);
                } else {
                     const { id, ...dataWithoutId } = scenarioData;
                     dataToStore = dataWithoutId;
                     request = store.add(dataToStore);
                }
                request.onsuccess = (event) => {
                    const resultId = event.target.result;
                    console.log("Escenario guardado/actualizado en DB:", scenarioData.name, "ID asignado/actualizado:", resultId);
                    scenarioData.id = resultId;
                    resolve(scenarioData);
                };
                request.onerror = (event) => {
                    console.error("Error al guardar escenario en DB:", event.target.error);
                    if (event.target.error.name === 'ConstraintError') {
                        alert("Error de restricción al guardar el escenario. Puede que ya exista un escenario con un nombre o identificador similar (si hay reglas de unicidad). Revisa la consola.");
                    } else if (event.target.error.name === 'DataError') {
                         alert("Error de datos al guardar el escenario. Revisa el formato o los valores. Revisa la consola.");
                    }
                    reject(event.target.error);
                };
            });
        }
        function getAllScenariosDB() {
            return new Promise((resolve, reject) => {
                if (!db) { resolve([]); return; }
                const transaction = db.transaction([STORE_NAME], "readonly");
                const store = transaction.objectStore(STORE_NAME);
                const request = store.getAll();
                request.onsuccess = () => { resolve(request.result); };
                request.onerror = (event) => {
                    console.error("Error al obtener todos los escenarios:", event.target.error);
                    reject(event.target.error);
                };
            });
        }
        function getScenarioByIdDB(id) {
            return new Promise((resolve, reject) => {
                if (!db) { reject("DB no inicializada"); return; }
                const transaction = db.transaction([STORE_NAME], "readonly");
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get(id);
                request.onsuccess = () => { resolve(request.result);};
                request.onerror = (event) => {
                    console.error("Error al obtener escenario por ID:", id, event.target.error);
                    reject(event.target.error);
                };
            });
        }
        function deleteScenarioDB(id) {
            return new Promise((resolve, reject) => {
                if (!db) { reject("DB no inicializada"); return; }
                const transaction = db.transaction([STORE_NAME], "readwrite");
                const store = transaction.objectStore(STORE_NAME);
                const request = store.delete(id);
                request.onsuccess = () => {
                    console.log("Escenario eliminado de DB, ID:", id);
                    resolve();
                };
                request.onerror = (event) => {
                    console.error("Error al eliminar escenario de DB:", event.target.error);
                    reject(event.target.error);
                };
            });
        }

        function preloadAssets(callback) {
            let texturesToLoadCount = textureURLs.length;
            let playerModelAssetLoaded = false;
            let minotaurModelAssetLoaded = false; 
            let texturesLoaded = false;
            let bloodTextureLoaded = false; 
            playerAnimations = []; 

            const checkCompletion = () => {
                if (texturesLoaded && playerModelAssetLoaded && minotaurModelAssetLoaded && bloodTextureLoaded) {
                    console.log("All assets (textures, models, blood) preloaded.");
                    callback();
                }
            };

            if (textureURLs.length === 0) {
                console.log("No textures to load.");
                selectRandomTextures(); 
                texturesLoaded = true;
            } else {
                textureURLs.forEach((url, index) => {
                    textureLoader.load(url,
                        (texture) => {
                            texture.wrapS = THREE.RepeatWrapping;
                            texture.wrapT = THREE.RepeatWrapping;
                            loadedTextures[index] = texture;
                            if (url.includes("textura_lava1.jpg")) { 
                                lavaTexture = texture;
                                lavaTexture.wrapS = lavaTexture.wrapT = THREE.RepeatWrapping; 
                            }
                            texturesToLoadCount--;
                            if (texturesToLoadCount === 0) {
                                console.log("All primary textures loaded successfully.");
                                texturesLoaded = true;
                                checkCompletion();
                            }
                        },
                        undefined,
                        (error) => {
                            console.error('Error al cargar textura:', url, error);
                            loadedTextures[index] = null; 
                            texturesToLoadCount--;
                            if (texturesToLoadCount === 0) {
                                console.warn("Algunas texturas no pudieron cargarse. Continuando con las disponibles...");
                                texturesLoaded = true;
                                checkCompletion();
                            }
                        }
                    );
                });
            }
             if (textureURLs.length === 0) { 
                texturesLoaded = true;
            }

            textureLoader.load(BLOOD_SPLATTER_TEXTURE_URL,
                (texture) => {
                    bloodSplatterTexture = texture;
                    bloodTextureLoaded = true;
                    console.log("Blood splatter texture loaded.");
                    checkCompletion();
                },
                undefined,
                (error) => {
                    console.error('Error loading blood splatter texture:', BLOOD_SPLATTER_TEXTURE_URL, error);
                    bloodSplatterTexture = null;
                    bloodTextureLoaded = true; 
                    checkCompletion();
                }
            );

            const playerModelURL = 'https://urysoft.github.io/ai.html.games/general/assets/modelos/greek_warrior.glb';
            const minotaurModelURL = 'https://urysoft.github.io/ai.html.games/general/assets/modelos/greek_warrior.glb';
            const gltfLoader = new THREE.GLTFLoader();

            gltfLoader.load(playerModelURL,
                (gltf) => {
                    playerModel = gltf.scene;
                    playerAnimations = gltf.animations; 
                    playerModel.traverse(function (node) {
                        if (node.isMesh) {
                            node.castShadow = true;
                        }
                    });
                    console.log("Player model loaded. Animations:", playerAnimations.length);
                    playerModelAssetLoaded = true;
                    checkCompletion();
                },
                undefined, 
                (error) => {
                    console.error('Error loading player model:', playerModelURL, error);
                    playerModel = null; 
                    playerModelAssetLoaded = true; 
                    checkCompletion();
                }
            );

            gltfLoader.load(minotaurModelURL,
                (gltf) => {
                    minotaurModelGLB = gltf.scene;
                    console.log("Minotaur model (monster1.glb) raw loaded.");
                    minotaurModelGLB.traverse(function (node) {
                        if (node.isMesh) {
                            node.castShadow = true; 
                            node.receiveShadow = true; 
                        }
                    });
                    minotaurModelAssetLoaded = true;
                    checkCompletion();
                },
                undefined,
                (error) => {
                    console.error('Error loading Minotaur model (monster1.glb):', minotaurModelURL, error);
                    console.error('Full error object:', error); 
                    minotaurModelGLB = null;
                    minotaurModelAssetLoaded = true;
                    checkCompletion();
                }
            );
        }


        function selectRandomTextures() {
            if (loadedTextures.length === 0) { console.warn("No hay texturas cargadas para seleccionar. Se usarán colores sólidos."); floorTexture = null; wallTexture = null; ceilingTexture = null; crackedTexture = null; return; }
            const validTextures = loadedTextures.filter(t => t && !t.image.src.includes("textura_lava1.jpg")); 
            if (validTextures.length === 0) { console.warn("Todas las texturas cargadas son inválidas (o solo hay lava)."); floorTexture = null; wallTexture = null; ceilingTexture = null; crackedTexture = null; return; }

            let floorIdx = Math.floor(Math.random() * validTextures.length);
            floorTexture = validTextures[floorIdx].clone();

            let wallIdx;
            if (validTextures.length > 1) {
                do { wallIdx = Math.floor(Math.random() * validTextures.length); } while (wallIdx === floorIdx);
                wallTexture = validTextures[wallIdx].clone();
            } else {
                wallTexture = validTextures[0].clone();
            }

            let ceilingIdx;
             if (validTextures.length > 2) {
                do { ceilingIdx = Math.floor(Math.random() * validTextures.length); } while (ceilingIdx === floorIdx || ceilingIdx === wallIdx);
                ceilingTexture = validTextures[ceilingIdx].clone();
            } else if (validTextures.length > 1) {
                 do { ceilingIdx = Math.floor(Math.random() * validTextures.length); } while (ceilingIdx === floorIdx && ceilingIdx === wallIdx); 
                 if (ceilingIdx === floorIdx && ceilingIdx === wallIdx && validTextures.length > 1) { 
                    ceilingTexture = validTextures.find(t => t !== validTextures[floorIdx]) || validTextures[0].clone(); 
                 } else {
                    ceilingTexture = validTextures[ceilingIdx].clone();
                 }
            }
             else {
                 ceilingTexture = validTextures[0].clone();
            }

            if (floorTexture) floorTexture.needsUpdate = true;
            if (wallTexture) wallTexture.needsUpdate = true;
            if (ceilingTexture) ceilingTexture.needsUpdate = true;

            crackedTexture = floorTexture.clone();
            if (crackedTexture) crackedTexture.needsUpdate = true;
            
            if (!lavaTexture) {
                const lavaTexEntry = loadedTextures.find(t => t && t.image.src.includes("textura_lava1.jpg"));
                if (lavaTexEntry) lavaTexture = lavaTexEntry.clone();
                else console.warn("Textura de lava no encontrada en loadedTextures.");
            }
            console.log("Texturas aleatorias seleccionadas.");
        }

        function selectTexturesForScenario(scenarioTextures) {
            if (loadedTextures.length === 0) { console.warn("No hay texturas cargadas."); selectRandomTextures(); return; }
            const validTextures = loadedTextures.filter(t => t && !t.image.src.includes("textura_lava1.jpg"));
            if (validTextures.length === 0) { console.warn("No hay texturas válidas cargadas (o solo lava)."); selectRandomTextures(); return; }

            const getTex = (index) => (index !== -1 && validTextures[index]) ? validTextures[index].clone() : validTextures[Math.floor(Math.random() * validTextures.length)].clone();

            wallTexture = getTex(scenarioTextures?.wall);
            floorTexture = getTex(scenarioTextures?.floor);
            ceilingTexture = getTex(scenarioTextures?.ceiling);

            if (scenarioTextures?.wall === -1 && scenarioTextures?.floor === -1 && wallTexture.image.src === floorTexture.image.src && validTextures.length > 1) {
                let newFloorIndex;
                do { newFloorIndex = Math.floor(Math.random() * validTextures.length); } while (validTextures[newFloorIndex].image.src === wallTexture.image.src);
                floorTexture = validTextures[newFloorIndex].clone();
            }
             if (scenarioTextures?.ceiling === -1) {
                if (validTextures.length > 2) {
                    let newCeilingIndex;
                    do { newCeilingIndex = Math.floor(Math.random() * validTextures.length); } while (validTextures[newCeilingIndex].image.src === wallTexture.image.src || validTextures[newCeilingIndex].image.src === floorTexture.image.src);
                    ceilingTexture = validTextures[newCeilingIndex].clone();
                } else if (validTextures.length === 2) {
                     ceilingTexture = validTextures.find(t => t.image.src !== wallTexture.image.src && t.image.src !== floorTexture.image.src) || wallTexture.clone();
                } else {
                    ceilingTexture = wallTexture.clone();
                }
            }


            if (floorTexture) floorTexture.needsUpdate = true;
            if (wallTexture) wallTexture.needsUpdate = true;
            if (ceilingTexture) ceilingTexture.needsUpdate = true;
            crackedTexture = floorTexture.clone();
            if (crackedTexture) crackedTexture.needsUpdate = true;

            if (!lavaTexture) { 
                const lavaTexEntry = loadedTextures.find(t => t && t.image.src.includes("textura_lava1.jpg"));
                if (lavaTexEntry) lavaTexture = lavaTexEntry.clone();
            }
            console.log("Texturas de escenario aplicadas.");
        }


        function init(customMazeData = null) {
            if (scene) {
                while(scene.children.length > 0){
                    const object = scene.children[0];
                    if(object.geometry) object.geometry.dispose();
                    if(object.material){
                        if(Array.isArray(object.material)){
                            object.material.forEach(material => material.dispose());
                        } else {
                            object.material.dispose();
                        }
                    }
                    if (object.traverse) { 
                        object.traverse(child => {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(m => m.dispose());
                                } else {
                                    child.material.dispose();
                                }
                            }
                        });
                    }
                    scene.remove(object);
                }
            }
            gameActive = false; 

            collidableObjects = [];
            interactiveObjects = [];
            staticTorches = [];
            lavaCells = []; 
            pitTrapObjects = [];
            fallingBlockTrapObjects = [];
            spikeTrapObjects = [];
            minotaurEnemy = null;
            minotaurCollisionCylinder = null; 
            minotaurInitialGridPos = null;
            minotaurState = 'patrolling';
            minotaurTargetCell = null;
            minotaurLastSawPlayerTime = 0;
            minotaurPatrolNextTargetTime = 0;
            playerFallingIntoPit = null;
            endZones = []; 
            minotaurTorch = null; 
            
            bloodSplatters.forEach(splatter => { 
                if (splatter.geometry) splatter.geometry.dispose();
                if (splatter.material) splatter.material.dispose();
            });
            bloodSplatters = [];

            smokeParticles.forEach(p => { 
                if (p.material) p.material.dispose();
            });
            smokeParticles = [];
            timeSinceLastSmokeSpawn = 0;

            playerMixer = null;
            idleAction = null; walkAction = null; runAction = null;
            currentAction = null;
            spearLight = null;
            spearFlameMesh = null;
            spearLightAndFlameGroup = null;


            scene = new THREE.Scene(); scene.background = new THREE.Color(0x050508); scene.fog = new THREE.Fog(0x050508, 10, 35);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            if (!renderer) {
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.shadowMap.enabled = true; renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 0.8;
                containerDiv.appendChild(renderer.domElement);

                if (isTouchDevice) {
                    if (!touchControlsSetupDone) setupTouchControls();
                } else {
                    if (!keyboardControlsSetupDone) setupKeyboardAndMouseControls();
                }
            }


            clock = new THREE.Clock();
            const ambientLight = new THREE.AmbientLight(0x404040, 0.15); scene.add(ambientLight);
            minimapCanvas = document.getElementById('minimapCanvas');
            minimapCanvas.width = minimapWidth; minimapCanvas.height = minimapHeight; minimapCtx = minimapCanvas.getContext('2d');
            if (!minimapCtx) { console.error("No se pudo obtener el contexto 2D del minimapa."); }

            if (customMazeData) {
                console.log("Iniciando con laberinto personalizado:", customMazeData.name);
                maze = JSON.parse(JSON.stringify(customMazeData.grid));
                currentMazeLayout = JSON.parse(JSON.stringify(maze));
                currentMazeWidth = customMazeData.width;
                currentMazeHeight = customMazeData.height;
                currentPlayingScenarioData = JSON.parse(JSON.stringify(customMazeData));
            } else {
                console.log("Iniciando con laberinto autogenerado.");
                currentMazeWidth = DEFAULT_MAZE_WIDTH;
                currentMazeHeight = DEFAULT_MAZE_HEIGHT;
                maze = generateMaze(currentMazeWidth, currentMazeHeight);
                currentMazeLayout = JSON.parse(JSON.stringify(maze));
                currentPlayingScenarioData = null;
            }

            visibilityMaze = [];
            for (let z = 0; z < currentMazeHeight; z++) {
                visibilityMaze[z] = [];
                for (let x = 0; x < currentMazeWidth; x++) {
                    visibilityMaze[z][x] = false;
                }
            }

            if (!smokeParticleGeometry) {
                smokeParticleGeometry = new THREE.SphereGeometry(SMOKE_PARTICLE_START_SIZE, 6, 4);
            }
            if (!smokeParticleMaterial) { 
                smokeParticleMaterial = new THREE.MeshBasicMaterial({
                    color: SMOKE_PARTICLE_COLOR,
                    transparent: true,
                    opacity: SMOKE_PARTICLE_START_OPACITY,
                    depthWrite: false,
                    blending: THREE.NormalBlending 
                });
            }


            buildMazeGeometry(currentMazeWidth, currentMazeHeight, currentMazeLayout);

            let modelInstance = null;
            if (playerModel) {
                modelInstance = playerModel.clone(); 

                const box = new THREE.Box3().setFromObject(modelInstance);
                const modelSize = new THREE.Vector3();
                box.getSize(modelSize);

                if (modelSize.y > 0) { 
                    const scaleFactor = PLAYER_HEIGHT / modelSize.y;
                    modelInstance.scale.set(scaleFactor, scaleFactor, scaleFactor);
                    modelInstance.position.y = 0; 
                } else {
                    console.warn("Player model has zero height. Scaling may be incorrect.");
                }

                player = new THREE.Group(); 
                player.add(modelInstance);  

                if (playerAnimations && playerAnimations.length > 0) {
                    playerMixer = new THREE.AnimationMixer(modelInstance);
                    const findAnim = (names) => {
                        for (const name of names) {
                            const clip = THREE.AnimationUtils.findByName(playerAnimations, name);
                            if (clip) return playerMixer.clipAction(clip);
                        }
                        return null;
                    };
                    idleAction = findAnim(['Idle', 'idle', 'Armature|Idle', 'CharacterArmature|Idle', 'metarig|Idle', 'Idle_Sword']);
                    walkAction = findAnim(['Walk', 'walk', 'Walking', 'walk_forward', 'Armature|Walk', 'CharacterArmature|Walk', 'metarig|Walk', 'WalkForward', 'Walk_Sword']);
                    runAction = findAnim(['Run', 'run', 'Running', 'run_forward', 'Armature|Run', 'CharacterArmature|Run', 'metarig|Run', 'RunForward', 'Run_Sword']);

                    if (!idleAction && playerAnimations.length > 0) {
                        console.warn("Could not find a specifically named 'Idle' animation. Using first available animation as idle:", playerAnimations[0].name);
                        idleAction = playerMixer.clipAction(playerAnimations[0]);
                    }
                    
                    if (idleAction) {
                        idleAction.play();
                        currentAction = idleAction; 
                    } else {
                        console.warn("No idle animation found or usable for player.");
                    }
                    if (!walkAction) console.warn("No walk animation found for player (tried common names).");
                    if (!runAction) console.warn("No run animation found for player (tried common names).");
                } else {
                     console.warn("Player model loaded, but no animations found in the GLB.");
                }

            } else {
                console.warn("Player model not loaded, falling back to cylinder.");
                const playerGeometry = new THREE.CylinderGeometry(PLAYER_RADIUS, PLAYER_RADIUS, PLAYER_HEIGHT, 16);
                const playerMaterial = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.6 });
                player = new THREE.Mesh(playerGeometry, playerMaterial); 
                player.castShadow = true; 
            }
            player.rotation.order = 'YXZ'; 


            const startPos = findCell(5, maze, currentMazeWidth, currentMazeHeight);
            if (startPos) {
                initialPlayerPosition.set(
                    (startPos.x - currentMazeWidth / 2 + 0.5) * CELL_SIZE,
                    PLAYER_HEIGHT / 2 + 0.01, 
                    (startPos.z - currentMazeHeight / 2 + 0.5) * CELL_SIZE
                );
            } else {
                console.warn("No se encontró celda de inicio (5) en el laberinto. Colocando en el centro del primer camino disponible o (0,0).");
                let fallbackStart = findCell(1, maze, currentMazeWidth, currentMazeHeight);
                if (!fallbackStart) fallbackStart = {x: Math.floor(currentMazeWidth/2), z: Math.floor(currentMazeHeight/2)};
                 if (!maze[fallbackStart.z] || maze[fallbackStart.z][fallbackStart.x] === 0) { 
                     fallbackStart = {x:1,z:1}; 
                }
                initialPlayerPosition.set(
                    (fallbackStart.x - currentMazeWidth / 2 + 0.5) * CELL_SIZE,
                    PLAYER_HEIGHT / 2 + 0.01,
                    (fallbackStart.z - currentMazeHeight / 2 + 0.5) * CELL_SIZE
                );
            }
            player.position.copy(initialPlayerPosition);
            playerVelocity.set(0,0,0);
            playerOnGround = true;
            scene.add(player);

            spearLightAndFlameGroup = new THREE.Group();
            spearLight = new THREE.PointLight(TORCH_COLOR, SPEAR_LIGHT_INTENSITY, SPEAR_LIGHT_DISTANCE, SPEAR_LIGHT_DECAY);
            spearLight.castShadow = true; 
            spearLight.shadow.mapSize.width = 256; 
            spearLight.shadow.mapSize.height = 256;
            spearLight.shadow.camera.near = 0.1;
            spearLight.shadow.camera.far = SPEAR_LIGHT_DISTANCE;
            spearLight.userData.baseIntensity = SPEAR_LIGHT_INTENSITY;
            spearLight.userData.originalDistance = SPEAR_LIGHT_DISTANCE; 
            spearLightAndFlameGroup.add(spearLight);

            const spearFlameMaterial = new THREE.MeshBasicMaterial({
                color: 0xffd080, 
                transparent: true,
                opacity: FLAME_BASE_OPACITY * 0.9, 
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const spearFlameGeometry = new THREE.ConeGeometry(SPEAR_FLAME_SIZE * 0.6, SPEAR_FLAME_SIZE * 2.2, 8);
            spearFlameGeometry.translate(0, SPEAR_FLAME_SIZE * 1.1, 0); 
            spearFlameMesh = new THREE.Mesh(spearFlameGeometry, spearFlameMaterial);
            spearLightAndFlameGroup.add(spearFlameMesh);

            if (modelInstance) { 
                let spearNode = null;
                modelInstance.traverse((node) => {
                    if (node.name.toLowerCase() === "spear" && (node.isObject3D || node.isBone)) { 
                        spearNode = node;
                    }
                });

                if (spearNode) {
                    console.log("Attaching spear light to Spear node:", spearNode.name);
                    spearNode.add(spearLightAndFlameGroup);
                    spearLightAndFlameGroup.position.set(0, 0.1, -1.5); 
                    spearLightAndFlameGroup.rotation.x = Math.PI / 18; 
                } else {
                    console.warn("Spear node not found. Attaching light to player's root. Adjust fallback position.");
                    modelInstance.add(spearLightAndFlameGroup); 
                    spearLightAndFlameGroup.position.set(PLAYER_RADIUS * -0.3, PLAYER_HEIGHT * 0.4, PLAYER_RADIUS * 0.8); 
                }
            } else { 
                player.add(spearLightAndFlameGroup); 
                spearLightAndFlameGroup.position.set(PLAYER_RADIUS * -0.3, PLAYER_HEIGHT * 0.4, PLAYER_RADIUS * 0.8); 
            }


            const ceilingSize = Math.max(currentMazeWidth, currentMazeHeight) * CELL_SIZE * 1.2;
            const ceilingGeometry = new THREE.PlaneGeometry(ceilingSize, ceilingSize);
            const ceilingMat = new THREE.MeshStandardMaterial({ color: 0x333333, side: THREE.DoubleSide, roughness: 0.9 });
            if (ceilingTexture) {
                ceilingMat.map = ceilingTexture.clone();
                ceilingMat.map.needsUpdate = true;
                ceilingMat.color.set(0xffffff);
                ceilingMat.map.repeat.set(ceilingSize / (CELL_SIZE * 2), ceilingSize / (CELL_SIZE * 2));
            }
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMat);
            ceiling.position.y = WALL_HEIGHT + 0.1; ceiling.rotation.x = Math.PI / 2; ceiling.receiveShadow = true; ceiling.userData = { isCeiling: true, originalOpacity: 1.0, isTransparentCapable: true }; scene.add(ceiling); collidableObjects.push(ceiling);

            updateRendererAndCameraSize();

            player.visible = !isFirstPersonView;
            if (spearLight) { 
                spearLight.intensity = isFirstPersonView ? SPEAR_LIGHT_INTENSITY * 0.3 : spearLight.userData.baseIntensity;
                spearLight.castShadow = !isFirstPersonView;
                spearLight.distance = isFirstPersonView ? spearLight.userData.originalDistance * 0.5 : spearLight.userData.originalDistance;
            }
            
            cameraPhi = Math.PI / 3;
            cameraTheta = 0;
            updateCamera(); 
            gameActive = true; 
            if (!animationFrameId) {
                 animate();
            }
        }

        function generateMaze(width, height) {
            let matrix = []; for (let y = 0; y < height; y++) { matrix[y] = []; for (let x = 0; x < width; x++) matrix[y][x] = 0; }
            let stack = [];
            let startX = 1; let startY = 1;
            matrix[startY][startX] = 1;
            stack.push({ x: startX, y: startY });
            function isValid(x, y, currentMatrix) { return y >= 0 && y < height && x >= 0 && x < width && currentMatrix[y][x] === 0; }
            while (stack.length > 0) {
                let current = stack[stack.length - 1];
                let neighbors = [];
                let potential = [ { x: current.x, y: current.y - 2, wallX: current.x, wallY: current.y - 1 }, { x: current.x, y: current.y + 2, wallX: current.x, wallY: current.y + 1 }, { x: current.x + 2, y: current.y, wallX: current.x + 1, wallY: current.y }, { x: current.x - 2, y: current.y, wallX: current.x - 1, wallY: current.y } ];
                potential.forEach(p => { if (isValid(p.x, p.y, matrix)) { neighbors.push(p); } });
                if (neighbors.length > 0) { let next = neighbors[Math.floor(Math.random() * neighbors.length)]; matrix[next.y][next.x] = 1; matrix[next.wallY][next.wallX] = 1; stack.push({ x: next.x, y: next.y });
                } else { stack.pop(); }
            }
            if (matrix[1] && matrix[1][1] !== undefined) matrix[1][1] = 5; 
            
            let endPlaced = false;
            let potentialEndPos = [];
            for (let y = 1; y < height - 1; y++) { for (let x = 1; x < width - 1; x++) { if (matrix[y][x] === 1) { if (Math.abs(x - startX) + Math.abs(y - startY) > (width + height) / 2.5) { potentialEndPos.push({ x, y }); } } } }
            if (potentialEndPos.length > 0) { 
                let endPos = potentialEndPos[Math.floor(Math.random() * potentialEndPos.length)]; 
                if(matrix[endPos.y] && matrix[endPos.y][endPos.x] !== undefined) matrix[endPos.y][endPos.x] = END_CELL_TERMINATE; 
                endPlaced = true; 
            }
            if (!endPlaced) { 
                const endY = height - 2; const endX = width - 2; 
                if (matrix[endY] && matrix[endY][endX] !== undefined) { 
                    if (matrix[endY][endX] === 0) { 
                        matrix[endY][endX] = END_CELL_TERMINATE; 
                        if (matrix[endY-1] && matrix[endY-1][endX] === 0) matrix[endY-1][endX] = 1; 
                        else if (matrix[endY][endX-1] === 0) matrix[endY][endX-1] = 1;
                    } else {
                         matrix[endY][endX] = END_CELL_TERMINATE; 
                    }
                } else { console.warn("Fallback para colocar el punto final falló.");}
            }
            return matrix;
        }
        function findCell(type, targetMaze, mazeW, mazeH) { for (let z = 0; z < mazeH; z++) { for (let x = 0; x < mazeW; x++) { if (targetMaze[z] && targetMaze[z][x] === type) return { x, z }; } } return null; }
        function findDeadEnds(targetMaze, mazeW, mazeH) { let deadEnds = []; for (let y = 1; y < mazeH - 1; y++) { for (let x = 1; x < mazeW - 1; x++) { if (targetMaze[y][x] !== 0) { let pathNeighbors = 0; if (targetMaze[y+1] && targetMaze[y+1][x] !== 0) pathNeighbors++; if (targetMaze[y-1] && targetMaze[y-1][x] !== 0) pathNeighbors++; if (targetMaze[y][x+1] !== 0) pathNeighbors++; if (targetMaze[y][x-1] !== 0) pathNeighbors++; if (pathNeighbors === 1) { deadEnds.push({ x, y }); } } } } return deadEnds; }
        function buildMazeGeometry(mazeW, mazeH, layout) {
            collidableObjects = [];
            interactiveObjects = [];
            staticTorches = [];
            lavaCells = []; 
            pitTrapObjects = [];
            fallingBlockTrapObjects = [];
            spikeTrapObjects = [];
            minotaurEnemy = null;
            minotaurCollisionCylinder = null; 
            minotaurInitialGridPos = null;
            endZones = []; 
            minotaurTorch = null; 

            const wallMaterialBase = new THREE.MeshStandardMaterial({
                map: wallTexture ? wallTexture.clone() : null,
                roughness: 0.9, metalness: 0.1,
                color: wallTexture ? 0xffffff : 0x605548
            });
            if (wallMaterialBase.map) wallMaterialBase.map.needsUpdate = true;


            const floorCellMaterialBase = new THREE.MeshStandardMaterial({ 
                map: floorTexture ? floorTexture.clone() : null,
                roughness: 0.95, metalness: 0.1, side: THREE.DoubleSide,
                color: floorTexture ? 0xffffff : 0x444038
            });
            if (floorCellMaterialBase.map) {
                floorCellMaterialBase.map.needsUpdate = true;
                floorCellMaterialBase.map.wrapS = floorCellMaterialBase.map.wrapT = THREE.RepeatWrapping;
                floorCellMaterialBase.map.repeat.set(1, 1); 
            }


            const pitTrapCoverMaterialBase = new THREE.MeshStandardMaterial({
                map: floorTexture ? floorTexture.clone() : null,
                roughness: 0.95, metalness: 0.1,
                color: floorTexture ? 0xffffff : 0x444038
            });
            if (pitTrapCoverMaterialBase.map) {
                 pitTrapCoverMaterialBase.map.needsUpdate = true;
                 pitTrapCoverMaterialBase.map.repeat.set(1,1);
            }

            const lavaMaterialBase = new THREE.MeshStandardMaterial({
                map: lavaTexture ? lavaTexture.clone() : null,
                emissive: LAVA_LIGHT_COLOR, 
                emissiveIntensity: 0.6,
                roughness: 0.6,
                metalness: 0.1,
                color: lavaTexture ? 0xffffff : LAVA_LIGHT_COLOR, 
            });
            if (lavaMaterialBase.map) {
                lavaMaterialBase.map.needsUpdate = true;
                lavaMaterialBase.map.wrapS = lavaMaterialBase.map.wrapT = THREE.RepeatWrapping;
                lavaMaterialBase.map.repeat.set(1, 1); 
            }


            const endMaterial = new THREE.MeshStandardMaterial({ color: MINIMAP_END_COLOR, emissive: MINIMAP_END_COLOR, transparent: true, opacity: 0.6 });
            const endLinkMaterial = new THREE.MeshStandardMaterial({ color: MINIMAP_END_LINK_COLOR, emissive: MINIMAP_END_LINK_COLOR, transparent: true, opacity: 0.7 });


            const torchHolderMaterial = new THREE.MeshStandardMaterial({ color: 0x504030, roughness: 0.8 });
            const flameMaterialBase = new THREE.MeshBasicMaterial({ color: 0xffd080, transparent: true, opacity: FLAME_BASE_OPACITY, blending: THREE.AdditiveBlending, depthWrite: false });

            const wallGeometry = new THREE.BoxGeometry(CELL_SIZE, WALL_HEIGHT, CELL_SIZE);
            const floorCellGeometry = new THREE.PlaneGeometry(CELL_SIZE, CELL_SIZE); 
            const lavaGeometry = new THREE.PlaneGeometry(CELL_SIZE, CELL_SIZE); 
            const endGeometry = new THREE.CylinderGeometry(CELL_SIZE * 0.3, CELL_SIZE * 0.3, 0.2, 16);
            const torchHolderGeometry = new THREE.BoxGeometry(0.2, 0.8, 0.2);
            const flameGeometry = new THREE.SphereGeometry(0.25, 10, 8); 
            const pitCoverGeometry = new THREE.BoxGeometry(CELL_SIZE, PIT_COVER_THICKNESS, CELL_SIZE);
            const pitHoleGeometry = new THREE.BoxGeometry(CELL_SIZE * 0.95, WALL_HEIGHT * 2, CELL_SIZE * 0.95);
            
            const spikeGeometry = new THREE.ConeGeometry(PLAYER_RADIUS * 0.3, SPIKE_HEIGHT, 4);
            
            let torchLocations = [];
            for (let z_grid = 0; z_grid < mazeH; z_grid++) { 
                for (let x_grid = 0; x_grid < mazeW; x_grid++) { 
                    if (!layout[z_grid] || layout[z_grid][x_grid] === undefined) { layout[z_grid][x_grid] = 0; }
                    const cellTypeInLayout = layout[z_grid][x_grid];

                    const posX = (x_grid - mazeW / 2 + 0.5) * CELL_SIZE;
                    const posYBase = WALL_HEIGHT / 2;
                    const posZ = (z_grid - mazeH / 2 + 0.5) * CELL_SIZE;

                    if (cellTypeInLayout === 0) {
                        const wallMatInstance = wallMaterialBase.clone();
                        if (wallMatInstance.map) {
                            wallMatInstance.map = wallMaterialBase.map.clone();
                            wallMatInstance.map.needsUpdate = true;
                            wallMatInstance.map.repeat.set(1, WALL_HEIGHT / CELL_SIZE);
                        }
                        const wall = new THREE.Mesh(wallGeometry, wallMatInstance);
                        wall.position.set(posX, posYBase, posZ);
                        wall.castShadow = true; wall.receiveShadow = true;
                        wall.userData = { isWall: true, originalOpacity: 1.0, isTransparentCapable: true };
                        scene.add(wall);
                        collidableObjects.push(wall);
                    } else if (cellTypeInLayout === LAVA_CELL_TYPE) { 
                        const lavaMatInstance = lavaMaterialBase.clone();
                        if (lavaMatInstance.map) {
                            lavaMatInstance.map = lavaMaterialBase.map.clone(); 
                            lavaMatInstance.map.needsUpdate = true;
                        }
                        const lavaSurface = new THREE.Mesh(lavaGeometry, lavaMatInstance);
                        lavaSurface.rotation.x = -Math.PI / 2;
                        lavaSurface.position.set(posX, LAVA_SURFACE_OFFSET_Y, posZ);
                        lavaSurface.receiveShadow = true; 
                        lavaSurface.userData = { isLava: true, gridX: x_grid, gridZ: z_grid };
                        scene.add(lavaSurface);
                        
                        const lavaLight = new THREE.PointLight(LAVA_LIGHT_COLOR, LAVA_LIGHT_INTENSITY, LAVA_LIGHT_DISTANCE, 1.8);
                        lavaLight.position.set(posX, LAVA_SURFACE_OFFSET_Y + 0.5, posZ);
                        lavaLight.userData.baseIntensity = LAVA_LIGHT_INTENSITY;
                        scene.add(lavaLight);
                        lavaCells.push({ mesh: lavaSurface, light: lavaLight });

                    } else if (cellTypeInLayout === BROKEN_PIT_TRAP_CELL_TYPE_LAYOUT) {
                        const pitHole = new THREE.Mesh(pitHoleGeometry, PIT_HOLE_MATERIAL);
                        pitHole.position.set(posX, -WALL_HEIGHT, posZ);
                        pitHole.visible = true;
                        scene.add(pitHole);
                        pitTrapObjects.push({ mesh: null, holeMesh: pitHole, state: 'broken', gridX: x_grid, gridZ: z_grid, worldX: posX, worldZ: posZ, hasBeenRevealedByActivation: true });
                    } else if (cellTypeInLayout === PIT_TRAP_CELL_TYPE) {
                        const pitCoverMatInstance = pitTrapCoverMaterialBase.clone();
                        if (pitCoverMatInstance.map) {
                            pitCoverMatInstance.map = pitTrapCoverMaterialBase.map.clone();
                            pitCoverMatInstance.map.needsUpdate = true;
                            pitCoverMatInstance.map.repeat.set(1,1);
                        }
                        const pitCover = new THREE.Mesh(pitCoverGeometry, pitCoverMatInstance);
                        pitCover.position.set(posX, -PIT_COVER_THICKNESS / 2, posZ); 
                        pitCover.castShadow = true; pitCover.receiveShadow = true;
                        pitCover.userData = { isPitTrapCover: true, gridX: x_grid, gridZ: z_grid, isCollidable: true };
                        scene.add(pitCover);
                        collidableObjects.push(pitCover);

                        const pitHole = new THREE.Mesh(pitHoleGeometry, PIT_HOLE_MATERIAL);
                        pitHole.position.set(posX, -WALL_HEIGHT, posZ);
                        pitHole.visible = false;
                        scene.add(pitHole);
                        pitTrapObjects.push({ mesh: pitCover, holeMesh: pitHole, state: 'intact', gridX: x_grid, gridZ: z_grid, worldX: posX, worldZ: posZ, hasBeenRevealedByActivation: false });

                    } else { 
                        // Add a floor tile for any non-wall, non-lava, non-broken-pit path cell
                        if (cellTypeInLayout !== 0 && cellTypeInLayout !== BROKEN_PIT_TRAP_CELL_TYPE_LAYOUT) { 
                             const floorCellMatInstance = floorCellMaterialBase.clone();
                             if (floorCellMatInstance.map) {
                                 floorCellMatInstance.map = floorCellMaterialBase.map.clone();
                                 floorCellMatInstance.map.needsUpdate = true;
                             }
                             const floorCell = new THREE.Mesh(floorCellGeometry, floorCellMatInstance);
                             floorCell.rotation.x = -Math.PI / 2;
                             floorCell.position.set(posX, 0, posZ); 
                             floorCell.receiveShadow = true;
                             floorCell.userData = { isFloorTile: true }; 
                             scene.add(floorCell);
                        }
                        
                        if (cellTypeInLayout === FALLING_BLOCK_TRAP_CELL_TYPE) {
                             const rockGroup = new THREE.Group();
                            const numRocks = Math.floor(Math.random() * 3) + 3; 
                            const rockMaterialToUse = FALLING_BLOCK_MATERIAL.clone();
                            if(wallTexture && Math.random() < 0.5) { 
                                rockMaterialToUse.map = wallTexture.clone();
                                rockMaterialToUse.map.needsUpdate = true;
                                rockMaterialToUse.color.set(0xffffff);
                            }

                            for (let i = 0; i < numRocks; i++) {
                                const rockRadius = (Math.random() * 0.2 + 0.25) * CELL_SIZE * 0.8; 
                                const rockGeometry = new THREE.DodecahedronGeometry(rockRadius, 0); 
                                const rock = new THREE.Mesh(rockGeometry, rockMaterialToUse);
                                rock.position.set(
                                    (Math.random() - 0.5) * CELL_SIZE * 0.5,
                                    (Math.random() - 0.5) * CELL_SIZE * 0.3, 
                                    (Math.random() - 0.5) * CELL_SIZE * 0.5
                                );
                                rock.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                                rock.castShadow = true;
                                rockGroup.add(rock);
                            }
                            rockGroup.position.set(posX, WALL_HEIGHT + WALL_HEIGHT * 0.45, posZ); 
                            rockGroup.visible = false;
                            rockGroup.castShadow = true; 
                            scene.add(rockGroup);
                            fallingBlockTrapObjects.push({
                                triggerCellX: x_grid, triggerCellZ: z_grid, worldX: posX, worldZ: posZ,
                                blockMesh: rockGroup, 
                                state: 'armed', hasBeenRevealedByActivation: false,
                                userData: { isFallingBlock: true } 
                            });
                        } else if (cellTypeInLayout === SPIKE_TRAP_CELL_TYPE) {
                            const spikeGroup = new THREE.Group();
                            const numSpikes = 5;
                            for (let i = 0; i < numSpikes; i++) {
                                const spike = new THREE.Mesh(spikeGeometry, SPIKE_MATERIAL.clone());
                                if (i < 4) {
                                    spike.position.x = (i % 2 === 0 ? -1 : 1) * CELL_SIZE * 0.25;
                                    spike.position.z = (i < 2 ? -1 : 1) * CELL_SIZE * 0.25;
                                } else {
                                    spike.position.x = 0; spike.position.z = 0;
                                }
                                spike.position.y = -SPIKE_HEIGHT / 2;
                                spikeGroup.add(spike);
                            }
                            spikeGroup.position.set(posX, 0, posZ);
                            spikeGroup.visible = false;
                            scene.add(spikeGroup);
                            spikeTrapObjects.push({
                                triggerCellX: x_grid, triggerCellZ: z_grid, worldX: posX, worldZ: posZ,
                                spikeGroup: spikeGroup, state: 'hidden', hasBeenRevealedByActivation: false
                            });
                        } else if (cellTypeInLayout === MINOTAUR_CELL_TYPE) {
                             if (!minotaurEnemy) { 
                                if (minotaurModelGLB) { 
                                    minotaurEnemy = minotaurModelGLB.clone(); 

                                    const tempModelForBBox = minotaurModelGLB.clone();
                                    const originalBBox = new THREE.Box3().setFromObject(tempModelForBBox);
                                    const originalSize = new THREE.Vector3();
                                    originalBBox.getSize(originalSize);
                                    const originalMinY = originalBBox.min.y;

                                    console.log(`%cBUILD: Minotaur (monster1.glb) Original - Size: W ${originalSize.x.toFixed(3)}, H ${originalSize.y.toFixed(3)}, D ${originalSize.z.toFixed(3)} | MinY: ${originalMinY.toFixed(3)}`, "color:lightblue;");
                                    console.log(`%cBUILD: MINOTAUR_TARGET_HEIGHT: ${MINOTAUR_TARGET_HEIGHT.toFixed(3)}`, "color:lightgreen;");

                                    let scaleFactor = 1.0;
                                    if (originalSize.y > 0.01) {
                                        scaleFactor = MINOTAUR_TARGET_HEIGHT / originalSize.y;
                                    } else {
                                        console.warn("BUILD: Minotaur model original height is very small or zero. Using scale factor 1.");
                                    }
                                    console.log(`%cBUILD: Calculated scaleFactor: ${scaleFactor.toFixed(3)}`, "color:lightgreen;");
                                    minotaurEnemy.scale.set(scaleFactor, scaleFactor, scaleFactor);
                                    console.log(`%cBUILD: Minotaur scaled. Actual minotaurEnemy.scale: (${minotaurEnemy.scale.x.toFixed(3)}, ${minotaurEnemy.scale.y.toFixed(3)}, ${minotaurEnemy.scale.z.toFixed(3)})`, "color:orange;");
                                    
                                    const worldPosYForMinotaurOrigin = -(originalMinY * scaleFactor);
                                    minotaurEnemy.position.set(posX, worldPosYForMinotaurOrigin, posZ);
                                    console.log(`%cBUILD: Minotaur placed. Model origin at world Y: ${worldPosYForMinotaurOrigin.toFixed(3)}. Expected visual base at Y=0. (Cell: X ${posX.toFixed(2)}, Z ${posZ.toFixed(2)})`, "color:orange;");
                                   
                                } else { 
                                    console.warn("Modelo del Minotauro no cargado, usando cilindro.");
                                    const minoGeom = new THREE.CylinderGeometry(MINOTAUR_COLLISION_RADIUS, MINOTAUR_COLLISION_RADIUS * 0.8, MINOTAUR_COLLISION_HEIGHT, 16); 
                                    const minoMat = new THREE.MeshStandardMaterial({ color: 0x8B0000, roughness: 0.5, metalness: 0.2 });
                                    minotaurEnemy = new THREE.Mesh(minoGeom, minoMat);
                                    minotaurEnemy.position.set(posX, MINOTAUR_COLLISION_HEIGHT / 2, posZ); 
                                }
                                
                                minotaurEnemy.castShadow = true;
                                minotaurEnemy.traverse(child => { 
                                    if (child.isMesh) {
                                        child.castShadow = true;
                                        child.receiveShadow = true; 
                                    }
                                });
                                minotaurEnemy.rotation.order = 'YXZ';
                                minotaurInitialGridPos = { x: x_grid, z: z_grid };
                                minotaurEnemy.userData.gridX = x_grid;
                                minotaurEnemy.userData.gridZ = z_grid;
                                scene.add(minotaurEnemy);

                                const collisionCylinderGeom = new THREE.CylinderGeometry(MINOTAUR_COLLISION_RADIUS, MINOTAUR_COLLISION_RADIUS, MINOTAUR_COLLISION_HEIGHT, 8);
                                minotaurCollisionCylinder = new THREE.Mesh(collisionCylinderGeom, new THREE.MeshBasicMaterial({visible: false, transparent: true, opacity: 0.3, color:0x00ff00})); 
                                minotaurCollisionCylinder.position.set(posX, MINOTAUR_COLLISION_HEIGHT / 2, posZ);
                                scene.add(minotaurCollisionCylinder); 
                                collidableObjects.push(minotaurCollisionCylinder);


                                const mTorchGroup = new THREE.Group();
                                const mTorchLight = new THREE.PointLight(MINOTAUR_TORCH_COLOR, MINOTAUR_TORCH_LIGHT_INTENSITY, MINOTAUR_TORCH_LIGHT_DISTANCE, MINOTAUR_TORCH_LIGHT_DECAY);
                                mTorchLight.castShadow = true; 
                                mTorchLight.shadow.mapSize.width = 128; 
                                mTorchLight.shadow.mapSize.height = 128;
                                mTorchLight.userData.baseIntensity = MINOTAUR_TORCH_LIGHT_INTENSITY;
                                mTorchGroup.add(mTorchLight);

                                const mFlameMat = flameMaterialBase.clone();
                                mFlameMat.color.set(MINOTAUR_TORCH_COLOR); 
                                const mFlameGeom = new THREE.ConeGeometry(MINOTAUR_TORCH_FLAME_SIZE * 0.5, MINOTAUR_TORCH_FLAME_SIZE * 1.5, 8);
                                mFlameGeom.translate(0, MINOTAUR_TORCH_FLAME_SIZE * 0.75, 0);
                                const mFlameMesh = new THREE.Mesh(mFlameGeom, mFlameMat);
                                mTorchGroup.add(mFlameMesh);
                                
                                let handBone = null;
                                const minotaurHandBoneNames = ["Hand.R", "mixamorig_RightHand", "mixamorig:RightHand", "mixamorig:righthand", "Bip01_R_Hand", "mano_d", "hand_r", "Hand_R", "RightHand", "joint_HandRT", "Weapon", "Bip001_R_Hand", "monster_hand_r", "RightHandBone", "r_hand_weapon", "weapon_joint", "Object_Weapon", "weapon_bone_r"]; 
                                if (minotaurEnemy) { 
                                    minotaurEnemy.traverse((node) => { 
                                        if ((node.isBone || node.isObject3D) && minotaurHandBoneNames.some(name => node.name.toLowerCase().includes(name.toLowerCase()))) {
                                            handBone = node;
                                        }
                                    });
                                }

                                if (handBone) {
                                    console.log("Minotaur torch attached to bone:", handBone.name);
                                    handBone.add(mTorchGroup);
                                    mTorchGroup.position.set(0.05, 0.15, 0.05); 
                                    mTorchGroup.rotation.x = Math.PI / 6; 
                                } else {
                                    console.warn("Minotaur hand bone not found. Attaching torch to visual model root with offset.");
                                    minotaurEnemy.add(mTorchGroup); 
                                    mTorchGroup.position.copy(MINOTAUR_TORCH_OFFSET);
                                }
                                minotaurTorch = { light: mTorchLight, flameMesh: mFlameMesh, group: mTorchGroup };
                                
                                console.log("Minotaur spawned at grid:", x_grid, z_grid);
                                currentMazeLayout[z_grid][x_grid] = 1; 
                            } else {
                                console.warn("Multiple Minotaur start points defined, only one used.");
                                currentMazeLayout[z_grid][x_grid] = 1;
                            }
                        }
                        
                        if (Math.random() < STATIC_TORCH_FREQUENCY) {
                            let possibleTorchWalls = [];
                            if (z_grid > 0 && layout[z_grid-1][x_grid] === 0) possibleTorchWalls.push({ side: 'N' });
                            if (z_grid < mazeH - 1 && layout[z_grid+1][x_grid] === 0) possibleTorchWalls.push({ side: 'S' });
                            if (x_grid > 0 && layout[z_grid][x_grid-1] === 0) possibleTorchWalls.push({ side: 'W' });
                            if (x_grid < mazeW - 1 && layout[z_grid][x_grid+1] === 0) possibleTorchWalls.push({ side: 'E' });
                            if (possibleTorchWalls.length > 0) {
                                const chosenWallData = possibleTorchWalls[Math.floor(Math.random() * possibleTorchWalls.length)];
                                let tooClose = torchLocations.some(loc => Math.abs(loc.x - posX) < CELL_SIZE * 1.5 && Math.abs(loc.z - posZ) < CELL_SIZE * 1.5 );
                                if (!tooClose) { addStaticTorch(posX, posZ, chosenWallData.side, torchHolderGeometry, flameGeometry, torchHolderMaterial, flameMaterialBase, mazeW, mazeH); torchLocations.push({x: posX, z: posZ}); }
                            }
                        }
                        if (cellTypeInLayout === END_CELL_TERMINATE || cellTypeInLayout === END_CELL_SPECIFIC_NEXT) {
                            const currentEndMaterial = (cellTypeInLayout === END_CELL_SPECIFIC_NEXT) ? endLinkMaterial.clone() : endMaterial.clone();
                            const endZoneMesh = new THREE.Mesh(endGeometry, currentEndMaterial); 
                            endZoneMesh.position.set(posX, 0.1, posZ);
                            endZoneMesh.userData = { type: 'end', behaviorType: cellTypeInLayout, gridX: x_grid, gridZ: z_grid };
                            scene.add(endZoneMesh);
                            endZones.push(endZoneMesh); 
                            interactiveObjects.push(endZoneMesh);
                        }
                    }
                }
            }
        }
        function addStaticTorch(pathCellX, pathCellZ, attachSide, holderGeom, flameGeom, holderMat, flameMatBase, mazeW, mazeH) {
            const torchY = WALL_HEIGHT * 0.6; const holder = new THREE.Mesh(holderGeom, holderMat.clone()); const flameMaterial = flameMatBase.clone(); const flame = new THREE.Mesh(flameGeom, flameMaterial); const light = new THREE.PointLight( TORCH_COLOR, TORCH_STATIC_INTENSITY, TORCH_STATIC_DISTANCE, TORCH_STATIC_DECAY ); light.castShadow = false; light.userData.baseIntensity = TORCH_STATIC_INTENSITY; staticTorches.push({ light: light, flameMesh: flame }); const torchOffsetFromWall = TORCH_WALL_OFFSET; const halfCell = CELL_SIZE / 2; let torchPosX = pathCellX; let torchPosZ = pathCellZ; let holderRotationY = 0;
            if (attachSide === 'N') { torchPosZ = pathCellZ - halfCell + torchOffsetFromWall; holderRotationY = Math.PI; } else if (attachSide === 'S') { torchPosZ = pathCellZ + halfCell - torchOffsetFromWall; holderRotationY = 0; } else if (attachSide === 'W') { torchPosX = pathCellX - halfCell + torchOffsetFromWall; holderRotationY = Math.PI / 2; } else if (attachSide === 'E') { torchPosX = pathCellX + halfCell - torchOffsetFromWall; holderRotationY = -Math.PI / 2; }
            holder.position.set(torchPosX, torchY, torchPosZ); holder.rotation.y = holderRotationY; flame.position.set(torchPosX, torchY + 0.5, torchPosZ); light.position.set(torchPosX, torchY + 0.4, torchPosZ); scene.add(holder); scene.add(flame); scene.add(light);
        }


        let touchControlsSetupDone = false;
        function isInsideUIScreen(target) { return target.closest('#loading-screen') || target.closest('#custom-game-screen') || target.closest('#scenario-editor-screen') || target.closest('#next-scenario-selection-screen'); }
        function updateJoystickThumb() { const dX=joystickCurrentPos.x-joystickStartPos.x, dY=joystickCurrentPos.y-joystickStartPos.y, dist=Math.sqrt(dX*dX+dY*dY); const angle=Math.atan2(dY,dX); const tD=Math.min(dist, JOYSTICK_VISUAL_RADIUS/2-joystickThumb.offsetWidth/4); const tX=Math.cos(angle)*tD, tY=Math.sin(angle)*tD; joystickThumb.style.transform=`translate(${tX}px, ${tY}px)`; }
        function updateMovementFromJoystick() {
            const dx = joystickCurrentPos.x - joystickStartPos.x;
            const dy = joystickCurrentPos.y - joystickStartPos.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist === 0) {
                moveForward = 0; moveRight = 0; return;
            }
            let normalizedX = dx / JOYSTICK_EFFECTIVE_RADIUS;
            let normalizedY = dy / JOYSTICK_EFFECTIVE_RADIUS;
            const magnitude = Math.min(1.0, dist / JOYSTICK_EFFECTIVE_RADIUS);
            if (magnitude < JOYSTICK_DEADZONE) {
                moveForward = 0; moveRight = 0; return;
            }
            moveForward = -normalizedY * magnitude;
            moveRight   =  normalizedX * magnitude;
            moveForward = Math.max(-1, Math.min(1, moveForward));
            moveRight   = Math.max(-1, Math.min(1, moveRight));
        }
        function setupTouchControls() {
            if (touchControlsSetupDone) return;
            document.body.addEventListener('pointerdown', handlePointerDown); document.body.addEventListener('pointermove', handlePointerMove); document.body.addEventListener('pointerup', handlePointerEnd); document.body.addEventListener('pointercancel', handlePointerEnd);
            jumpButton.addEventListener('touchstart', (e) => { e.preventDefault(); if (playerOnGround && gameActive && !playerFallingIntoPit) playerVelocity.y = JUMP_VELOCITY; }, { passive: false });
            actionButton.addEventListener('touchstart', (e) => { e.preventDefault(); if (gameActive) toggleView(); }, { passive: false });
            touchControlsSetupDone = true;
        }
        function handlePointerDown(event) { if (isInsideUIScreen(event.target)) { return; } if (event.target === jumpButton || event.target === actionButton || event.target.closest('#minimapCanvas')) return; event.preventDefault(); const tX=event.clientX, tY=event.clientY, sW=window.innerWidth; if (tX < sW/2 && joystickPointerId===-1){ joystickPointerId=event.pointerId; joystickStartPos={x:tX,y:tY}; joystickCurrentPos={x:tX,y:tY}; joystickArea.style.display='flex'; joystickArea.style.left=`${tX}px`; joystickArea.style.top=`${tY}px`; joystickThumb.style.transform='translate(0px, 0px)'; updateMovementFromJoystick(); } else if (tX >= sW/2 && cameraPointerId===-1){ cameraPointerId=event.pointerId; cameraTouchStartPos={x:tX, y:tY}; } }
        function handlePointerMove(event) { if (isInsideUIScreen(event.target)) { return; } if (event.target === jumpButton || event.target === actionButton || event.target.closest('#minimapCanvas')) return; event.preventDefault(); if(event.pointerId===joystickPointerId){ joystickCurrentPos={x:event.clientX, y:event.clientY}; updateJoystickThumb(); updateMovementFromJoystick(); } else if(event.pointerId===cameraPointerId){ const tX=event.clientX, tY=event.clientY; updateCameraLook(tX-cameraTouchStartPos.x, tY-cameraTouchStartPos.y); cameraTouchStartPos={x:tX,y:tY}; } }
        function handlePointerEnd(event) { if (isInsideUIScreen(event.target)) { return; } if (event.target === jumpButton || event.target === actionButton || event.target.closest('#minimapCanvas')) return; if(event.pointerId===joystickPointerId){ joystickPointerId=-1; joystickArea.style.display='none'; moveForward=0; moveRight=0; } else if(event.pointerId===cameraPointerId){ cameraPointerId=-1; } }


        let keyboardControlsSetupDone = false;
        function setupKeyboardAndMouseControls() {
            if (keyboardControlsSetupDone) return;
            document.addEventListener('keydown', (event) => { keyStates[event.code] = true; handleKeyPress(event.code); }); document.addEventListener('keyup', (event) => { keyStates[event.code] = false; });
            renderer.domElement.addEventListener('mousedown', (event) => { if (event.button === 0 && !isPointerLocked && gameActive) { renderer.domElement.requestPointerLock(); } });
            renderer.domElement.addEventListener('contextmenu', (event) => { event.preventDefault(); if (gameActive) { toggleView(); } });
            document.addEventListener('pointerlockchange', () => { isPointerLocked = document.pointerLockElement === renderer.domElement; if (isPointerLocked) { if (pointerLockInfoDiv) pointerLockInfoDiv.style.display = 'none'; renderer.domElement.style.cursor = 'none'; } else { if (pointerLockInfoDiv && !isTouchDevice) pointerLockInfoDiv.style.display = 'block'; renderer.domElement.style.cursor = 'grab'; keyStates = {}; moveForward=0; moveRight=0; } }, false);
            document.addEventListener('pointerlockerror', () => { console.error('Error blocking mouse pointer.'); if (pointerLockInfoDiv && !isTouchDevice) pointerLockInfoDiv.style.display = 'block'; }, false);
            document.addEventListener('mousemove', (event) => { if (isPointerLocked && gameActive) { updateCameraLook(event.movementX, event.movementY); } });
            keyboardControlsSetupDone = true;
        }
        function handleKeyPress(code) { if (!gameActive) return; if (code === 'KeyV') { toggleView(); } }
        function updateMovementFromKeyboard() { if (isTouchDevice || !isPointerLocked || playerFallingIntoPit) { moveForward=0; moveRight=0; return; } let newMoveForward = 0; let newMoveRight = 0; if (keyStates['KeyW'] || keyStates['ArrowUp']) newMoveForward = 1; if (keyStates['KeyS'] || keyStates['ArrowDown']) newMoveForward = -1; if (keyStates['KeyA'] || keyStates['ArrowLeft']) newMoveRight = -1; if (keyStates['KeyD'] || keyStates['ArrowRight']) newMoveRight = 1; if (joystickPointerId === -1) { moveForward = newMoveForward; moveRight = newMoveRight; } if (keyStates['Space'] && playerOnGround) { playerVelocity.y = JUMP_VELOCITY; } }
        
        function updateCameraLook(deltaX, deltaY) {
            let currentSensitivity = CAMERA_SENSITIVITY;
            if (isTouchDevice) {
                currentSensitivity *= CAMERA_SENSITIVITY_MOBILE_MULTIPLIER;
            }
            cameraTheta -= deltaX * currentSensitivity;
            cameraPhi -= deltaY * currentSensitivity;
            cameraPhi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraPhi));
        }


        function toggleView() {
            if (!player || !camera || !scene) return; 
            isFirstPersonView = !isFirstPersonView;
            player.visible = !isFirstPersonView; 

            if (spearLight) { 
                if (isFirstPersonView) {
                    spearLight.intensity = SPEAR_LIGHT_INTENSITY * 0.3; 
                    spearLight.castShadow = false; 
                    spearLight.distance = spearLight.userData.originalDistance * 0.5; 
                } else {
                    spearLight.intensity = spearLight.userData.baseIntensity; 
                    spearLight.castShadow = true;
                    spearLight.distance = spearLight.userData.originalDistance; 
                }
            }

            if (isFirstPersonView) {
                showMessage("Vista: Primera Persona", 1500);
            } else {
                showMessage("Vista: Tercera Persona", 1500);
            }
            updateCamera(); 
        }


        function updatePlayer(deltaTime) {
            if (!gameActive || !player) return;
            if (!isTouchDevice) { updateMovementFromKeyboard(); }

            let currentSpeed = PLAYER_SPEED;
            let isSprinting = (!isTouchDevice && keyStates['ShiftLeft'] && moveForward > 0);
            if (playerOnGround && !playerFallingIntoPit && ( (moveForward > SPRINT_THRESHOLD && joystickPointerId !== -1) || isSprinting) ) {
                currentSpeed = SPRINT_SPEED;
            }

            let dampingFactor = playerOnGround ? 0.85 : 0.98;
            if (!playerOnGround) playerVelocity.y += GRAVITY * deltaTime;
            playerVelocity.y = Math.max(playerVelocity.y, -30);

            const previousY = player.position.y;

            if (!playerFallingIntoPit) {
                const forward = new THREE.Vector3(0, 0, -1); forward.applyQuaternion(player.quaternion); forward.y = 0; forward.normalize();
                const right = new THREE.Vector3(1, 0, 0); right.applyQuaternion(player.quaternion); right.y = 0; right.normalize();
                const targetVelocityXZ = new THREE.Vector3();
                targetVelocityXZ.addScaledVector(forward, -moveForward * currentSpeed);
                targetVelocityXZ.addScaledVector(right,   -moveRight * currentSpeed);
                playerVelocity.x += (targetVelocityXZ.x - playerVelocity.x) * 0.25;
                playerVelocity.z += (targetVelocityXZ.z - playerVelocity.z) * 0.25;
            } else {
                playerVelocity.x *= 0.9;
                playerVelocity.z *= 0.9;
            }
            playerVelocity.x *= dampingFactor;
            playerVelocity.z *= dampingFactor;

            let isMoving = Math.abs(moveForward) > 0.01 || Math.abs(moveRight) > 0.01 || Math.abs(playerVelocity.x) > 0.05 || Math.abs(playerVelocity.z) > 0.05;
            let isSprintingEffective = (currentSpeed === SPRINT_SPEED && isMoving && playerOnGround);

            if (playerMixer) {
                let actionToPlay = idleAction;
                if (playerFallingIntoPit) { 
                    actionToPlay = idleAction; 
                } else if (isSprintingEffective && runAction) {
                    actionToPlay = runAction;
                } else if (isMoving && playerOnGround && walkAction) {
                    actionToPlay = walkAction;
                } else if (!playerOnGround && idleAction) { 
                    actionToPlay = idleAction; 
                }


                if (actionToPlay && actionToPlay !== currentAction) {
                    if (currentAction) {
                        currentAction.fadeOut(0.2);
                    }
                    actionToPlay.reset().setEffectiveTimeScale(1).setEffectiveWeight(1).fadeIn(0.2).play();
                    currentAction = actionToPlay;
                } else if (!currentAction && idleAction) { 
                    idleAction.reset().play();
                    currentAction = idleAction;
                }
            }


            const deltaPosition = playerVelocity.clone().multiplyScalar(deltaTime);
            playerOnGround = false; // Will be set true by collision or ground check
            const collisionSizeVec = new THREE.Vector3(PLAYER_RADIUS * 2, PLAYER_HEIGHT, PLAYER_RADIUS * 2);

            // Vertical collision with objects
            const verticalCheckCenter = player.position.clone().add(new THREE.Vector3(0, deltaPosition.y, 0));
            collisionCheckTempBox.setFromCenterAndSize(verticalCheckCenter, collisionSizeVec);

            for (const obj of collidableObjects) {
                if (obj.userData.isFloorTile || obj.userData.isCeiling || obj === minotaurCollisionCylinder) continue; 
                if (obj.userData.isPitTrapCover && !obj.userData.isCollidable) continue;
                if (obj.userData.isFallingBlock && obj.userData.state !== 'landed') continue; 

                const oB = new THREE.Box3().setFromObject(obj);
                if (collisionCheckTempBox.intersectsBox(oB)) {
                    if (deltaPosition.y < 0 && collisionCheckTempBox.min.y < oB.max.y) { // Falling onto object
                        playerVelocity.y = 0;
                        deltaPosition.y = oB.max.y - (player.position.y - PLAYER_HEIGHT / 2) + 0.001;
                        playerOnGround = true;
                    } else if (deltaPosition.y > 0 && collisionCheckTempBox.max.y > oB.min.y) { // Jumping into object from below
                        playerVelocity.y = 0;
                        deltaPosition.y = oB.min.y - (player.position.y + PLAYER_HEIGHT / 2) - 0.001;
                    }
                    break; 
                }
            }

            // Generic ground check & Lava interaction
            const playerGridXForGroundCheck = Math.floor((player.position.x / CELL_SIZE) + (currentMazeWidth / 2));
            const playerGridZForGroundCheck = Math.floor((player.position.z / CELL_SIZE) + (currentMazeHeight / 2));
            let isOverLavaCell = false;
            if (playerGridXForGroundCheck >= 0 && playerGridXForGroundCheck < currentMazeWidth &&
                playerGridZForGroundCheck >= 0 && playerGridZForGroundCheck < currentMazeHeight &&
                currentMazeLayout[playerGridZForGroundCheck] && currentMazeLayout[playerGridZForGroundCheck][playerGridXForGroundCheck] === LAVA_CELL_TYPE) {
                isOverLavaCell = true;
            }
            
            const groundY = 0; 
            const feetY = player.position.y + deltaPosition.y - PLAYER_HEIGHT / 2;

            if (playerFallingIntoPit) {
                if (player.position.y + deltaPosition.y < PIT_FALL_DEPTH) {
                    loseGame("Caíste en un foso!");
                }
            } else {
                if (isOverLavaCell) {
                    // Over lava: standard ground snapping (to y=0) is skipped. Gravity will continue to act.
                    // playerOnGround will remain false unless a specific collidable object (not lava surface) is hit.
                } else {
                    // Regular ground collision for non-lava cells (if not already onGround from object collision)
                    if (feetY <= groundY && playerVelocity.y <= 0 && !playerOnGround) {
                        playerVelocity.y = 0;
                        deltaPosition.y = groundY - (player.position.y - PLAYER_HEIGHT / 2);
                        playerOnGround = true;
                    }
                }
            }
            player.position.y += deltaPosition.y; 


            // Horizontal Collision
            if (!playerFallingIntoPit && gameActive) { 
                const horizontalCheckPos = player.position.clone().add(new THREE.Vector3(deltaPosition.x, 0, deltaPosition.z));
                collisionCheckTempBox.setFromCenterAndSize(horizontalCheckPos, collisionSizeVec);

                let collisionX = false; let collisionZ = false;
                for (const obj of collidableObjects) {
                    if (obj.userData.isFloorTile || obj.userData.isCeiling || obj === minotaurCollisionCylinder) continue; 
                    if (obj.userData.isPitTrapCover && !obj.userData.isCollidable) continue;
                    if (obj.userData.isFallingBlock && obj.userData.state !== 'landed') continue; 

                    const oB = new THREE.Box3().setFromObject(obj);

                    const tempBoxX = new THREE.Box3().setFromCenterAndSize(player.position.clone().add(new THREE.Vector3(deltaPosition.x, 0, 0)), collisionSizeVec);
                    if (tempBoxX.intersectsBox(oB)) {
                        if (oB.max.y > player.position.y - PLAYER_HEIGHT/2 && oB.max.y < player.position.y - PLAYER_HEIGHT/2 + PLAYER_STEP_HEIGHT && playerOnGround && deltaPosition.x !== 0) {
                            const stepUpAmount = oB.max.y - (player.position.y - PLAYER_HEIGHT/2) + 0.01;
                            player.position.y += stepUpAmount; // Step up
                        } else {
                            collisionX = true;
                        }
                    }
                    const tempBoxZ = new THREE.Box3().setFromCenterAndSize(player.position.clone().add(new THREE.Vector3(0, 0, deltaPosition.z)), collisionSizeVec);
                    if (tempBoxZ.intersectsBox(oB)) {
                         if (oB.max.y > player.position.y - PLAYER_HEIGHT/2 && oB.max.y < player.position.y - PLAYER_HEIGHT/2 + PLAYER_STEP_HEIGHT && playerOnGround && deltaPosition.z !== 0) {
                            const stepUpAmount = oB.max.y - (player.position.y - PLAYER_HEIGHT/2) + 0.01;
                            player.position.y += stepUpAmount; // Step up
                        } else {
                            collisionZ = true;
                        }
                    }
                    if (collisionX && collisionZ) break;
                }
                if(collisionX) { playerVelocity.x = 0; deltaPosition.x = 0; }
                if(collisionZ) { playerVelocity.z = 0; deltaPosition.z = 0; }
            }

            player.position.x += deltaPosition.x;
            player.position.z += deltaPosition.z;

            // Lava death check (after all position updates for the frame)
            if (!playerFallingIntoPit && gameActive) {
                const finalPlayerGridX = Math.floor((player.position.x / CELL_SIZE) + (currentMazeWidth / 2));
                const finalPlayerGridZ = Math.floor((player.position.z / CELL_SIZE) + (currentMazeHeight / 2));

                if (finalPlayerGridX >= 0 && finalPlayerGridX < currentMazeWidth &&
                    finalPlayerGridZ >= 0 && finalPlayerGridZ < currentMazeHeight &&
                    currentMazeLayout[finalPlayerGridZ] && currentMazeLayout[finalPlayerGridZ][finalPlayerGridX] === LAVA_CELL_TYPE) {
                    
                    if ((player.position.y - (PLAYER_HEIGHT / 2)) < (LAVA_SURFACE_OFFSET_Y + 0.05)) { // Feet at/below lava surface
                        loseGame("¡Quemado por la lava!");
                    }
                }
            }


            player.rotation.y = cameraTheta + Math.PI;

            // Trap Triggers & End Zone
            if (!playerFallingIntoPit && gameActive) { 
                for (const trap of pitTrapObjects) {
                    if (trap.state === 'intact') {
                        const distSq = player.position.clone().setY(0).distanceToSquared(new THREE.Vector3(trap.worldX, 0, trap.worldZ));
                        if (playerOnGround && distSq < PIT_TRAP_TRIGGER_RADIUS_SQUARED && Math.abs(player.position.y - PLAYER_HEIGHT / 2) < PLAYER_STEP_HEIGHT + 0.01) {
                            triggerPitTrap(trap);
                        }
                    }
                }
                for (const trap of fallingBlockTrapObjects) {
                    if (trap.state === 'armed') {
                        const playerGridX = Math.round(player.position.x / CELL_SIZE + currentMazeWidth / 2 - 0.5);
                        const playerGridZ = Math.round(player.position.z / CELL_SIZE + currentMazeHeight / 2 - 0.5);
                        if (playerGridX === trap.triggerCellX && playerGridZ === trap.triggerCellZ && playerOnGround) {
                            triggerFallingBlockTrap(trap);
                        }
                    } else if (trap.state === 'falling') {
                        const fallSpeed = WALL_HEIGHT * 3 * deltaTime;
                        trap.blockMesh.position.y -= fallSpeed; 
                        
                        const playerBox = new THREE.Box3().setFromCenterAndSize(player.position, new THREE.Vector3(PLAYER_RADIUS*2, PLAYER_HEIGHT, PLAYER_RADIUS*2));
                        const blockGroupBBox = new THREE.Box3().setFromObject(trap.blockMesh); 

                        if (playerBox.intersectsBox(blockGroupBBox)) {
                            let hitRock = false;
                            for(const rock of trap.blockMesh.children) {
                                const rockBBoxWorld = new THREE.Box3().setFromObject(rock);
                                if (playerBox.intersectsBox(rockBBoxWorld)) {
                                    hitRock = true;
                                    break;
                                }
                            }
                            if (hitRock) {
                                loseGame("¡Aplastado por rocas!");
                                trap.state = 'landed';
                                trap.blockMesh.position.y = (WALL_HEIGHT * 0.35) / 2; 
                                if (!collidableObjects.includes(trap.blockMesh)) collidableObjects.push(trap.blockMesh);
                            }
                        }
                        if (trap.blockMesh.position.y <= (WALL_HEIGHT * 0.35) / 2) { 
                            trap.blockMesh.position.y = (WALL_HEIGHT * 0.35) / 2;
                            trap.state = 'landed';
                            if (!collidableObjects.includes(trap.blockMesh)) collidableObjects.push(trap.blockMesh);
                        }
                    }
                }
                for (const trap of spikeTrapObjects) {
                     if (trap.state === 'hidden') {
                        const playerGridX = Math.round(player.position.x / CELL_SIZE + currentMazeWidth / 2 - 0.5);
                        const playerGridZ = Math.round(player.position.z / CELL_SIZE + currentMazeHeight / 2 - 0.5);
                        if (playerGridX === trap.triggerCellX && playerGridZ === trap.triggerCellZ && playerOnGround) {
                            triggerSpikeTrap(trap);
                        }
                    }
                }
            }

            if (endZones.length > 0 && gameActive && !playerFallingIntoPit) { 
                for (const currentEndZone of endZones) {
                    const pXZ = new THREE.Vector2(player.position.x, player.position.z);
                    const eZXZ = new THREE.Vector2(currentEndZone.position.x, currentEndZone.position.z);
                    if (playerOnGround && pXZ.distanceTo(eZXZ) < PLAYER_RADIUS + CELL_SIZE * 0.3) {
                        winGame(currentEndZone.userData.behaviorType, currentEndZone.userData.gridX, currentEndZone.userData.gridZ);
                        break; 
                    }
                }
            }
        }

        function triggerPitTrap(trap) {
            if (trap.state !== 'intact' || !gameActive) return;

            if (!trap.hasBeenRevealedByActivation) {
                trap.hasBeenRevealedByActivation = true;
            }

            trap.state = 'breaking';
            if (trap.mesh && trap.mesh.userData) trap.mesh.userData.isCollidable = false;
            currentMazeLayout[trap.gridZ][trap.gridX] = BROKEN_PIT_TRAP_CELL_TYPE_LAYOUT;

            if(crackedTexture && trap.mesh && trap.mesh.material.map !== crackedTexture) {
                const newMaterial = trap.mesh.material.clone();
                newMaterial.map = crackedTexture.clone();
                newMaterial.map.needsUpdate = true;
                newMaterial.map.repeat.set(1,1);
                trap.mesh.material = newMaterial;
            }
            if (trap.holeMesh) trap.holeMesh.visible = true;

            if (trap.mesh) {
                new TWEEN.Tween(trap.mesh.rotation)
                    .to({ x: trap.mesh.rotation.x - Math.PI / 2.1 }, PIT_TRAP_BREAK_ANIMATION_TIME * 0.8)
                    .easing(TWEEN.Easing.Quadratic.In)
                    .onComplete(() => {
                         new TWEEN.Tween(trap.mesh.position)
                            .to({ y: PIT_FALL_DEPTH * 0.5 }, PIT_TRAP_BREAK_ANIMATION_TIME * 0.7) 
                            .easing(TWEEN.Easing.Quadratic.In)
                            .onComplete(() => {
                                trap.state = 'broken';
                                if(trap.mesh) {
                                     trap.mesh.visible = false; 
                                }
                            })
                            .start();
                    })
                    .start();
            }


            const playerGridX = Math.round(player.position.x / CELL_SIZE + currentMazeWidth / 2 - 0.5);
            const playerGridZ = Math.round(player.position.z / CELL_SIZE + currentMazeHeight / 2 - 0.5);

            if (playerGridX === trap.gridX && playerGridZ === trap.gridZ && playerOnGround) {
                playerFallingIntoPit = { x: trap.gridX, z: trap.gridZ };
                playerOnGround = false;
                playerVelocity.y = -1.0;
                showMessage("¡El suelo se rompe!", 2000);
            }
        }
        function triggerFallingBlockTrap(trap) {
            if (trap.state !== 'armed' || !gameActive) return;
            trap.state = 'falling';
            trap.blockMesh.visible = true; 
            if (!trap.hasBeenRevealedByActivation) trap.hasBeenRevealedByActivation = true;
        }
        function triggerSpikeTrap(trap) {
            if (trap.state !== 'hidden' || !gameActive) return;
            trap.state = 'rising';
            trap.spikeGroup.visible = true;
            currentMazeLayout[trap.triggerCellZ][trap.triggerCellX] = BROKEN_PIT_TRAP_CELL_TYPE_LAYOUT; 

            if (!trap.hasBeenRevealedByActivation) trap.hasBeenRevealedByActivation = true;

            trap.spikeGroup.children.forEach((spike, index) => {
                new TWEEN.Tween(spike.position)
                    .to({ y: SPIKE_HEIGHT / 2 - 0.1 }, SPIKE_RISE_TIME)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .delay(index * 30)
                    .onComplete(() => {
                        if (index === trap.spikeGroup.children.length - 1) {
                            trap.state = 'risen';
                            const playerGridX = Math.round(player.position.x / CELL_SIZE + currentMazeWidth / 2 - 0.5);
                            const playerGridZ = Math.round(player.position.z / CELL_SIZE + currentMazeHeight / 2 - 0.5);
                            if (playerGridX === trap.triggerCellX && playerGridZ === trap.triggerCellZ &&
                                Math.abs(player.position.y - PLAYER_HEIGHT/2) < SPIKE_HEIGHT * 0.7 ) {
                                loseGame("¡Ensartado por pinchos!");
                            }
                        }
                    })
                    .start();
            });
        }
        
        function isCellWalkableForMinotaur(gridX, gridZ, targetMazeLayout, originalMazeRef) {
            if (gridX < 0 || gridX >= currentMazeWidth || gridZ < 0 || gridZ >= currentMazeHeight) {
                return false; // Out of bounds
            }
            if (!targetMazeLayout[gridZ] || !originalMazeRef[gridZ]) return false;

            const cellTypeInLayout = targetMazeLayout[gridZ][gridX];
            const originalCellType = originalMazeRef[gridZ][gridX];

            if (cellTypeInLayout === 0) return false; // Wall in current layout
            if (cellTypeInLayout === LAVA_CELL_TYPE) return false; // Lava

            // Minotaur avoids stepping on any original trap-type cells, regardless of current state
            if (originalCellType === PIT_TRAP_CELL_TYPE ||
                originalCellType === FALLING_BLOCK_TRAP_CELL_TYPE ||
                originalCellType === SPIKE_TRAP_CELL_TYPE) {
                return false; 
            }
            
            // Also avoid stepping on currently broken pits (holes)
            if (cellTypeInLayout === BROKEN_PIT_TRAP_CELL_TYPE_LAYOUT) return false; 

            return true; // Walkable
        }

        function updateMinotaur(deltaTime) {
            if (!minotaurEnemy || !gameActive || playerFallingIntoPit) return;

            const currentTime = clock.elapsedTime * 1000; 

            minotaurEnemy.userData.gridX = Math.round(minotaurEnemy.position.x / CELL_SIZE + currentMazeWidth / 2 - 0.5);
            minotaurEnemy.userData.gridZ = Math.round(minotaurEnemy.position.z / CELL_SIZE + currentMazeHeight / 2 - 0.5);

            if (minotaurCollisionCylinder) {
                minotaurCollisionCylinder.position.set(
                    minotaurEnemy.position.x,
                    minotaurEnemy.position.y + MINOTAUR_COLLISION_HEIGHT / 2, 
                    minotaurEnemy.position.z
                );
                minotaurCollisionCylinder.rotation.copy(minotaurEnemy.rotation);
            }


            const canSee = canMinotaurSeePlayer();

            if (minotaurState === 'chasing') {
                if (canSee) {
                    minotaurLastSawPlayerTime = currentTime;
                    minotaurTargetCell = { 
                        x: Math.round(player.position.x / CELL_SIZE + currentMazeWidth / 2 - 0.5),
                        z: Math.round(player.position.z / CELL_SIZE + currentMazeHeight / 2 - 0.5)
                    };
                } else {
                    if (currentTime - minotaurLastSawPlayerTime > MINOTAUR_LOSE_SIGHT_TIME) {
                        minotaurState = 'patrolling';
                        minotaurTargetCell = null; 
                        minotaurPatrolNextTargetTime = currentTime; 
                    }
                }
            } else if (minotaurState === 'patrolling') {
                if (canSee) {
                    minotaurState = 'chasing';
                    minotaurLastSawPlayerTime = currentTime;
                    minotaurTargetCell = { 
                        x: Math.round(player.position.x / CELL_SIZE + currentMazeWidth / 2 - 0.5),
                        z: Math.round(player.position.z / CELL_SIZE + currentMazeHeight / 2 - 0.5)
                    };
                } else {
                    if (!minotaurTargetCell || (minotaurEnemy.userData.gridX === minotaurTargetCell.x && minotaurEnemy.userData.gridZ === minotaurTargetCell.z) || currentTime > minotaurPatrolNextTargetTime) {
                        minotaurTargetCell = findRandomPatrolTarget(minotaurEnemy.userData.gridX, minotaurEnemy.userData.gridZ);
                        minotaurPatrolNextTargetTime = currentTime + MINOTAUR_PATROL_NEW_TARGET_INTERVAL * (0.5 + Math.random()); 
                        if (!minotaurTargetCell) {
                            minotaurTargetCell = minotaurInitialGridPos; 
                        }
                    }
                }
            }
            
            let finalTargetPos; 
            if (minotaurState === 'chasing' && canSee && player) { 
                finalTargetPos = player.position.clone();
                 finalTargetPos.y = minotaurEnemy.position.y; 
            } else if (minotaurTargetCell) { 
                const targetWorldX = (minotaurTargetCell.x - currentMazeWidth / 2 + 0.5) * CELL_SIZE;
                const targetWorldZ = (minotaurTargetCell.z - currentMazeHeight / 2 + 0.5) * CELL_SIZE;
                finalTargetPos = new THREE.Vector3(targetWorldX, minotaurEnemy.position.y, targetWorldZ);
            }


            if (finalTargetPos) {
                const direction = finalTargetPos.clone().sub(minotaurEnemy.position);
                direction.y = 0; 
                const distanceToFinalTarget = direction.length();

                if (distanceToFinalTarget > 0.1) { 
                    direction.normalize();
                    const currentSpeed = (minotaurState === 'chasing') ? MINOTAUR_CHASE_SPEED : MINOTAUR_PATROL_SPEED;
                    
                    const moveStep = direction.clone().multiplyScalar(currentSpeed * deltaTime);
                    const nextPotentialPos = minotaurEnemy.position.clone().add(moveStep);
                    const nextGridX = Math.round(nextPotentialPos.x / CELL_SIZE + currentMazeWidth / 2 - 0.5);
                    const nextGridZ = Math.round(nextPotentialPos.z / CELL_SIZE + currentMazeHeight / 2 - 0.5);

                    let allowMove = true;
                    if (minotaurEnemy.userData.gridX !== nextGridX || minotaurEnemy.userData.gridZ !== nextGridZ) { 
                        if (!isCellWalkableForMinotaur(nextGridX, nextGridZ, currentMazeLayout, maze)) {
                            allowMove = false;
                            if (minotaurState === 'patrolling') {
                                minotaurTargetCell = null; 
                                minotaurPatrolNextTargetTime = currentTime;
                            } 
                        }
                    }

                    if (allowMove) {
                        minotaurEnemy.position.add(moveStep);
                    }
                    
                    const targetRotationY = Math.atan2(direction.x, direction.z);
                    let currentRotationY = minotaurEnemy.rotation.y;
                    
                    while (targetRotationY - currentRotationY > Math.PI) currentRotationY += 2 * Math.PI;
                    while (targetRotationY - currentRotationY < -Math.PI) currentRotationY -= 2 * Math.PI;
                    
                    minotaurEnemy.rotation.y = THREE.MathUtils.lerp(currentRotationY, targetRotationY, MINOTAUR_TURN_SPEED * deltaTime);

                } else { 
                    if (minotaurState === 'patrolling') minotaurTargetCell = null; 
                }
            }

            // Attack Check using Bounding Boxes
            if (player && minotaurEnemy && gameActive) { 
                playerCollisionBox.setFromCenterAndSize(player.position, new THREE.Vector3(PLAYER_RADIUS * 2, PLAYER_HEIGHT, PLAYER_RADIUS * 2));
                
                minotaurCollisionBox.setFromObject(minotaurEnemy); 
                minotaurCollisionBox.min.y = minotaurEnemy.position.y; 
                minotaurCollisionBox.max.y = minotaurEnemy.position.y + MINOTAUR_COLLISION_HEIGHT;

                if (playerCollisionBox.intersectsBox(minotaurCollisionBox)) {
                    loseGame("¡Atrapado por el Minotauro!");
                }
            }
        }
        function canMinotaurSeePlayer() {
            if (!minotaurEnemy || !player || !gameActive) return false;

            minotaurToPlayerVec.subVectors(player.position, minotaurEnemy.position);
            const distanceSq = minotaurToPlayerVec.lengthSq();

            if (distanceSq > MINOTAUR_VISION_RANGE_SQ) {
                return false; 
            }

            minotaurEnemy.getWorldDirection(minotaurForwardVec);
            minotaurForwardVec.y = 0; 
            minotaurForwardVec.normalize();

            const playerDir = minotaurToPlayerVec.clone().setY(0).normalize();
            const dot = minotaurForwardVec.dot(playerDir);

            if (dot < MINOTAUR_VISION_ANGLE_DOT) {
                return false; 
            }

            minotaurRaycaster.set(minotaurEnemy.position, minotaurToPlayerVec.normalize());
            minotaurRaycaster.far = Math.sqrt(distanceSq); 
            const wallObjects = collidableObjects.filter(obj => obj.userData.isWall);
            const intersects = minotaurRaycaster.intersectObjects(wallObjects, false);

            if (intersects.length > 0 && intersects[0].distance * intersects[0].distance < distanceSq - 0.1) { 
                 return false; 
            }
            return true;
        }
        function findRandomPatrolTarget(currentX, currentZ) {
            const possibleMoves = [];
            const directions = [{dx:0, dz:1}, {dx:0, dz:-1}, {dx:1, dz:0}, {dx:-1, dz:0}]; 

            for (const dir of directions) {
                const nextX = currentX + dir.dx;
                const nextZ = currentZ + dir.dz;
                if (isCellWalkableForMinotaur(nextX, nextZ, currentMazeLayout, maze)) { 
                    possibleMoves.push({ x: nextX, z: nextZ });
                }
            }

            if (possibleMoves.length > 0) {
                return possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
            }
            return null; 
        }

        function updateCamera() {
            if (!player || !camera) return;
            if (isFirstPersonView) {
                camera.position.copy(player.position);
                camera.position.y += PLAYER_HEIGHT * (FIRST_PERSON_EYE_HEIGHT_FACTOR - 0.5); 
                camera.rotation.order = 'YXZ';
                camera.rotation.y = cameraTheta;
                camera.rotation.x = cameraPhi - CAMERA_PITCH_OFFSET_FPS;
                camera.rotation.z = 0;
                camera.updateMatrixWorld(); 

                for (const obj of currentlyTransparentObjects) {
                    if (obj.material && typeof obj.material.opacity !== 'undefined' && obj.userData.isTransparentCapable) {
                        obj.material.transparent = false;
                        obj.material.opacity = obj.userData.originalOpacity || 1.0;
                    }
                }
                currentlyTransparentObjects.clear();
            } else { 
                const targetPosition = new THREE.Vector3();
                const offset = new THREE.Vector3();
                offset.x = CAMERA_DISTANCE * Math.sin(cameraPhi) * Math.sin(cameraTheta);
                offset.y = CAMERA_DISTANCE * Math.cos(cameraPhi) + CAMERA_HEIGHT_OFFSET;
                offset.z = CAMERA_DISTANCE * Math.sin(cameraPhi) * Math.cos(cameraTheta);

                targetPosition.copy(player.position).add(offset);

                const cameraRaycaster = new THREE.Raycaster();
                const rayOrigin = player.position.clone().add(new THREE.Vector3(0, PLAYER_HEIGHT * 0.3, 0)); 
                const directionToCamera = targetPosition.clone().sub(rayOrigin).normalize();
                const rayLength = rayOrigin.distanceTo(targetPosition);

                cameraRaycaster.set(rayOrigin, directionToCamera);
                cameraRaycaster.far = rayLength;

                const cameraCheckObjects = collidableObjects.filter(obj =>
                    obj !== player &&
                    !obj.userData.isFloorTile && 
                    obj.userData.isTransparentCapable &&
                    !(obj.userData.isPitTrapCover && !obj.userData.isCollidable) &&
                    !(obj.userData.isFallingBlock && obj.userData.state !== 'landed') && 
                    obj !== minotaurCollisionCylinder 
                );

                const intersects = cameraRaycaster.intersectObjects(cameraCheckObjects, false);

                let objectsToMakeTransparentThisFrame = new Set();
                for (const intersect of intersects) {
                    if (intersect.object.userData.isTransparentCapable) {
                        objectsToMakeTransparentThisFrame.add(intersect.object);
                    }
                }

                for (const obj of currentlyTransparentObjects) {
                    if (!objectsToMakeTransparentThisFrame.has(obj)) {
                        if (obj.material && typeof obj.material.opacity !== 'undefined' && obj.userData.isTransparentCapable) {
                            obj.material.transparent = false;
                            obj.material.opacity = obj.userData.originalOpacity || 1.0;
                        }
                    }
                }
                for (const obj of objectsToMakeTransparentThisFrame) {
                    if (obj.material && typeof obj.material.opacity !== 'undefined' && obj.userData.isTransparentCapable) {
                        obj.material.transparent = true;
                        obj.material.opacity = OBSTACLE_OPACITY;
                    }
                }
                currentlyTransparentObjects = objectsToMakeTransparentThisFrame;

                let finalCameraPosition = targetPosition.clone();
                if (intersects.length > 0) {
                    let closestDistance = rayLength;
                    for (const intersect of intersects) {
                        if (intersect.distance < closestDistance) {
                            closestDistance = intersect.distance;
                        }
                    }
                    finalCameraPosition.copy(rayOrigin).addScaledVector(directionToCamera, Math.max(0.5, closestDistance - 0.3)); 
                }

                finalCameraPosition.y = Math.max(finalCameraPosition.y, player.position.y + MIN_CAMERA_Y_ABOVE_GROUND); 
                camera.position.copy(finalCameraPosition);

                const lookAtTarget = player.position.clone().add(new THREE.Vector3(0, PLAYER_HEIGHT * 0.3, 0)); 
                camera.lookAt(lookAtTarget);
            }
        }
        function drawMinimap() {
            if (!minimapCtx || !player || !currentMazeLayout.length || !visibilityMaze.length || !currentMazeWidth || !currentMazeHeight) return;
            const playerGridX = Math.round(player.position.x / CELL_SIZE + currentMazeWidth / 2 - 0.5);
            const playerGridZ = Math.round(player.position.z / CELL_SIZE + currentMazeHeight / 2 - 0.5);
            minimapCtx.clearRect(0, 0, minimapWidth, minimapHeight); minimapCtx.save(); minimapCtx.translate(minimapWidth / 2, minimapHeight / 2); minimapCtx.rotate(cameraTheta);
            const radius = MINIMAP_RADIUS_CELLS; const cellSizePx = MINIMAP_CELL_SIZE_PX;

            for (let relZ = -radius; relZ <= radius; relZ++) {
                for (let relX = -radius; relX <= radius; relX++) {
                    const checkX = playerGridX + relX; const checkZ = playerGridZ + relZ;
                    let fillColor;
                    if (!visibilityMaze[checkZ] || typeof visibilityMaze[checkZ][checkX] === 'undefined' || !visibilityMaze[checkZ][checkX]) {
                        fillColor = MINIMAP_UNSEEN_COLOR;
                    } else {
                        if (checkX < 0 || checkX >= currentMazeWidth || checkZ < 0 || checkZ >= currentMazeHeight) {
                            fillColor = MINIMAP_UNSEEN_COLOR;
                        } else {
                            const cellTypeInLayout = currentMazeLayout[checkZ][checkX];
                            const originalCellType = maze[checkZ][checkX]; 

                            if (cellTypeInLayout === 0) fillColor = MINIMAP_WALL_COLOR;
                            else if (cellTypeInLayout === LAVA_CELL_TYPE) fillColor = MINIMAP_LAVA_COLOR; 
                            else if (cellTypeInLayout === BROKEN_PIT_TRAP_CELL_TYPE_LAYOUT) fillColor = MINIMAP_PITTRAP_BROKEN_COLOR;
                            else if (cellTypeInLayout === END_CELL_TERMINATE) fillColor = MINIMAP_END_COLOR;
                            else if (cellTypeInLayout === END_CELL_SPECIFIC_NEXT) fillColor = MINIMAP_END_LINK_COLOR;
                            else if (originalCellType === PIT_TRAP_CELL_TYPE ||
                                     originalCellType === FALLING_BLOCK_TRAP_CELL_TYPE ||
                                     originalCellType === SPIKE_TRAP_CELL_TYPE ||
                                     originalCellType === MINOTAUR_CELL_TYPE) {
                                // Traps (even intact) and Minotaur spawn point are shown as path if revealed by player
                                const trapObject = pitTrapObjects.find(t => t.gridX === checkX && t.gridZ === checkZ);
                                if (trapObject && trapObject.hasBeenRevealedByActivation && cellTypeInLayout === PIT_TRAP_CELL_TYPE && trapObject.state !== 'broken') {
                                     fillColor = MINIMAP_PITTRAP_INTACT_COLOR; // Show intact pit if activated but not broken
                                } else {
                                     fillColor = MINIMAP_PATH_COLOR;
                                }
                            }
                            else fillColor = MINIMAP_PATH_COLOR; // Default path
                        }
                    }
                    minimapCtx.fillStyle = fillColor;
                    const drawX = relX * cellSizePx - cellSizePx / 2; const drawY = relZ * cellSizePx - cellSizePx / 2;
                    minimapCtx.fillRect(drawX, drawY, cellSizePx, cellSizePx);
                }
            }
            minimapCtx.restore(); minimapCtx.beginPath(); const playerMarkerSize = cellSizePx * 0.9; const halfSize = playerMarkerSize / 2; minimapCtx.moveTo(minimapWidth / 2, minimapHeight / 2 - halfSize * 0.8); minimapCtx.lineTo(minimapWidth / 2 - halfSize * 0.6, minimapHeight / 2 + halfSize * 0.5); minimapCtx.lineTo(minimapWidth / 2 + halfSize * 0.6, minimapHeight / 2 + halfSize * 0.5); minimapCtx.closePath(); minimapCtx.fillStyle = MINIMAP_PLAYER_COLOR; minimapCtx.fill();
        }
        function hasLineOfSight(x0, z0, x1, z1) { let dx = Math.abs(x1 - x0); let sx = x0 < x1 ? 1 : -1; let dz = -Math.abs(z1 - z0); let sz = z0 < z1 ? 1 : -1; let err = dx + dz; let currentX = x0; let currentZ = z0; let steps = 0; const maxSteps = currentMazeWidth + currentMazeHeight; while (steps < maxSteps) { steps++; if (currentX === x1 && currentZ === z1) return true; if (!(currentX === x0 && currentZ === z0)) { if (currentX >= 0 && currentX < currentMazeWidth && currentZ >= 0 && currentZ < currentMazeHeight) { if (currentMazeLayout[currentZ][currentX] === 0 && maze[currentZ][currentX] === 0) { if (visibilityMaze[currentZ] && typeof visibilityMaze[currentZ][currentX] !== 'undefined') { visibilityMaze[currentZ][currentX] = true; } return false; } } else { return false; } } let e2 = 2 * err; let moved = false; if (e2 >= dz) { if (currentX === x1 && currentZ === z1 && !(currentX === x0 && currentZ === z0)) break; err += dz; currentX += sx; moved = true; } if (e2 <= dx) { if (currentX === x1 && currentZ === z1 && !(currentX === x0 && currentZ === z0)) break; err += dx; currentZ += sz; moved = true; } if (!moved && (currentX !== x1 || currentZ !== z1)) { return false; } } return (currentX === x1 && currentZ === z1); }
        function updateVisibility() {
            if (!player || !visibilityMaze.length || !currentMazeLayout.length || !currentMazeWidth || !currentMazeHeight) return;
            const playerGridX = Math.round(player.position.x / CELL_SIZE + currentMazeWidth / 2 - 0.5);
            const playerGridZ = Math.round(player.position.z / CELL_SIZE + currentMazeHeight / 2 - 0.5);
            const visionRadius = PLAYER_VISION_RADIUS_CELLS;

            if (playerGridX >= 0 && playerGridX < currentMazeWidth && playerGridZ >= 0 && playerGridZ < currentMazeHeight) {
                if(visibilityMaze[playerGridZ]) visibilityMaze[playerGridZ][playerGridX] = true;
            }
            for (let relZ = -visionRadius; relZ <= visionRadius; relZ++) {
                for (let relX = -visionRadius; relX <= visionRadius; relX++) {
                    if (relX === 0 && relZ === 0) continue;
                    if (relX * relX + relZ * relZ <= visionRadius * visionRadius) {
                        const checkX = playerGridX + relX; const checkZ = playerGridZ + relZ;
                        if (checkX >= 0 && checkX < currentMazeWidth && checkZ >= 0 && checkZ < currentMazeHeight) {
                            if (hasLineOfSight(playerGridX, playerGridZ, checkX, checkZ)) {
                                if(visibilityMaze[checkZ]) visibilityMaze[checkZ][checkX] = true;
                            }
                        }
                    }
                }
            }
        }

        function spawnSmokeParticle() {
            if (smokeParticles.length >= MAX_SMOKE_PARTICLES) return;
            if (!spearFlameMesh || !gameActive || !player) return;

            spearLightAndFlameGroup.getWorldPosition(smokeSpawnPosition); 

            const particle = new THREE.Mesh(smokeParticleGeometry, smokeParticleMaterial.clone()); 
            particle.position.copy(smokeSpawnPosition);
            particle.position.y += SPEAR_FLAME_SIZE * 0.5; 

            particle.userData.life = 0;
            particle.userData.maxLife = SMOKE_PARTICLE_MIN_LIFE + Math.random() * (SMOKE_PARTICLE_MAX_LIFE - SMOKE_PARTICLE_MIN_LIFE);
            
            const playerWorldDir = new THREE.Vector3();
            player.getWorldDirection(playerWorldDir);

            particle.userData.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.15,  
                0.5 + Math.random() * 0.3,    
                (Math.random() - 0.5) * 0.15   
            );
            particle.userData.velocity.x -= playerVelocity.x * 0.05; 
            particle.userData.velocity.z -= playerVelocity.z * 0.05; 


            scene.add(particle);
            smokeParticles.push(particle);
        }

        function updateSmokeParticles(deltaTime) {
            for (let i = smokeParticles.length - 1; i >= 0; i--) {
                const p = smokeParticles[i];
                p.userData.life += deltaTime;

                if (p.userData.life >= p.userData.maxLife) {
                    scene.remove(p);
                    if (p.material) p.material.dispose(); 
                    smokeParticles.splice(i, 1);
                    continue;
                }

                p.position.addScaledVector(p.userData.velocity, deltaTime);
                p.userData.velocity.y += 0.20 * deltaTime; 
                
                const lifeRatio = p.userData.life / p.userData.maxLife;
                p.material.opacity = SMOKE_PARTICLE_START_OPACITY * (1 - lifeRatio);
                
                const currentScale = SMOKE_PARTICLE_START_SIZE + (SMOKE_PARTICLE_END_SIZE - SMOKE_PARTICLE_START_SIZE) * lifeRatio;
                p.scale.set(currentScale, currentScale, currentScale);
            }

            if(playerOnGround && (Math.abs(playerVelocity.x) > 0.1 || Math.abs(playerVelocity.z) > 0.1 ) ){
                timeSinceLastSmokeSpawn += deltaTime;
                if (timeSinceLastSmokeSpawn > SMOKE_SPAWN_INTERVAL) {
                    spawnSmokeParticle();
                    timeSinceLastSmokeSpawn = 0;
                }
            }
        }


        let animationFrameId;
        function animate() {
            if (!gameActive && !TWEEN.getAll().length && playerFallingIntoPit === null) {
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                return;
            }
            animationFrameId = requestAnimationFrame(animate);
            const dT = Math.min(0.05, clock.getDelta());
            TWEEN.update();

            if (playerMixer && (gameActive || playerFallingIntoPit !== null)) {
                playerMixer.update(dT);
            }

            if (gameActive || playerFallingIntoPit !== null) {
                updatePlayer(dT); 
                if (minotaurEnemy && (gameActive || playerFallingIntoPit !== null) ) updateMinotaur(dT); 
            }


            if (gameActive) {
                const flicker = (Math.random() - 0.5) * TORCH_FLICKER_AMOUNT;
                if (spearLight && spearLight.userData.baseIntensity) { 
                     if (isFirstPersonView) {
                         spearLight.intensity = Math.max(0, (SPEAR_LIGHT_INTENSITY * 0.3) + flicker * 0.5); 
                     } else {
                         spearLight.intensity = Math.max(0, spearLight.userData.baseIntensity + flicker * 1.2);
                     }
                }

                if (spearFlameMesh && spearFlameMesh.material) { 
                    const pVO = (Math.random()-0.5)*FLAME_OPACITY_VAR * 1.1; 
                    const pVS = (Math.random()-0.5)*FLAME_SCALE_Y_VAR * 1.1; 
                    spearFlameMesh.material.opacity = Math.max(0.2,Math.min(1.0, FLAME_BASE_OPACITY + pVO)); 
                    const scaleMultiplier = Math.max(0.3, 1.0 + pVS);
                    spearFlameMesh.scale.set(scaleMultiplier * 0.7, scaleMultiplier, scaleMultiplier*0.7); 
                }

                for (const torch of staticTorches) { 
                    const sLF = (Math.random()-0.5)*TORCH_FLICKER_AMOUNT*1.1; 
                    const vO = (Math.random()-0.5)*FLAME_OPACITY_VAR; 
                    const vS = (Math.random()-0.5)*FLAME_SCALE_Y_VAR; 
                    if (torch.light?.userData.baseIntensity) { 
                        torch.light.intensity = Math.max(0, torch.light.userData.baseIntensity + sLF); 
                    } 
                    if (torch.flameMesh?.material) { 
                        torch.flameMesh.material.opacity = Math.max(0.1,Math.min(1.0,FLAME_BASE_OPACITY+vO)); 
                        torch.flameMesh.scale.y = Math.max(0.1,FLAME_BASE_SCALE_Y+vS); 
                        torch.flameMesh.scale.x = torch.flameMesh.scale.z = Math.max(0.1,FLAME_BASE_SCALE_Y*0.8 + vS * 0.5); 
                    } 
                }
                if (minotaurTorch && minotaurTorch.light && minotaurTorch.flameMesh) {
                    const mFlicker = (Math.random() - 0.5) * TORCH_FLICKER_AMOUNT * 0.9;
                    minotaurTorch.light.intensity = Math.max(0, MINOTAUR_TORCH_LIGHT_INTENSITY + mFlicker);
                    
                    const mVO = (Math.random() - 0.5) * FLAME_OPACITY_VAR * 0.8;
                    const mVS = (Math.random() - 0.5) * FLAME_SCALE_Y_VAR * 0.8;
                    minotaurTorch.flameMesh.material.opacity = Math.max(0.2, Math.min(1.0, FLAME_BASE_OPACITY * 0.8 + mVO));
                    minotaurTorch.flameMesh.scale.y = Math.max(0.3, 1.0 + mVS);
                    minotaurTorch.flameMesh.scale.x = minotaurTorch.flameMesh.scale.z = Math.max(0.3, (1.0 + mVS) * 0.7);
                }

                for (const lavaCell of lavaCells) {
                    if (lavaCell.mesh.material.map) {
                        lavaCell.mesh.material.map.offset.x += LAVA_FLOW_SPEED_U;
                        lavaCell.mesh.material.map.offset.y += LAVA_FLOW_SPEED_V;
                        if (lavaCell.mesh.material.map.offset.x > 1) lavaCell.mesh.material.map.offset.x -= 1;
                        if (lavaCell.mesh.material.map.offset.y > 1) lavaCell.mesh.material.map.offset.y -= 1;
                    }
                    if (lavaCell.light) {
                        lavaCell.light.intensity = Math.max(0, lavaCell.light.userData.baseIntensity + (Math.random() - 0.5) * TORCH_FLICKER_AMOUNT * 0.3);
                    }
                }


                updateSmokeParticles(dT);
            }
            updateCamera();
            updateVisibility();
            drawMinimap();

            if(renderer && scene && camera) renderer.render(scene, camera);
        }
        function onWindowResize() { updateRendererAndCameraSize(); }
        let messageTimeout = null; function showMessage(text, duration = 2500) { if (messageTimeout) clearTimeout(messageTimeout); messageDiv.textContent = text; messageDiv.style.display = 'block'; messageTimeout = setTimeout(() => { messageDiv.style.display = 'none'; messageTimeout = null; }, duration); }
        function winGame(endCellType = END_CELL_TERMINATE, endCellX = -1, endCellZ = -1) {
            if (!gameActive) return;
            gameActive = false;
            TWEEN.removeAll();

            console.log("Juego ganado! Tipo de fin:", endCellType, "en celda:", endCellX, ",", endCellZ);
            if (isPointerLocked && document.pointerLockElement) document.exitPointerLock();

            if (endCellType === END_CELL_SPECIFIC_NEXT) {
                showMessage("¡Portal Activado!", 2000);

                const nextScenarioNameToLoad = currentPlayingScenarioData?.specificNextScenarioName;
                const canTransition = !!nextScenarioNameToLoad;

                if (canTransition) {
                    setTimeout(async () => {
                        const scenarios = await getAllScenariosDB();
                        const scenarioToPlay = scenarios.find(s => s.name === nextScenarioNameToLoad);

                        if (scenarioToPlay) {
                            if (nextScenarioSelectionScreen) nextScenarioSelectionScreen.style.display = 'none';
                            if(loadingTextElement) loadingTextElement.style.display = 'block';
                            if(loadingScreenElement) loadingScreenElement.style.display = 'flex';

                            cleanUpScene();
                            preloadAssets(() => { 
                                selectTexturesForScenario(scenarioToPlay.textures);
                                currentPlayingScenarioData = JSON.parse(JSON.stringify(scenarioToPlay));
                                init(scenarioToPlay);
                                finalizeLoadingScreen();
                            });
                        } else {
                            alert(`Error: No se pudo encontrar el escenario de destino llamado "${nextScenarioNameToLoad}". Volviendo al menú.`);
                            window.location.reload(); 
                        }
                    }, 1500);
                } else {
                    console.warn("Fin específico activado, pero no se encontró nombre de escenario de destino válido para el nivel actual. Terminando partida.");
                    showMessage("¡HAS ESCAPADO!", 10000);
                    setTimeout(() => { window.location.reload(); }, 5000);
                }
            } else { 
                showMessage("¡HAS ESCAPADO!", 10000);
                setTimeout(() => {
                    window.location.reload();
                }, 5000);
            }
        }
        function loseGame(reason = "Has perdido.") {
            if (!gameActive && playerFallingIntoPit === null) return; 
            gameActive = false; // Set gameActive false immediately

            showMessage(reason, 3000);
            console.log("Juego perdido:", reason);
            if (isPointerLocked && document.pointerLockElement) document.exitPointerLock();

            if (bloodSplatterTexture && player && scene) { 
                const playerGridX = Math.floor((player.position.x / CELL_SIZE) + (currentMazeWidth / 2));
                const playerGridZ = Math.floor((player.position.z / CELL_SIZE) + (currentMazeHeight / 2));

                if (playerGridX >= 0 && playerGridX < currentMazeWidth && playerGridZ >= 0 && playerGridZ < currentMazeHeight) {
                    const worldX = (playerGridX - currentMazeWidth / 2 + 0.5) * CELL_SIZE;
                    const worldZ = (playerGridZ - currentMazeHeight / 2 + 0.5) * CELL_SIZE;
                    
                    let groundLevelForSplatter = 0.01; // Default for normal ground
                    if (currentMazeLayout[playerGridZ] && currentMazeLayout[playerGridZ][playerGridX] === LAVA_CELL_TYPE) {
                        groundLevelForSplatter = LAVA_SURFACE_OFFSET_Y + 0.01; // On lava surface
                    }


                    const splatterGeometry = new THREE.PlaneGeometry(CELL_SIZE * 0.9, CELL_SIZE * 0.9);
                    const splatterMaterial = new THREE.MeshBasicMaterial({
                        map: bloodSplatterTexture,
                        transparent: true,
                        opacity: 0.75, 
                        depthWrite: false, 
                        blending: THREE.NormalBlending 
                    });
                    const splatterMesh = new THREE.Mesh(splatterGeometry, splatterMaterial);
                    splatterMesh.position.set(worldX, groundLevelForSplatter, worldZ); 
                    splatterMesh.rotation.x = -Math.PI / 2;
                    splatterMesh.rotation.z = Math.random() * Math.PI * 2; 
                    scene.add(splatterMesh);
                    bloodSplatters.push(splatterMesh); 
                }
            }


            setTimeout(() => {
                // Reset player
                player.position.copy(initialPlayerPosition);
                playerVelocity.set(0, 0, 0);
                playerOnGround = true;
                playerFallingIntoPit = null;
                moveForward = 0;
                moveRight = 0;
                keyStates = {};
                cameraPhi = Math.PI / 3;
                cameraTheta = player.rotation.y - Math.PI; 
                updateCamera();

                if (playerMixer) {
                    playerMixer.stopAllAction(); 
                    if (idleAction) {
                        idleAction.reset().fadeIn(0.1).play(); 
                        currentAction = idleAction;
                    } else {
                        currentAction = null;
                    }
                }
                
                // Reset Minotaur
                if (minotaurEnemy && minotaurInitialGridPos) {
                    const initialWorldX = (minotaurInitialGridPos.x - currentMazeWidth / 2 + 0.5) * CELL_SIZE;
                    const initialWorldZ = (minotaurInitialGridPos.z - currentMazeHeight / 2 + 0.5) * CELL_SIZE;
                    
                    if (minotaurModelGLB) { 
                        const tempModelForBBoxReset = minotaurModelGLB.clone(); 
                        const originalBBoxReset = new THREE.Box3().setFromObject(tempModelForBBoxReset);
                        const originalSizeReset = new THREE.Vector3();
                        originalBBoxReset.getSize(originalSizeReset);
                        const originalMinYReset = originalBBoxReset.min.y;

                        console.log(`%cRESET: Minotaur (monster1.glb) Original - Size: W ${originalSizeReset.x.toFixed(3)}, H ${originalSizeReset.y.toFixed(3)}, D ${originalSizeReset.z.toFixed(3)} | MinY: ${originalMinYReset.toFixed(3)}`, "color:lightblue;");
                        console.log(`%cRESET: MINOTAUR_TARGET_HEIGHT: ${MINOTAUR_TARGET_HEIGHT.toFixed(3)}`, "color:lightgreen;");

                        let scaleFactorReset = 1.0;
                        if (originalSizeReset.y > 0.01) {
                            scaleFactorReset = MINOTAUR_TARGET_HEIGHT / originalSizeReset.y;
                        } else {
                             console.warn("RESET: Minotaur model original height is very small or zero. Using scale factor 1.");
                        }
                        console.log(`%cRESET: Calculated scaleFactor: ${scaleFactorReset.toFixed(3)}`, "color:lightgreen;");
                        minotaurEnemy.scale.set(scaleFactorReset, scaleFactorReset, scaleFactorReset); // Apply scale to the existing minotaurEnemy instance
                        console.log(`%cRESET: Minotaur re-scaled. Actual minotaurEnemy.scale: (${minotaurEnemy.scale.x.toFixed(3)}, ${minotaurEnemy.scale.y.toFixed(3)}, ${minotaurEnemy.scale.z.toFixed(3)})`, "color:orange;");

                        const worldPosYForMinotaurOriginReset = -(originalMinYReset * scaleFactorReset);
                        minotaurEnemy.position.set(initialWorldX, worldPosYForMinotaurOriginReset, initialWorldZ);
                        console.log(`%cRESET: Minotaur re-positioned. Model origin at world Y: ${worldPosYForMinotaurOriginReset.toFixed(3)}`, "color:orange;");
                    } else { 
                        minotaurEnemy.position.set(initialWorldX, MINOTAUR_COLLISION_HEIGHT / 2, initialWorldZ); 
                    }

                    minotaurEnemy.rotation.y = 0; 
                    minotaurState = 'patrolling';
                    minotaurTargetCell = null;
                    minotaurLastSawPlayerTime = 0;
                    minotaurPatrolNextTargetTime = clock.elapsedTime * 1000;
                }

                // Reset Traps
                for (const trap of pitTrapObjects) {
                    if (trap.state === 'broken' || trap.state === 'breaking') {
                        trap.state = 'intact';
                        currentMazeLayout[trap.gridZ][trap.gridX] = PIT_TRAP_CELL_TYPE;
                        if (trap.mesh) {
                            trap.mesh.visible = true;
                            trap.mesh.userData.isCollidable = true;
                            trap.mesh.position.set(trap.worldX, -PIT_COVER_THICKNESS / 2, trap.worldZ);
                            trap.mesh.rotation.set(0, 0, 0);
                            if (floorTexture && trap.mesh.material.map !== floorTexture) { 
                                const originalCoverMaterial = new THREE.MeshStandardMaterial({
                                    map: floorTexture.clone(),
                                    roughness: 0.95, metalness: 0.1,
                                    color: floorTexture ? 0xffffff : 0x444038
                                });
                                if (originalCoverMaterial.map) {
                                    originalCoverMaterial.map.needsUpdate = true;
                                    originalCoverMaterial.map.repeat.set(1,1);
                                }
                                trap.mesh.material = originalCoverMaterial;
                            }
                        }
                        if (trap.holeMesh) {
                            trap.holeMesh.visible = false;
                        }
                    }
                     trap.hasBeenRevealedByActivation = false; 
                }
                for (const trap of fallingBlockTrapObjects) {
                     if (trap.state === 'falling' || trap.state === 'landed') {
                        trap.state = 'armed';
                        if (trap.blockMesh) { 
                             trap.blockMesh.visible = false;
                             trap.blockMesh.position.y = WALL_HEIGHT + WALL_HEIGHT * 0.45; 
                             const colIndex = collidableObjects.indexOf(trap.blockMesh);
                             if (colIndex > -1) collidableObjects.splice(colIndex, 1);
                        }
                         currentMazeLayout[trap.triggerCellZ][trap.triggerCellX] = FALLING_BLOCK_TRAP_CELL_TYPE;
                    }
                    trap.hasBeenRevealedByActivation = false; 
                }
                for (const trap of spikeTrapObjects) {
                     if (trap.state === 'rising' || trap.state === 'risen') {
                        trap.state = 'hidden';
                        if (trap.spikeGroup) {
                            trap.spikeGroup.visible = false;
                            trap.spikeGroup.children.forEach(spike => {
                                spike.position.y = -SPIKE_HEIGHT / 2;
                            });
                        }
                         currentMazeLayout[trap.triggerCellZ][trap.triggerCellX] = SPIKE_TRAP_CELL_TYPE;
                    }
                    trap.hasBeenRevealedByActivation = false; 
                }
                TWEEN.removeAll();


                gameActive = true; 
                if (!animationFrameId && TWEEN.getAll().length === 0) { 
                     animate();
                }
                showMessage("Inténtalo de nuevo...", 2000);
            }, 3000);
        }
        function updateRendererAndCameraSize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            let maxDim = Math.max(width, height);
            let currentMaxRes = isTouchDevice ? MAX_RESOLUTION_DIMENSION_MOBILE : MAX_RESOLUTION_DIMENSION;

            const scaleFactor = maxDim > currentMaxRes ? currentMaxRes / maxDim : 1;
            const renderWidth = Math.floor(width * scaleFactor);
            const renderHeight = Math.floor(height * scaleFactor);

            if(renderer && camera) {
                renderer.setSize(renderWidth, renderHeight, false);
                renderer.domElement.style.width = '100%';
                renderer.domElement.style.height = '100%';
                camera.aspect = renderWidth / renderHeight;
                camera.updateProjectionMatrix();
            }
        }
        function populateTextureSelectors() {
            const selectorsData = [
                { id: 'wall-texture-select', previewId: 'wall-texture-preview' },
                { id: 'floor-texture-select', previewId: 'floor-texture-preview' },
                { id: 'ceiling-texture-select', previewId: 'ceiling-texture-preview' }
            ];

            selectorsData.forEach(data => {
                const selectElement = document.getElementById(data.id);
                const previewElement = document.getElementById(data.previewId);
                if (!selectElement || !previewElement) return;

                selectElement.innerHTML = '<option value="-1" data-url="">Aleatorio</option>';
                textureURLs.forEach((url, index) => {
                    if (url.includes("textura_lava1.jpg")) return; 
                    const option = document.createElement('option');
                    option.value = index;
                    option.textContent = `Textura ${index + 1}`;
                    option.dataset.url = url;
                    selectElement.appendChild(option);
                });

                selectElement.addEventListener('change', function() {
                    const selectedOption = this.options[this.selectedIndex];
                    const textureUrl = selectedOption.dataset.url;
                    if (textureUrl) {
                        previewElement.src = textureUrl;
                        previewElement.style.display = 'inline-block';
                    } else {
                        previewElement.src = '';
                        previewElement.style.display = 'none';
                    }
                });
                if (selectElement.value !== "-1" && selectElement.options[selectElement.selectedIndex]) {
                     const initialUrl = selectElement.options[selectElement.selectedIndex].dataset.url;
                     if (initialUrl) {
                         previewElement.src = initialUrl;
                         previewElement.style.display = 'inline-block';
                     } else {
                         previewElement.src = '';
                         previewElement.style.display = 'none';
                     }
                } else {
                     previewElement.src = '';
                     previewElement.style.display = 'none';
                }

            });
        }
        async function populateSpecificNextScenarioSelector() {
            if (!specificNextScenarioSelect) return;

            const previouslySelectedId = specificNextScenarioSelect.value;
            specificNextScenarioSelect.innerHTML = '<option value="">-- Seleccionar Escenario --</option>';

            try {
                const scenarios = await getAllScenariosDB();
                scenarios.forEach(s => {
                    if (currentEditingScenario && currentEditingScenario.id === s.id) {
                        return;
                    }
                    const option = document.createElement('option');
                    option.value = s.id;
                    option.textContent = s.name;
                    specificNextScenarioSelect.appendChild(option);
                });
                if (previouslySelectedId && specificNextScenarioSelect.querySelector(`option[value="${previouslySelectedId}"]`)) {
                    specificNextScenarioSelect.value = previouslySelectedId;
                } else if (currentEditingScenario && currentEditingScenario.specificNextScenarioName) {
                    const targetScenario = scenarios.find(s => s.name === currentEditingScenario.specificNextScenarioName);
                    if (targetScenario) {
                        specificNextScenarioSelect.value = targetScenario.id;
                    }
                }


            } catch (error) {
                console.error("Error al poblar selector de escenarios específicos:", error);
            }
        }
        function updateTexturePreview(selectId, previewId, textureIndex) {
            const selectElement = document.getElementById(selectId);
            const previewElement = document.getElementById(previewId);
            if (!selectElement || !previewElement) return;

            if (textureIndex !== -1 && textureURLs[textureIndex] && !textureURLs[textureIndex].includes("textura_lava1.jpg")) {
                previewElement.src = textureURLs[textureIndex];
                previewElement.style.display = 'inline-block';
            } else {
                previewElement.src = '';
                previewElement.style.display = 'none';
            }
            selectElement.value = textureIndex;
        }
        function cleanUpScene() {
            if (scene) {
                while(scene.children.length > 0){
                    const object = scene.children[0];
                    if(object.geometry) object.geometry.dispose();
                    if(object.material){
                        if(Array.isArray(object.material)){
                            object.material.forEach(material => material.dispose());
                        } else {
                            object.material.dispose();
                        }
                    }
                     if (object.traverse) { 
                        object.traverse(child => {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(m => m.dispose());
                                } else {
                                    child.material.dispose();
                                }
                            }
                        });
                    }
                    scene.remove(object);
                }
            }
            collidableObjects = [];
            interactiveObjects = [];
            staticTorches = [];
            lavaCells = []; 
            pitTrapObjects = [];
            fallingBlockTrapObjects = [];
            spikeTrapObjects = [];
            minotaurEnemy = null;
            minotaurCollisionCylinder = null; 
            endZones = [];
            minotaurTorch = null; 
            
            bloodSplatters.forEach(splatter => { 
                if (splatter.geometry) splatter.geometry.dispose();
                if (splatter.material) splatter.material.dispose();
            });
            bloodSplatters = [];


            smokeParticles.forEach(p => { 
                if (p.material) p.material.dispose();
            });
            smokeParticles = [];

        }
        async function displayNextScenarioSelection() {
            try {
                const scenarios = await getAllScenariosDB();
                nextScenarioListUL.innerHTML = '';
                if (scenarios && scenarios.length > 0) {
                    noNextScenariosMsg.style.display = 'none';
                    scenarios.forEach(scenario => {
                        const listItem = document.createElement('li');
                        listItem.classList.add('scenario-item');
                        listItem.innerHTML = `
                            <div class="scenario-info">
                                <span>${escapeHTML(scenario.name)} (${scenario.width}x${scenario.height})</span>
                            </div>
                            <div class="scenario-actions">
                                <button class="action-btn play-this-scenario-btn" data-id="${scenario.id}">Jugar este</button>
                            </div>
                        `;
                        listItem.querySelector('.play-this-scenario-btn').addEventListener('click', async () => {
                            const scenarioId = parseInt(scenario.id);
                            const scenarioToPlay = await getScenarioByIdDB(scenarioId);
                            if (scenarioToPlay) {
                                nextScenarioSelectionScreen.style.display = 'none';
                                if(loadingTextElement) loadingTextElement.style.display = 'block';
                                if(loadingScreenElement) loadingScreenElement.style.display = 'flex';

                                cleanUpScene();
                                preloadAssets(() => { 
                                    selectTexturesForScenario(scenarioToPlay.textures);
                                    currentPlayingScenarioData = JSON.parse(JSON.stringify(scenarioToPlay));
                                    init(scenarioToPlay);
                                    finalizeLoadingScreen();
                                });
                            } else {
                                alert("Error: No se pudo cargar el escenario seleccionado.");
                            }
                        });
                        nextScenarioListUL.appendChild(listItem);
                    });
                    nextScenarioSelectionScreen.style.display = 'flex';
                } else {
                    noNextScenariosMsg.style.display = 'block';
                    nextScenarioSelectionScreen.style.display = 'flex';
                }
            } catch (error) { console.error("Error cargando escenarios para la selección:", error); noNextScenariosMsg.textContent = "Error cargando escenarios."; noNextScenariosMsg.style.display = 'block'; nextScenarioSelectionScreen.style.display = 'flex'; }
        }
        function showCustomGameUI() { gameActive = false; if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null;} if (isPointerLocked && document.pointerLockElement) document.exitPointerLock(); if(startOptionsDiv) startOptionsDiv.style.display = 'none'; if(loadingTextElement) loadingTextElement.style.display = 'none'; if(loadingScreenElement) loadingScreenElement.style.display = 'none'; customGameScreen.style.display = 'flex'; scenarioEditorScreen.style.display = 'none'; nextScenarioSelectionScreen.style.display = 'none'; loadAndDisplayCustomScenarios(); }
        backToMainMenuBtn.addEventListener('click', () => { customGameScreen.style.display = 'none'; nextScenarioSelectionScreen.style.display = 'none'; if(loadingScreenElement) loadingScreenElement.style.display = 'flex'; if(startOptionsDiv) startOptionsDiv.style.display = 'flex'; });
        cancelNextScenarioBtn.addEventListener('click', () => {
            nextScenarioSelectionScreen.style.display = 'none';
            if(loadingScreenElement) loadingScreenElement.style.display = 'flex';
            if(startOptionsDiv) startOptionsDiv.style.display = 'flex';
        });
        async function loadAndDisplayCustomScenarios() {
            try {
                const scenarios = await getAllScenariosDB();
                customScenarioListUL.innerHTML = '';
                if (scenarios && scenarios.length > 0) {
                    noCustomScenariosMsg.style.display = 'none';
                    scenarios.forEach(scenario => {
                        const listItem = document.createElement('li');
                        listItem.classList.add('scenario-item');
                        listItem.dataset.id = scenario.id;
                        listItem.innerHTML = `
                            <div class="scenario-preview" id="preview-${scenario.id}"></div>
                            <div class="scenario-info">
                                <span>${escapeHTML(scenario.name)} (${scenario.width}x${scenario.height})</span>
                            </div>
                            <div class="scenario-actions">
                                <button class="action-btn play-scenario-btn">Jugar</button>
                                <button class="action-btn edit-scenario-btn">Editar</button>
                                <button class="action-btn export-scenario-btn">Exportar</button>
                                <button class="action-btn delete-scenario-btn">Eliminar</button>
                            </div>
                        `;
                        customScenarioListUL.appendChild(listItem);
                        generateScenarioPreview(scenario, `preview-${scenario.id}`);
                    });
                    addScenarioActionListeners();
                } else {
                    noCustomScenariosMsg.style.display = 'block';
                }
            } catch (error) { console.error("Error loading scenarios:", error); noCustomScenariosMsg.textContent = "Error loading scenarios."; noCustomScenariosMsg.style.display = 'block'; }
        }
        function generateScenarioPreview(scenario, containerId) {
            const container = document.getElementById(containerId);
            if (!container || !scenario.grid) return;

            container.innerHTML = '';
            const rows = scenario.height;
            const cols = scenario.width;
            container.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
            container.style.gridTemplateRows = `repeat(${rows}, 1fr)`;

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const cellDiv = document.createElement('div');
                    cellDiv.classList.add('scenario-preview-cell');
                    let cellColor = MINIMAP_PATH_COLOR;
                    const cellType = scenario.grid[r][c];
                    switch (cellType) {
                        case 0: cellColor = MINIMAP_WALL_COLOR; break;
                        case 1: cellColor = MINIMAP_PATH_COLOR; break;
                        case 5: cellColor = MINIMAP_PLAYER_COLOR; break;
                        case END_CELL_TERMINATE: cellColor = MINIMAP_END_COLOR; break;
                        case END_CELL_SPECIFIC_NEXT: cellColor = MINIMAP_END_LINK_COLOR; break;
                        case PIT_TRAP_CELL_TYPE: cellColor = MINIMAP_PITTRAP_INTACT_COLOR; break;
                        case BROKEN_PIT_TRAP_CELL_TYPE_LAYOUT: cellColor = MINIMAP_PITTRAP_BROKEN_COLOR; break;
                        case FALLING_BLOCK_TRAP_CELL_TYPE: cellColor = MINIMAP_FALLING_BLOCK_COLOR; break;
                        case SPIKE_TRAP_CELL_TYPE: cellColor = MINIMAP_SPIKES_COLOR; break;
                        case MINOTAUR_CELL_TYPE: cellColor = MINIMAP_MINOTAUR_COLOR; break;
                        case LAVA_CELL_TYPE: cellColor = MINIMAP_LAVA_COLOR; break; 
                    }
                    cellDiv.style.backgroundColor = cellColor;
                    container.appendChild(cellDiv);
                }
            }
        }
        function addScenarioActionListeners() {
            customScenarioListUL.querySelectorAll('.scenario-item').forEach(item => {
                const scenarioId = parseInt(item.dataset.id);
                item.querySelector('.play-scenario-btn').addEventListener('click', async () => {
                    const scenarioToPlay = await getScenarioByIdDB(scenarioId);
                    if (scenarioToPlay) {
                        customGameScreen.style.display = 'none';
                        if(loadingTextElement) loadingTextElement.style.display = 'block';
                        if(loadingScreenElement) loadingScreenElement.style.display = 'flex';
                        preloadAssets(() => { 
                            selectTexturesForScenario(scenarioToPlay.textures);
                            currentPlayingScenarioData = JSON.parse(JSON.stringify(scenarioToPlay));
                            init(scenarioToPlay);
                            finalizeLoadingScreen();
                        });
                    } else { alert("Error: Could not load scenario to play."); }
                });
                item.querySelector('.edit-scenario-btn').addEventListener('click', () => { openScenarioEditor(scenarioId); });
                item.querySelector('.export-scenario-btn').addEventListener('click', async () => {
                    const scenario = await getScenarioByIdDB(scenarioId);
                    if (scenario) { const { id, ...exportData } = scenario; exportScenarioAsJSON(exportData); }
                });
                item.querySelector('.delete-scenario-btn').addEventListener('click', async () => {
                    if (confirm("Are you sure you want to delete this scenario?")) {
                        try { await deleteScenarioDB(scenarioId); loadAndDisplayCustomScenarios(); }
                        catch (error) { console.error("Error deleting scenario:", error); alert("Error deleting scenario."); }
                    }
                });
            });
        }
        function exportScenarioAsJSON(scenarioData) { const jsonString = JSON.stringify(scenarioData, null, 2); const blob = new Blob([jsonString], { type: "application/json" }); const url = URL.createObjectURL(blob); const a = document.createElement("a"); a.href = url; a.download = `${scenarioData.name.replace(/[^a-z0-9\s-]/gi, '_').trim().replace(/\s+/g, '-').toLowerCase() || 'custom_scenario'}.json`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); }
        importScenarioBtn.addEventListener('click', () => { importFileInput.click(); });
        importFileInput.addEventListener('change', (event) => { const file = event.target.files[0]; if (file) { const reader = new FileReader(); reader.onload = async (e) => { try { const importedScenario = JSON.parse(e.target.result); if (importedScenario.name && importedScenario.width && importedScenario.height && importedScenario.grid && Array.isArray(importedScenario.grid) && importedScenario.grid.length === importedScenario.height && importedScenario.grid.every(row => Array.isArray(row) && row.length === importedScenario.width)) { let scenarioToSave = { name: importedScenario.name, width: importedScenario.width, height: importedScenario.height, grid: importedScenario.grid, textures: importedScenario.textures || {wall:-1, floor:-1, ceiling:-1}, specificNextScenarioName: importedScenario.specificNextScenarioName || null, specificExitCoords: importedScenario.specificExitCoords || null }; const existingScenarios = await getAllScenariosDB(); const existingByName = existingScenarios.find(s => s.name === scenarioToSave.name); if (existingByName) { if (confirm(`A scenario named "${scenarioToSave.name}" already exists. Do you want to overwrite it?`)) { scenarioToSave.id = existingByName.id; } else { importFileInput.value = ''; return; } } await saveScenarioDB(scenarioToSave); loadAndDisplayCustomScenarios(); alert(`Scenario "${importedScenario.name}" imported successfully.`); } else { alert("The JSON file does not have the expected scenario format or is corrupt."); } } catch (error) { console.error("Error importing scenario:", error); alert("Error processing the JSON file. Ensure it is valid."); } importFileInput.value = ''; }; reader.readAsText(file); } });
        createNewScenarioBtn.addEventListener('click', () => { openScenarioEditor(null); });
        backToCustomScreenBtn.addEventListener('click', () => { if (hasUnsavedChanges) { if (!confirm("You have unsaved changes. Are you sure you want to leave the editor? Changes will be lost.")) { return; } } scenarioEditorScreen.style.display = 'none'; customGameScreen.style.display = 'flex'; currentEditingScenario = null; hasUnsavedChanges = false; editorMessageSpan.textContent = ''; });
        async function openScenarioEditor(scenarioId) {
            customGameScreen.style.display = 'none';
            scenarioEditorScreen.style.display = 'flex';
            hasUnsavedChanges = false;
            editorMessageSpan.textContent = '';
            playEditedScenarioBtn.disabled = true;

             if (document.getElementById('wall-texture-select').options.length <= 1) { 
                 populateTextureSelectors();
             }


            if (scenarioId !== null) {
                const scenario = await getScenarioByIdDB(scenarioId);
                if (!scenario) { alert("Error: Could not load scenario."); backToCustomScreenBtn.click(); return; }
                currentEditingScenario = JSON.parse(JSON.stringify(scenario));
                scenarioNameInput.value = currentEditingScenario.name;
                dimensionSelectorDiv.style.display = 'none';
                scenarioNameInput.style.display = 'block';
                brushToolsDiv.style.display = 'flex';
                if (textureSelectorsDiv) textureSelectorsDiv.style.display = 'block';
                editorActionsDiv.style.display = 'flex';

                updateTexturePreview('wall-texture-select', 'wall-texture-preview', currentEditingScenario.textures?.wall ?? -1);
                updateTexturePreview('floor-texture-select', 'floor-texture-preview', currentEditingScenario.textures?.floor ?? -1);
                updateTexturePreview('ceiling-texture-select', 'ceiling-texture-preview', currentEditingScenario.textures?.ceiling ?? -1);

                let endTypeToSelect = 'terminate'; 
                let hasSpecificEndCellInGrid = false;
                for (let r = 0; r < currentEditingScenario.grid.length; r++) {
                    for (let c = 0; c < currentEditingScenario.grid[r].length; c++) {
                        if (currentEditingScenario.grid[r][c] === END_CELL_SPECIFIC_NEXT) {
                            hasSpecificEndCellInGrid = true;
                            break;
                        }
                    }
                    if (hasSpecificEndCellInGrid) break;
                }
                
                if (hasSpecificEndCellInGrid && currentEditingScenario.specificNextScenarioName) {
                     endTypeToSelect = 'specific_next_scenario';
                }

                document.querySelector(`input[name="end-behavior"][value="${endTypeToSelect}"]`).checked = true;

                if (endTypeToSelect === 'specific_next_scenario') {
                    await populateSpecificNextScenarioSelector(); 
                    const scenarios = await getAllScenariosDB(); 
                    const targetScenario = scenarios.find(s => s.name === currentEditingScenario.specificNextScenarioName);
                    specificNextScenarioSelect.value = targetScenario ? targetScenario.id : "";
                    specificNextScenarioSelect.style.display = 'inline-block';
                } else {
                    specificNextScenarioSelect.style.display = 'none';
                }


                setupEditorGrid(currentEditingScenario.width, currentEditingScenario.height, currentEditingScenario.grid);
                checkEditorStateForPlayability();
            } else { 
                currentEditingScenario = { id: null, name: "", width: 0, height: 0, grid: [], textures: {wall: -1, floor: -1, ceiling:-1 }, specificNextScenarioName: null, specificExitCoords: null };
                scenarioNameInput.value = '';
                dimensionSelectorDiv.style.display = 'flex';
                scenarioNameInput.style.display = 'none';
                brushToolsDiv.style.display = 'none';
                if (textureSelectorsDiv) textureSelectorsDiv.style.display = 'none';
                if (endCellOptionsDiv) endCellOptionsDiv.style.display = 'none';
                editorActionsDiv.style.display = 'none';
                editorGridContainer.innerHTML = '';

                updateTexturePreview('wall-texture-select', 'wall-texture-preview', -1);
                updateTexturePreview('floor-texture-select', 'floor-texture-preview', -1);
                updateTexturePreview('ceiling-texture-select', 'ceiling-texture-preview', -1);
                if (document.querySelector('input[name="end-behavior"]')) {
                    document.querySelector('input[name="end-behavior"][value="terminate"]').checked = true;
                }
                if (specificNextScenarioSelect) {
                    specificNextScenarioSelect.style.display = 'none';
                    specificNextScenarioSelect.value = "";
                }
            }

            if (selectedBrush === 'end' && brushToolsDiv.style.display !== 'none' && endCellOptionsDiv) {
                endCellOptionsDiv.style.display = 'block';
                const currentEndBehavior = document.querySelector('input[name="end-behavior"]:checked').value;
                if(specificNextScenarioSelect) specificNextScenarioSelect.style.display = (currentEndBehavior === 'specific_next_scenario') ? 'inline-block' : 'none';
                if (currentEndBehavior === 'specific_next_scenario' && specificNextScenarioSelect && specificNextScenarioSelect.options.length <=1 ) {
                     populateSpecificNextScenarioSelector();
                }
            } else if (endCellOptionsDiv) {
                endCellOptionsDiv.style.display = 'none';
            }
            document.querySelectorAll('.brush-btn').forEach(b => b.classList.remove('active'));
            const activeButton = document.querySelector(`.brush-btn[data-type="${selectedBrush}"]`);
            if (activeButton) activeButton.classList.add('active');
        }
        function confirmSizeBtnEventListener() { 
            const [w, h] = scenarioSizeSelect.value.split('x').map(Number);
            currentEditingScenario.width = w;
            currentEditingScenario.height = h;
            currentEditingScenario.grid = Array(h).fill(null).map(() => Array(w).fill(0)); 
            for (let r = 0; r < h; r++) {
                currentEditingScenario.grid[r][0] = 0;
                currentEditingScenario.grid[r][w-1] = 0;
            }
            for (let c = 0; c < w; c++) {
                currentEditingScenario.grid[0][c] = 0;
                currentEditingScenario.grid[h-1][c] = 0;
            }

            currentEditingScenario.textures = {wall: -1, floor: -1, ceiling: -1 };
            currentEditingScenario.specificNextScenarioName = null;
            currentEditingScenario.specificExitCoords = null; 

            dimensionSelectorDiv.style.display = 'none';
            scenarioNameInput.style.display = 'block';
            scenarioNameInput.value = "Nuevo Laberinto";
            currentEditingScenario.name = "Nuevo Laberinto";
            brushToolsDiv.style.display = 'flex';
            if (textureSelectorsDiv) textureSelectorsDiv.style.display = 'block';
             updateTexturePreview('wall-texture-select', 'wall-texture-preview', -1);
             updateTexturePreview('floor-texture-select', 'floor-texture-preview', -1);
             updateTexturePreview('ceiling-texture-select', 'ceiling-texture-preview', -1);
            if (endCellOptionsDiv) {
                endCellOptionsDiv.style.display = (selectedBrush === 'end') ? 'block' : 'none';
                document.querySelector('input[name="end-behavior"][value="terminate"]').checked = true;
                specificNextScenarioSelect.style.display = 'none';
                specificNextScenarioSelect.value = "";
            }

            editorActionsDiv.style.display = 'flex';
            setupEditorGrid(w, h, currentEditingScenario.grid);
            hasUnsavedChanges = true;
            checkEditorStateForPlayability();
        }
        confirmSizeBtn.addEventListener('click', confirmSizeBtnEventListener); 
        function setupEditorGrid(width, height, gridData) { editorGridContainer.innerHTML = ''; editorGridContainer.style.gridTemplateColumns = `repeat(${width}, 1fr)`; editorGridContainer.style.gridTemplateRows = `repeat(${height}, 1fr)`; editorGridData = JSON.parse(JSON.stringify(gridData)); editorCellElements = []; for (let r = 0; r < height; r++) { editorCellElements[r] = []; for (let c = 0; c < width; c++) { const cell = document.createElement('div'); cell.classList.add('grid-cell'); cell.dataset.row = r; cell.dataset.col = c; if (r === 0 || r === height - 1 || c === 0 || c === width - 1) { cell.classList.add('border'); editorGridData[r][c] = 0; } updateCellVisual(cell, editorGridData[r][c]); cell.addEventListener('click', handleGridCellClick); editorGridContainer.appendChild(cell); editorCellElements[r][c] = cell; } } }
        function updateCellVisual(cellElement, cellType) {
            cellElement.classList.remove('path', 'start', 'end', 'wall', 'pittrap', 'fallingblock', 'spikes', 'minotaur', 'lava'); 
            let symbol = '';
            cellElement.style.fontSize = "12px";
            cellElement.style.color = "rgba(255,255,255,0.8)";
            
            const defaultBgClass = cellElement.classList.contains('border') ? 'border' : (editorGridData[parseInt(cellElement.dataset.row)][parseInt(cellElement.dataset.col)] === 0 ? 'wall' : 'path');
            if (!cellElement.classList.contains(defaultBgClass)) {
                 cellElement.style.backgroundColor = ""; 
            }


            switch (cellType) {
                case 0: cellElement.classList.add('wall'); break;
                case 1: cellElement.classList.add('path'); break;
                case 5: cellElement.classList.add('start'); symbol = 'S'; break;
                case END_CELL_TERMINATE: cellElement.classList.add('end'); symbol = 'E'; break;
                case END_CELL_SPECIFIC_NEXT:
                    cellElement.classList.add('end'); 
                    symbol = 'E>';
                    cellElement.style.backgroundColor = MINIMAP_END_LINK_COLOR; 
                    break;
                case PIT_TRAP_CELL_TYPE: cellElement.classList.add('pittrap'); symbol = 'T'; break;
                case FALLING_BLOCK_TRAP_CELL_TYPE: cellElement.classList.add('fallingblock'); symbol = 'B'; break;
                case SPIKE_TRAP_CELL_TYPE: cellElement.classList.add('spikes'); symbol = 'P'; break;
                case MINOTAUR_CELL_TYPE: cellElement.classList.add('minotaur'); symbol = 'M'; break;
                case LAVA_CELL_TYPE: cellElement.classList.add('lava'); symbol = 'L'; break; 
                default: cellElement.classList.add('wall'); break; 
            }
            cellElement.textContent = symbol;
        }
        function handleGridCellClick(event) {
            const cell = event.target;
            const r = parseInt(cell.dataset.row);
            const c = parseInt(cell.dataset.col);

            if (cell.classList.contains('border')) return;

            let newType;
            let newCellTypeForGridData = -1; 

            switch (selectedBrush) {
                case 'wall': newType = 0; break;
                case 'path': newType = 1; break;
                case 'start': newType = 5; break;
                case 'pittrap': newType = PIT_TRAP_CELL_TYPE; break;
                case 'fallingblock': newType = FALLING_BLOCK_TRAP_CELL_TYPE; break;
                case 'spikes': newType = SPIKE_TRAP_CELL_TYPE; break;
                case 'minotaur': newType = MINOTAUR_CELL_TYPE; break;
                case 'lava': newType = LAVA_CELL_TYPE; break; 
                case 'end':
                    const endBehaviorRadio = document.querySelector('input[name="end-behavior"]:checked');
                    const endBehavior = endBehaviorRadio ? endBehaviorRadio.value : 'terminate';

                    if (endBehavior === 'specific_next_scenario') {
                        newType = END_CELL_SPECIFIC_NEXT;
                        const targetScenarioIdSelected = specificNextScenarioSelect.value ? parseInt(specificNextScenarioSelect.value) : null;
                        if (targetScenarioIdSelected === null || isNaN(targetScenarioIdSelected) || targetScenarioIdSelected === "") {
                            editorMessageSpan.textContent = "Selecciona un escenario de destino para el fin específico o cambia el comportamiento.";
                            setTimeout(() => editorMessageSpan.textContent = "", 3500);
                            return; 
                        }
                    } else {
                        newType = END_CELL_TERMINATE;
                    }
                    newCellTypeForGridData = newType; 
                    break;
                default: return;
            }
            
            if (newType === 5 || newType === MINOTAUR_CELL_TYPE) { 
                 for (let i = 0; i < editorGridData.length; i++) {
                    for (let j = 0; j < editorGridData[i].length; j++) {
                        if (editorGridData[i][j] === newType) { 
                            editorGridData[i][j] = 1; 
                            if (editorCellElements[i] && editorCellElements[i][j]) {
                                updateCellVisual(editorCellElements[i][j], 1);
                            }
                        }
                    }
                }
            }


            editorGridData[r][c] = (newCellTypeForGridData !== -1 && selectedBrush === 'end') ? newCellTypeForGridData : newType;
            updateCellVisual(cell, editorGridData[r][c]);
            hasUnsavedChanges = true;
            checkEditorStateForPlayability();
        }
        document.querySelectorAll('.brush-btn').forEach(button => {
            button.addEventListener('click', () => {
                document.querySelectorAll('.brush-btn').forEach(b => b.classList.remove('active'));
                button.classList.add('active');
                selectedBrush = button.dataset.type;

                if (selectedBrush === 'end') {
                    if(endCellOptionsDiv) endCellOptionsDiv.style.display = 'block';
                    const currentEndBehavior = document.querySelector('input[name="end-behavior"]:checked').value;
                     if (specificNextScenarioSelect) specificNextScenarioSelect.style.display = (currentEndBehavior === 'specific_next_scenario') ? 'inline-block' : 'none';
                     if (currentEndBehavior === 'specific_next_scenario' && specificNextScenarioSelect && specificNextScenarioSelect.options.length <=1 ) { 
                         populateSpecificNextScenarioSelector();
                     }
                } else {
                    if(endCellOptionsDiv) endCellOptionsDiv.style.display = 'none';
                }
            });
        });
        document.querySelectorAll('input[name="end-behavior"]').forEach(radio => {
            radio.addEventListener('change', function() {
                const newEndBehavior = this.value;
                if (newEndBehavior === 'specific_next_scenario') {
                    populateSpecificNextScenarioSelector(); 
                    if(specificNextScenarioSelect) specificNextScenarioSelect.style.display = 'inline-block';
                } else {
                    if(specificNextScenarioSelect) specificNextScenarioSelect.style.display = 'none';
                }
                for (let r_idx = 0; r_idx < editorGridData.length; r_idx++) {
                    for (let c_idx = 0; c_idx < editorGridData[r_idx].length; c_idx++) {
                        if (editorGridData[r_idx][c_idx] === END_CELL_TERMINATE || editorGridData[r_idx][c_idx] === END_CELL_SPECIFIC_NEXT) {
                            const newEndTypeForCell = (newEndBehavior === 'specific_next_scenario') ? END_CELL_SPECIFIC_NEXT : END_CELL_TERMINATE;
                            
                            if (newEndBehavior === 'specific_next_scenario' && (!specificNextScenarioSelect.value || specificNextScenarioSelect.value === "")) {
                                editorMessageSpan.textContent = "Selecciona un escenario de destino antes de cambiar todos los fines a 'Específico'.";
                                setTimeout(() => editorMessageSpan.textContent = "", 3500);
                                document.querySelector('input[name="end-behavior"][value="terminate"]').checked = true;
                                if(specificNextScenarioSelect) specificNextScenarioSelect.style.display = 'none';
                                return; 
                            }
                            
                            editorGridData[r_idx][c_idx] = newEndTypeForCell;
                            if (editorCellElements[r_idx] && editorCellElements[r_idx][c_idx]) {
                                 updateCellVisual(editorCellElements[r_idx][c_idx], newEndTypeForCell);
                            }
                        }
                    }
                }
                hasUnsavedChanges = true;
                checkEditorStateForPlayability();
            });
        });
        saveScenarioBtn.addEventListener('click', async () => {
            const scenarioName = scenarioNameInput.value.trim();
            if (!scenarioName) { editorMessageSpan.textContent = "Please enter a scenario name."; return; }

            currentEditingScenario.name = scenarioName;
            currentEditingScenario.grid = JSON.parse(JSON.stringify(editorGridData)); 
            currentEditingScenario.textures = {
                wall: parseInt(document.getElementById('wall-texture-select').value),
                floor: parseInt(document.getElementById('floor-texture-select').value),
                ceiling: parseInt(document.getElementById('ceiling-texture-select').value)
            };

            currentEditingScenario.specificNextScenarioName = null;
            currentEditingScenario.specificExitCoords = null; 
            
            const selectedEndBehaviorRadio = document.querySelector('input[name="end-behavior"]:checked');
            const endBehaviorSetting = selectedEndBehaviorRadio ? selectedEndBehaviorRadio.value : 'terminate';

            let hasAnySpecificEndCellInGrid = false;
            for (let r = 0; r < currentEditingScenario.grid.length; r++) {
                for (let c = 0; c < currentEditingScenario.grid[r].length; c++) {
                    if (currentEditingScenario.grid[r][c] === END_CELL_SPECIFIC_NEXT) {
                        hasAnySpecificEndCellInGrid = true;
                        if (!currentEditingScenario.specificExitCoords) {
                             currentEditingScenario.specificExitCoords = {x: c, z: r}; 
                        }
                    }
                }
            }

            if (endBehaviorSetting === 'specific_next_scenario' && hasAnySpecificEndCellInGrid) {
                const targetScenarioId = specificNextScenarioSelect.value ? parseInt(specificNextScenarioSelect.value) : null;
                if (targetScenarioId !== null && !isNaN(targetScenarioId) && targetScenarioId > 0) {
                    const scenarios = await getAllScenariosDB();
                    const targetScenario = scenarios.find(s => s.id === targetScenarioId);
                    if (targetScenario) {
                        currentEditingScenario.specificNextScenarioName = targetScenario.name;
                    } else {
                        editorMessageSpan.textContent = "Error: Escenario de destino no encontrado. Los fines 'E>' se guardarán como fines normales 'E'.";
                        for (let r=0; r<currentEditingScenario.grid.length; r++) for (let c=0; c<currentEditingScenario.grid[r].length; c++) if(currentEditingScenario.grid[r][c] === END_CELL_SPECIFIC_NEXT) currentEditingScenario.grid[r][c] = END_CELL_TERMINATE;
                        setTimeout(() => editorMessageSpan.textContent = "", 4000);
                    }
                } else {
                     editorMessageSpan.textContent = "Advertencia: Fines 'E>' sin destino válido. Se guardarán como fines normales 'E'.";
                     for (let r=0; r<currentEditingScenario.grid.length; r++) for (let c=0; c<currentEditingScenario.grid[r].length; c++) if(currentEditingScenario.grid[r][c] === END_CELL_SPECIFIC_NEXT) currentEditingScenario.grid[r][c] = END_CELL_TERMINATE;
                     setTimeout(() => editorMessageSpan.textContent = "", 4000);
                }
            } else { 
                 currentEditingScenario.specificNextScenarioName = null;
                 for (let r=0; r<currentEditingScenario.grid.length; r++) for (let c=0; c<currentEditingScenario.grid[r].length; c++) if(currentEditingScenario.grid[r][c] === END_CELL_SPECIFIC_NEXT) currentEditingScenario.grid[r][c] = END_CELL_TERMINATE;
            }
            delete currentEditingScenario.specificNextScenarioId_temp; 

            const validationResult = validateEditorGrid(); 
            if (!validationResult.valid) { editorMessageSpan.textContent = validationResult.message; return; }


            try {
                const allScenarios = await getAllScenariosDB();
                let nameConflict = null;
                if (currentEditingScenario.id !== null && currentEditingScenario.id !== undefined) { 
                    nameConflict = allScenarios.find(s => s.name === currentEditingScenario.name && s.id !== currentEditingScenario.id);
                } else { 
                    nameConflict = allScenarios.find(s => s.name === currentEditingScenario.name);
                }

                if (nameConflict) {
                    if (!confirm(`Un escenario llamado "${currentEditingScenario.name}" ya existe. ¿Quieres sobrescribirlo?`)) {
                        editorMessageSpan.textContent = "Guardado cancelado. Conflicto de nombre.";
                        return;
                    }
                    if (currentEditingScenario.id === null || currentEditingScenario.id === undefined) {
                         currentEditingScenario.id = nameConflict.id;
                    }
                }

                const savedScenario = await saveScenarioDB(currentEditingScenario);
                currentEditingScenario.id = savedScenario.id; 
                hasUnsavedChanges = false;
                editorMessageSpan.textContent = "Scenario saved!";
                playEditedScenarioBtn.disabled = false; 
                setTimeout(() => editorMessageSpan.textContent = "", 2000);
                loadAndDisplayCustomScenarios(); 
                openScenarioEditor(currentEditingScenario.id); 

            } catch (error) { console.error("Error saving scenario:", error); editorMessageSpan.textContent = "Error saving. Check console."; }
        });
        playEditedScenarioBtn.addEventListener('click', () => { if (hasUnsavedChanges) { editorMessageSpan.textContent = "Save changes before playing."; return; } if (!currentEditingScenario || currentEditingScenario.id === null || currentEditingScenario.id === undefined) { editorMessageSpan.textContent = "Save the scenario first."; return; } const validation = validateEditorGrid(); if (!validation.valid) { editorMessageSpan.textContent = "The maze is not valid for playing: " + validation.message; return; } scenarioEditorScreen.style.display = 'none'; if(loadingTextElement) loadingTextElement.style.display = 'block'; if(loadingScreenElement) loadingScreenElement.style.display = 'flex'; const scenarioToPlay = JSON.parse(JSON.stringify(currentEditingScenario)); preloadAssets(() => { selectTexturesForScenario(scenarioToPlay.textures); currentPlayingScenarioData = JSON.parse(JSON.stringify(scenarioToPlay)); init(scenarioToPlay); finalizeLoadingScreen(); }); });
        function checkEditorStateForPlayability() { const isSaved = (currentEditingScenario && currentEditingScenario.id !== null && currentEditingScenario.id !== undefined); if (hasUnsavedChanges || !isSaved) { playEditedScenarioBtn.disabled = true; if (hasUnsavedChanges) { editorMessageSpan.textContent = "Unsaved changes."; } else if (!isSaved) { editorMessageSpan.textContent = "Save to enable 'Play'."; } if (!hasUnsavedChanges && isSaved && editorMessageSpan.textContent.startsWith("The maze is not valid")) { editorMessageSpan.textContent = ""; } } else { const validation = validateEditorGrid(); playEditedScenarioBtn.disabled = !validation.valid; editorMessageSpan.textContent = validation.valid ? "Ready to play or save." : validation.message; } }
        function validateEditorGrid() {
            if (!editorGridData || editorGridData.length === 0 || !editorGridData[0] || editorGridData[0].length === 0) return {valid: false, message: "The grid is empty."};
            let startPoint = null;
            let endPointInfos = []; 
            let minotaurPoint = null;
            const rows = editorGridData.length;
            const cols = editorGridData[0].length;

            for (let r = 0; r < rows; r++) {
                if (!editorGridData[r]) { console.error(`Row ${r} is null/undefined in editorGridData`); continue; }
                for (let c = 0; c < cols; c++) {
                    const cellValue = editorGridData[r][c];
                    if (cellValue === undefined || cellValue === null) { console.warn(`Cell [${r}][${c}] is null/undefined, treating as wall (0).`); editorGridData[r][c] = 0; if (editorCellElements && editorCellElements[r] && editorCellElements[r][c]) { updateCellVisual(editorCellElements[r][c], 0); } }
                    
                    if (editorGridData[r][c] === 5) { 
                        if (startPoint) return {valid: false, message: "Only one start point (S) is allowed."}; 
                        startPoint = {r, c}; 
                    }
                    if (editorGridData[r][c] === END_CELL_TERMINATE || editorGridData[r][c] === END_CELL_SPECIFIC_NEXT) { 
                        endPointInfos.push({r, c, type: editorGridData[r][c]}); 
                    }
                    if (editorGridData[r][c] === MINOTAUR_CELL_TYPE) { 
                        if (minotaurPoint) return {valid: false, message: "Only one Minotaur (M) is allowed."}; 
                        minotaurPoint = {r,c};
                    }
                    if ((editorGridData[r][c] === PIT_TRAP_CELL_TYPE || editorGridData[r][c] === FALLING_BLOCK_TRAP_CELL_TYPE || editorGridData[r][c] === SPIKE_TRAP_CELL_TYPE || editorGridData[r][c] === LAVA_CELL_TYPE) && (r === 0 || r === rows - 1 || c === 0 || c === cols - 1)) { 
                        return { valid: false, message: `Traps (T, B, P, L) cannot be on the border.` }; 
                    }
                }
            }
            if (!startPoint) return {valid: false, message: "Missing a start point (S)."};
            if (endPointInfos.length === 0) return {valid: false, message: "Missing at least one end point (E or E>)."}; 

            if (startPoint.r === 0 || startPoint.r === rows - 1 || startPoint.c === 0 || startPoint.c === cols - 1) return { valid: false, message: "Start (S) cannot be on the border." };
            // if (editorGridData[startPoint.r][startPoint.c] === LAVA_CELL_TYPE) return {valid: false, message: "Start point (S) cannot be on Lava."}; 

            for (const endInfo of endPointInfos) {
                if (endInfo.r === 0 || endInfo.r === rows - 1 || endInfo.c === 0 || endInfo.c === cols - 1) return { valid: false, message: `End point (E or E>) at ${endInfo.r},${endInfo.c} cannot be on the border.` };
                if (editorGridData[endInfo.r][endInfo.c] === 0) return { valid: false, message: `End point at ${endInfo.r},${endInfo.c} cannot be on a wall.` }; 
                // if (editorGridData[endInfo.r][endInfo.c] === LAVA_CELL_TYPE) return {valid: false, message: `End point at ${endInfo.r},${endInfo.c} cannot be on Lava.`}; 
            }
            if (minotaurPoint) {
                 if (minotaurPoint.r === 0 || minotaurPoint.r === rows - 1 || minotaurPoint.c === 0 || minotaurPoint.c === cols - 1) return { valid: false, message: "Minotaur (M) cannot be on the border." };
                 if (editorGridData[minotaurPoint.r][minotaurPoint.c] === LAVA_CELL_TYPE) return {valid: false, message: "Minotaur (M) cannot start on Lava."}; 
            }
            
            const hasSpecificNextTypeCell = endPointInfos.some(ep => ep.type === END_CELL_SPECIFIC_NEXT);
            if (hasSpecificNextTypeCell) {
                const selectedEndBehaviorRadio = document.querySelector('input[name="end-behavior"]:checked');
                if (selectedEndBehaviorRadio && selectedEndBehaviorRadio.value === 'specific_next_scenario') {
                    if (!specificNextScenarioSelect.value || specificNextScenarioSelect.value === "") {
                        return {valid: false, message: "An 'E>' cell exists, but 'Cargar Escenario Específico' (in options) has no destination selected."};
                    }
                }
            }

            return {valid: true, message: "Valid maze."};
        }
        function escapeHTML(str) { if (str === null || str === undefined) return ""; return String(str).replace(/[&<>"']/g, function (match) { return { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[match]; }); }
        function startGameSequence() {
            console.log("Showing start options...");
            if(gameVersionSpan) gameVersionSpan.textContent = GAME_VERSION;
            if(loadingScreenElement) loadingScreenElement.style.display = 'flex';
            if(startOptionsDiv) startOptionsDiv.style.display = 'flex';
            if(loadingTextElement) loadingTextElement.style.display = 'none';

            populateTextureSelectors(); 

            initDB().then(() => {
                console.log("Database ready for use from startGameSequence.");
                 if (startCustomGameButton) startCustomGameButton.disabled = false;
            }).catch(error => {
                console.error("Database initialization failed. Custom game will not work correctly.", error);
                alert("Could not initialize database for custom scenarios. This feature might not be available.");
                if (startCustomGameButton) startCustomGameButton.disabled = true;
            });

            startAutoGameButton.addEventListener('click', () => {
                if(startOptionsDiv) startOptionsDiv.style.display = 'none';
                if(loadingTextElement) loadingTextElement.style.display = 'block';
                console.log("Starting game with autogenerated maze...");
                preloadAssets(() => { 
                    selectRandomTextures();
                    currentPlayingScenarioData = null;
                    init();
                    finalizeLoadingScreen();
                });
            });

            startCustomGameButton.addEventListener('click', showCustomGameUI);

            cancelNextScenarioBtn.addEventListener('click', () => {
                nextScenarioSelectionScreen.style.display = 'none';
                if(loadingScreenElement) loadingScreenElement.style.display = 'flex';
                if(startOptionsDiv) startOptionsDiv.style.display = 'flex';
            });


            if (!window.onresize) window.addEventListener('resize', onWindowResize, false);
        }
        function finalizeLoadingScreen() {
            setTimeout(() => {
                if(loadingScreenElement) {
                    loadingScreenElement.style.opacity = '0';
                    setTimeout(() => {
                        loadingScreenElement.style.display = 'none';
                        loadingScreenElement.style.opacity = '1'; 
                    }, 500); 
                }
                console.log("Loading screen hidden. Game started.");
                 if (!isTouchDevice && pointerLockInfoDiv && pointerLockInfoDiv.style.display !== 'none' && !isPointerLocked) {
                    pointerLockInfoDiv.style.display = 'block';
                }
            }, 200); 
        }
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', startGameSequence);
        } else {
            startGameSequence();
        }
    </script>
</body>
</html>
