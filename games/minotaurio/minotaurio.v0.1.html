<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minotaurio - Laberinto Subterráneo</title>
    <style>
        /* General Body and Game View Styles */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            touch-action: none;
            font-family: 'Palatino Linotype', 'Book Antiqua', 'Palatino', serif; /* Fuente principal con aire griego */
            color: #e0e0e0; /* Default text color for consistency */
        }
        canvas { display: block; width: 100%; height: 100%; }

        /* Functional UI Styles (Joystick, Action Buttons, Minimap - less aesthetic changes) */
        #joystick-area { position: absolute; width: 120px; height: 120px; background: rgba(200, 200, 200, 0.15); border-radius: 50%; display: none; justify-content: center; align-items: center; z-index: 10; pointer-events: none; transform: translate(-50%, -50%); }
        #joystick-thumb { width: 50px; height: 50px; background: rgba(200, 200, 200, 0.4); border-radius: 50%; }
        #action-buttons { position: absolute; bottom: 30px; right: 20px; display: flex; flex-direction: column; gap: 15px; z-index: 10; }
        .action-button {
            width: 60px; height: 60px;
            background: rgba(180, 40, 40, 0.7); /* Deep red */
            border-radius: 50%; display: flex; justify-content: center; align-items: center; color: white; font-weight: bold; font-size: 12px; text-align: center; user-select: none; border: 2px solid rgba(255, 255, 255, 0.3); cursor: pointer;
        }
        #message { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); background-color: rgba(20, 20, 20, 0.8); color: white; padding: 10px 20px; border-radius: 5px; display: none; z-index: 20; font-family: inherit;} /* Inherit font */
        #minimapCanvas { position: absolute; top: 15px; right: 15px; width: 160px; height: 160px; border: 1px solid rgba(255, 255, 255, 0.4); background-color: rgba(10, 10, 10, 0.6); z-index: 15; image-rendering: pixelated; }
        #pointer-lock-info { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.7); color: white; padding: 20px; border-radius: 10px; font-size: 1.2em; text-align: center; display: none; z-index: 100; font-family: inherit;} /* Inherit font */

        /* --- Loading Screen Styles --- */
        #loading-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: #111;
            color: #e0e0e0; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; transition: opacity 0.5s ease-out; z-index: 1000;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
            font-family: 'Palatino Linotype', 'Book Antiqua', 'Palatino', serif;
        }
        #loading-screen h1 {
            font-size: 4.8em;
            margin-bottom: 0.05em;
            color: #ffc107;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.6);
            border-bottom: 4px double #ffc107;
            padding-bottom: 10px;
        }
        #loading-screen .credits {
            font-size: 1em;
            color: #b0b0b0;
            margin-top: 0.5em;
            margin-bottom: 1em;
        }
        #loading-screen .credits a {
            color: #ffc107;
            text-decoration: none;
            font-weight: bold;
        }
        #loading-screen .credits a:hover {
            text-decoration: underline;
            color: #ffda6b;
        }
        #loading-screen p {
            font-size: 1.1em;
            color: #ccc;
            margin-bottom: 15px;
            max-width: 700px;
            line-height: 1.5;
        }
        #loading-screen .version {
            font-size: 0.9em;
            margin-top: 5px;
            margin-bottom: 20px;
            color: #aaa;
        }
        #loading-screen .legend-text {
             font-style: italic;
             color: #bbb;
             margin-bottom: 25px;
        }

        #loading-screen .loading-text {
            font-size: 1.5em;
            color: #ccc;
            margin-top: 20px;
        }
        #start-options {
             margin-top: 30px;
             display: flex;
             flex-direction: column;
             gap: 15px;
        }
        .menu-button {
            background-color: #ffc107;
            color: #1a1a1a;
            border: none;
            padding: 15px 30px;
            font-size: 1.2em;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.3s ease, transform 0.1s ease;
            min-width: 300px;
            text-transform: uppercase;
             letter-spacing: 1px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        .menu-button:hover {
            background-color: #ffda6b;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.4);
        }
         .menu-button:active {
             transform: translateY(0);
             box-shadow: 0 2px 3px rgba(0, 0, 0, 0.3);
         }
         .menu-button:disabled {
             background-color: #555;
             color: #999;
             cursor: not-allowed;
             box-shadow: none;
             transform: none;
         }


        /* --- Custom Game Screen Styles --- */
        #custom-game-screen, #scenario-editor-screen {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: #151515;
            color: #e0e0e0; flex-direction: column; align-items: center; padding-top: 50px; z-index: 900; overflow-y: auto;
            box-sizing: border-box;
        }
        #custom-game-screen h2, #scenario-editor-screen h2 {
            color: #ffc107;
            margin-bottom: 25px;
            border-bottom: 2px solid #ffc107;
            padding-bottom: 5px;
             font-size: 2em;
        }
        #custom-scenario-list-container { width: 90%; max-width: 700px; margin-bottom: 20px; }
        #no-custom-scenarios { text-align: center; display: none; color: #aaa; }
        #custom-scenario-list { list-style: none; padding: 0; width: 100%;}
        .scenario-item {
            background-color: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.15);
            padding: 12px 20px;
            margin-bottom: 10px;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
             flex-wrap: wrap;
             gap: 10px;
        }
        .scenario-item span { font-size: 1.1em; flex-grow: 1; min-width: 150px; }
        .scenario-actions {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
        }
        .scenario-actions .action-btn {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 6px 10px;
            font-size: 0.85em;
            cursor: pointer;
            border-radius: 3px;
            transition: background-color 0.2s ease;
            min-width: auto;
             text-transform: none;
             letter-spacing: normal;
             box-shadow: none;
             height: auto;
             display: inline-flex;
             align-items: center;
             justify-content: center;
        }
        .scenario-actions .action-btn:hover { background-color: #0056b3; transform: none; box-shadow: none;}
        .scenario-actions .delete-scenario-btn { background-color: #dc3545; }
        .scenario-actions .delete-scenario-btn:hover { background-color: #c82333; }
        .menu-button.small-padding { padding: 8px 15px; font-size: 0.9em; min-width: auto; }


        /* --- Scenario Editor Styles --- */
        #scenario-editor-screen { background-color: #151515; z-index: 950; padding-top: 20px;}
        #editor-controls { margin-bottom: 15px; display: flex; flex-direction: column; align-items: center; gap: 10px; width: 90%; max-width: 700px;}
        #dimension-selector { display:none; margin-bottom:10px; align-items: center; gap: 10px; flex-wrap: wrap; justify-content: center; }
        #dimension-selector label { font-size: 1.1em;}
        #scenario-size-select {
            padding: 8px;
            border-radius: 3px;
             background-color: #333;
             color: white;
             border: 1px solid #555;
             font-family: inherit;
             font-size: 1em;
        }
        #confirm-size-btn { margin-left: 0; margin-top: 5px; }
        #brush-tools { margin-bottom:10px; display:none; flex-wrap: wrap; justify-content: center;}
        #brush-tools span { font-size: 1.1em; margin-right: 10px; margin-bottom: 5px; flex-shrink: 0;}
        .brush-btn {
            padding: 8px 12px; margin: 0 5px; border: 1px solid #ccc; background-color: #555; color:white; cursor:pointer; border-radius: 3px;
            transition: background-color 0.2s ease, border-color 0.2s ease;
            font-family: inherit;
            font-size: 0.9em;
            margin-bottom: 5px;
        }
        .brush-btn.active {
            background-color: #ffc107;
            color:#1a1a1a;
            border-color: #ffc107;
        }
        #scenario-name-input {
            padding: 10px; margin-bottom:10px; display:none; width: 80%; max-width: 300px; border-radius: 3px; border: 1px solid #555; background-color: #333; color: white;
             font-family: inherit;
             font-size: 1.1em;
        }
        #editor-grid-container {
            display: grid; border: 1px solid #444; margin-bottom: 15px;
            background-color: #222;
        }
        .grid-cell {
            width: 25px; height: 25px;
            background-color: #403a30;
             border: 1px solid #2a2a2a; box-sizing: border-box; cursor: pointer; display: flex; justify-content: center; align-items: center; font-size: 12px; font-weight: bold;
             color: rgba(255,255,255,0.8);
        }
        .grid-cell.path {
            background-color: #605548;
        }
        .grid-cell.start { background-color: #4CAF50; color: white; }
        .grid-cell.end { background-color: #F44336; color: white; }
        .grid-cell.pittrap { background-color: #8B4513; color: white; }
        .grid-cell.border { cursor: not-allowed; background-color: #111 !important; color: #444 !important;}
        #editor-actions { display: flex; gap: 10px; margin-bottom: 15px; display:none; flex-wrap: wrap; justify-content: center;}
        #editor-message { color: #ffc107; margin-left:10px; align-self: center; font-size: 1em; margin-top: 5px; text-align: center;}

        #back-to-main-menu-btn {
            background-color: #6c757d;
            color: white;
        }
         #back-to-main-menu-btn:hover {
            background-color: #5a6268;
         }
        #back-to-custom-screen-btn {
            background-color: #6c757d;
            color: white;
        }
         #back-to-custom-screen-btn:hover {
            background-color: #5a6268;
         }
    </style>
</head>
<body>
    <div id="loading-screen">
        <h1>Minotaurio</h1>
        <p class="credits">
            por <a href="https://www.linkedin.com/in/oriol-badia" target="_blank" rel="noopener noreferrer">Oriol Badia Campanera</a>
        </p>
        <p class="version">Versión <span id="game-version"></span></p>

        <p class="legend-text">
            En el corazón de la antigua Creta, reinaba el Rey Minos, pero la oscuridad acechaba.
            Nacido de una unión impía, el Minotauro, una bestia de hombre y toro, exigía sacrificio.
            Encerrado en un vasto e ineludible Laberinto diseñado por el ingenioso Dédalo,
            se alimentaba de la juventud de Atenas. Cada año, jóvenes valientes y doncellas
            eran enviados a las retorcidas profundidades, nunca para regresar, perdidos
            ante la bestia o el laberinto mismo. El miedo se apoderó de la tierra,
            pues ¿quién podría navegar la oscuridad? ¿Quién podría enfrentar el rugiente terror en su centro?
        </p>

        <div id="start-options">
            <button id="start-auto-game" class="menu-button">Iniciar Juego (Laberinto Aleatorio)</button>
            <button id="start-custom-game" class="menu-button">Juego Personalizado</button>
        </div>
        <p class="loading-text" id="loading-text-element" style="display: none;">Cargando texturas y laberinto...</p>
    </div>

    <div id="custom-game-screen">
        <h2>Juego Personalizado</h2>
        <div id="custom-scenario-list-container">
            <p id="no-custom-scenarios">No tienes escenarios guardados.</p>
            <ul id="custom-scenario-list"></ul>
        </div>
        <div id="custom-game-actions" style="display: flex; flex-wrap: wrap; justify-content: center; gap: 15px; margin-bottom: 20px;">
            <button id="create-new-scenario-btn" class="menu-button">Crear Nuevo Escenario</button>
            <button id="import-scenario-btn" class="menu-button">Importar Escenario</button>
            <input type="file" id="import-file-input" accept=".json" style="display: none;">
        </div>
        <button id="back-to-main-menu-btn" class="menu-button" style="background-color: #6c757d;">Volver al Menú Principal</button>
    </div>

    <div id="scenario-editor-screen">
        <h2>Editor de Escenarios</h2>
        <div id="editor-controls">
            <div id="dimension-selector">
                <label for="scenario-size-select">Tamaño del Laberinto:</label>
                <select id="scenario-size-select">
                    <option value="10x10">Pequeño (10x10)</option>
                    <option value="15x15" selected>Mediano (15x15)</option>
                    <option value="20x20">Grande (20x20)</option>
                </select>
                <button id="confirm-size-btn" class="menu-button small-padding">Confirmar Tamaño</button>
            </div>
            <input type="text" id="scenario-name-input" placeholder="Nombre del Escenario">
            <div id="brush-tools">
                <span>Herramienta: </span>
                <button class="brush-btn active" data-type="wall">Pared</button>
                <button class="brush-btn" data-type="path">Camino</button>
                <button class="brush-btn" data-type="start">Inicio</button>
                <button class="brush-btn" data-type="end">Fin</button>
                <button class="brush-btn" data-type="pittrap">Trampa Foso</button>
            </div>
        </div>
        <div id="editor-grid-container"></div>
        <div id="editor-actions">
            <button id="save-scenario-btn" class="menu-button small-padding">Guardar</button>
            <button id="play-edited-scenario-btn" class="menu-button small-padding" disabled>Jugar</button>
            <span id="editor-message"></span>
        </div>
        <button id="back-to-custom-screen-btn" class="menu-button" style="background-color: #6c757d;">Volver a Escenarios</button>
    </div>


    <div id="pointer-lock-info">Haz clic para controlar la cámara con el ratón. Presiona ESC para liberar.</div>
    <div id="container"></div>
    <div id="joystick-area"><div id="joystick-thumb"></div></div>
    <div id="action-buttons">
        <div id="jump-button" class="action-button">SALTAR</div>
        <div id="action-button" class="action-button">VISTA</div>
    </div>
    <div id="message"></div>
    <canvas id="minimapCanvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>


    <script>
        // --- Constantes y Configuración ---
        const GAME_VERSION = "v1.10.0-gameplay-ux";
        const MAX_RESOLUTION_DIMENSION = 1920;
        const MAX_RESOLUTION_DIMENSION_MOBILE = 1280;
        const DEFAULT_MAZE_WIDTH = 15; const DEFAULT_MAZE_HEIGHT = 15;
        const CELL_SIZE = 4; const WALL_HEIGHT = 7;
        const PLAYER_HEIGHT = 1.8; const PLAYER_RADIUS = 0.4; const PLAYER_SPEED = 3.5; const SPRINT_SPEED = 6.0; const SPRINT_THRESHOLD = 0.9; const JUMP_VELOCITY = 10.5; const GRAVITY = -18.0; const CAMERA_DISTANCE = 6; const CAMERA_HEIGHT_OFFSET = 2.5; const PUSH_DISTANCE = 0.8; const JOYSTICK_VISUAL_RADIUS = 60; const JOYSTICK_EFFECTIVE_RADIUS = 50; const JOYSTICK_DEADZONE = 0.1; const CAMERA_SENSITIVITY = 0.002; const OBSTACLE_OPACITY = 0.20; const TORCH_COLOR = 0xffa545; const TORCH_PLAYER_INTENSITY = 1.6; const TORCH_PLAYER_DISTANCE = 11; const TORCH_PLAYER_DECAY = 1.4;
        const TORCH_STATIC_INTENSITY = 1.8; const TORCH_STATIC_DISTANCE = 12; const TORCH_STATIC_DECAY = 1.8;
        const STATIC_TORCH_FREQUENCY = 0.45;
        const TORCH_FLICKER_AMOUNT = 0.25; const TORCH_WALL_OFFSET = 0.25; const FLAME_BASE_OPACITY = 0.7; const FLAME_OPACITY_VAR = 0.2; const FLAME_BASE_SCALE_Y = 0.35; const FLAME_SCALE_Y_VAR = 0.1; const MIN_CAMERA_Y_ABOVE_GROUND = 0.5;
        const MINIMAP_SIZE = 160; const MINIMAP_RADIUS_CELLS = 5; const MINIMAP_CELL_SIZE_PX = Math.floor(MINIMAP_SIZE / (MINIMAP_RADIUS_CELLS * 2 + 1)); const MINIMAP_PLAYER_COLOR = '#ff4444'; const MINIMAP_WALL_COLOR = '#505050'; const MINIMAP_PATH_COLOR = '#888888'; const MINIMAP_END_COLOR = '#33cc33';
        const MINIMAP_PITTRAP_INTACT_COLOR = '#D2691E';
        const MINIMAP_PITTRAP_BROKEN_COLOR = '#111111';
        const PLAYER_VISION_RADIUS_CELLS = 4; const MINIMAP_UNSEEN_COLOR = '#181818';
        const FIRST_PERSON_EYE_HEIGHT_FACTOR = 0.85;
        const CAMERA_PITCH_OFFSET_FPS = Math.PI / 2;
        const FPS_TORCH_LIGHT_OFFSET = new THREE.Vector3(0.2, -0.25, -0.5);
        const FPS_TORCH_GROUP_OFFSET = new THREE.Vector3(0.35, -0.45, -0.7);
        const FPS_TORCH_GROUP_ROTATION = new THREE.Euler(Math.PI / 10, Math.PI / 8, -Math.PI / 12, 'YXZ');

        const PIT_TRAP_CELL_TYPE = 7;
        const BROKEN_PIT_TRAP_CELL_TYPE_LAYOUT = 8;
        const PIT_TRAP_TRIGGER_RADIUS_SQUARED = (CELL_SIZE * 0.30) * (CELL_SIZE * 0.30);
        const PIT_TRAP_BREAK_ANIMATION_TIME = 600;
        const PIT_FALL_DEPTH = -WALL_HEIGHT * 1.5;
        const PIT_HOLE_MATERIAL = new THREE.MeshStandardMaterial({ color: 0x101010, roughness: 0.9 });
        const PIT_COVER_THICKNESS = 0.05;
        const PLAYER_STEP_HEIGHT = 0.25;


        // --- TEXTURAS ---
        const textureBaseURL = 'https://urysoft.github.io/ai.html.games/general/assets/images/';
        const textureURLs = [];
        for (let i = 1; i <= 20; i++) {
            textureURLs.push(`${textureBaseURL}textura${i}.jpeg`);
        }
        const textureLoader = new THREE.TextureLoader();
        let loadedTextures = [];
        let floorTexture, wallTexture, crackedTexture;

        let scene, camera, renderer, player, clock;
        let maze = [];
        let currentMazeLayout = [];
        let initialPlayerPosition = new THREE.Vector3();

        let currentMazeWidth, currentMazeHeight;
        let collidableObjects = []; let interactiveObjects = []; let playerVelocity = new THREE.Vector3(); let playerOnGround = false; let moveForward = 0, moveRight = 0; let cameraPhi = Math.PI / 3; let cameraTheta = 0; let endZone = null; let gameActive = true;
        const joystickArea = document.getElementById('joystick-area'); const joystickThumb = document.getElementById('joystick-thumb'); const jumpButton = document.getElementById('jump-button'); const actionButton = document.getElementById('action-button'); const messageDiv = document.getElementById('message'); const containerDiv = document.getElementById('container');
        let joystickPointerId = -1; let cameraPointerId = -1; let joystickStartPos = { x: 0, y: 0 }; let joystickCurrentPos = { x: 0, y: 0 }; let cameraTouchStartPos = { x: 0, y: 0 };
        let currentlyTransparentObjects = new Set(); let playerTorchLight = null; let staticTorches = [];
        let playerTorchGroup = null; let playerTorchFlameMesh = null;
        let originalPlayerTorchLightPosition = new THREE.Vector3();
        let originalPlayerTorchGroupPosition = new THREE.Vector3();
        let originalPlayerTorchGroupRotation = new THREE.Euler();
        let minimapCanvas = null; let minimapCtx = null; let minimapWidth = MINIMAP_SIZE; let minimapHeight = MINIMAP_SIZE;
        let visibilityMaze = [];
        const loadingScreenElement = document.getElementById('loading-screen');
        const gameVersionSpan = document.getElementById('game-version');
        const pointerLockInfoDiv = document.getElementById('pointer-lock-info');
        let isFirstPersonView = false;
        let keyStates = {}; let isPointerLocked = false;
        let isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        const lightWorldPosHelper = new THREE.Vector3();
        const collisionCheckTempBox = new THREE.Box3();

        let pitTrapObjects = [];
        let playerFallingIntoPit = null;

        const startAutoGameButton = document.getElementById('start-auto-game');
        const startCustomGameButton = document.getElementById('start-custom-game');
        const loadingTextElement = document.getElementById('loading-text-element');
        const startOptionsDiv = document.getElementById('start-options');
        const customGameScreen = document.getElementById('custom-game-screen');
        const scenarioEditorScreen = document.getElementById('scenario-editor-screen');
        const customScenarioListUL = document.getElementById('custom-scenario-list');
        const noCustomScenariosMsg = document.getElementById('no-custom-scenarios');
        const createNewScenarioBtn = document.getElementById('create-new-scenario-btn');
        const importScenarioBtn = document.getElementById('import-scenario-btn');
        const importFileInput = document.getElementById('import-file-input');
        const backToMainMenuBtn = document.getElementById('back-to-main-menu-btn');
        const backToCustomScreenBtn = document.getElementById('back-to-custom-screen-btn');
        const dimensionSelectorDiv = document.getElementById('dimension-selector');
        const scenarioSizeSelect = document.getElementById('scenario-size-select');
        const confirmSizeBtn = document.getElementById('confirm-size-btn');
        const brushToolsDiv = document.getElementById('brush-tools');
        const scenarioNameInput = document.getElementById('scenario-name-input');
        const editorGridContainer = document.getElementById('editor-grid-container');
        const editorActionsDiv = document.getElementById('editor-actions');
        const saveScenarioBtn = document.getElementById('save-scenario-btn');
        const playEditedScenarioBtn = document.getElementById('play-edited-scenario-btn');
        const editorMessageSpan = document.getElementById('editor-message');

        let currentEditingScenario = null;
        let editorGridData = [];
        let selectedBrush = 'wall';
        let hasUnsavedChanges = false;
        let editorCellElements = [];


        const DB_NAME = "MinotaurioCustomScenariosDB";
        const DB_VERSION = 1;
        const STORE_NAME = "scenarios";
        let db;

        function initDB() {
            return new Promise((resolve, reject) => {
                if (!window.indexedDB) {
                    console.warn("IndexedDB no soportado por este navegador. Juego Personalizado no funcionará.");
                    alert("Tu navegador no soporta IndexedDB, necesario para guardar escenarios personalizados.");
                    reject("IndexedDB not supported");
                    return;
                }
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onupgradeneeded = (event) => {
                    const dbInstance = event.target.result;
                    if (!dbInstance.objectStoreNames.contains(STORE_NAME)) {
                        const store = dbInstance.createObjectStore(STORE_NAME, { keyPath: "id", autoIncrement: true });
                        store.createIndex("name", "name", { unique: false });
                    }
                    console.log("IndexedDB: Actualización/creación de base de datos completada.");
                };
                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log("IndexedDB: Conexión exitosa.");
                    resolve(db);
                };
                request.onerror = (event) => {
                    console.error("IndexedDB: Error al abrir la base de datos", event.target.error);
                    reject(event.target.error);
                };
            });
        }
        function saveScenarioDB(scenarioData) {
            return new Promise((resolve, reject) => {
                if (!db) { reject("DB no inicializada"); return; }
                const transaction = db.transaction([STORE_NAME], "readwrite");
                const store = transaction.objectStore(STORE_NAME);
                let request;
                let dataToStore;
                if (scenarioData.id !== null && scenarioData.id !== undefined) {
                     dataToStore = { ...scenarioData };
                     request = store.put(dataToStore);
                } else {
                     const { id, ...dataWithoutId } = scenarioData;
                     dataToStore = dataWithoutId;
                     request = store.add(dataToStore);
                }
                request.onsuccess = (event) => {
                    const resultId = event.target.result;
                    console.log("Escenario guardado/actualizado en DB:", scenarioData.name, "ID asignado/actualizado:", resultId);
                    scenarioData.id = resultId;
                    resolve(scenarioData);
                };
                request.onerror = (event) => {
                    console.error("Error al guardar escenario en DB:", event.target.error);
                    if (event.target.error.name === 'ConstraintError') {
                        alert("Error de restricción al guardar el escenario. Puede que ya exista un escenario con un nombre o identificador similar (si hay reglas de unicidad). Revisa la consola.");
                    } else if (event.target.error.name === 'DataError') {
                         alert("Error de datos al guardar el escenario. Revisa el formato o los valores. Revisa la consola.");
                    }
                    reject(event.target.error);
                };
            });
        }
        function getAllScenariosDB() {
            return new Promise((resolve, reject) => {
                if (!db) { resolve([]); return; }
                const transaction = db.transaction([STORE_NAME], "readonly");
                const store = transaction.objectStore(STORE_NAME);
                const request = store.getAll();
                request.onsuccess = () => { resolve(request.result); };
                request.onerror = (event) => {
                    console.error("Error al obtener todos los escenarios:", event.target.error);
                    reject(event.target.error);
                };
            });
        }
        function getScenarioByIdDB(id) {
            return new Promise((resolve, reject) => {
                if (!db) { reject("DB no inicializada"); return; }
                const transaction = db.transaction([STORE_NAME], "readonly");
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get(id);
                request.onsuccess = () => { resolve(request.result);};
                request.onerror = (event) => {
                    console.error("Error al obtener escenario por ID:", id, event.target.error);
                    reject(event.target.error);
                };
            });
        }
        function deleteScenarioDB(id) {
            return new Promise((resolve, reject) => {
                if (!db) { reject("DB no inicializada"); return; }
                const transaction = db.transaction([STORE_NAME], "readwrite");
                const store = transaction.objectStore(STORE_NAME);
                const request = store.delete(id);
                request.onsuccess = () => {
                    console.log("Escenario eliminado de DB, ID:", id);
                    resolve();
                };
                request.onerror = (event) => {
                    console.error("Error al eliminar escenario de DB:", event.target.error);
                    reject(event.target.error);
                };
            });
        }

        function preloadTextures(callback) {
            let texturesToLoad = textureURLs.length; if (texturesToLoad === 0) { console.log("No hay texturas definidas para cargar."); selectRandomTextures(); callback(); return; } textureURLs.forEach((url, index) => { textureLoader.load( url, (texture) => { texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping; loadedTextures[index] = texture; texturesToLoad--; if (texturesToLoad === 0) { console.log("Todas las texturas cargadas exitosamente."); selectRandomTextures(); callback(); } }, undefined, (error) => { console.error('Error al cargar textura:', url, error); texturesToLoad--; if (texturesToLoad === 0) { console.warn("Algunas texturas no pudieron cargarse. Continuando con las disponibles..."); selectRandomTextures(); callback(); } } ); });
        }

        function selectRandomTextures() {
            if (loadedTextures.length === 0) { console.warn("No hay texturas cargadas para seleccionar. Se usarán colores sólidos."); floorTexture = null; wallTexture = null; crackedTexture = null; return; } const validTextures = loadedTextures.filter(t => t); if (validTextures.length === 0) { console.warn("Todas las texturas cargadas son inválidas. Se usarán colores sólidos."); floorTexture = null; wallTexture = null; crackedTexture = null; return; }

            let floorTextureIndex = Math.floor(Math.random() * validTextures.length);
            floorTexture = validTextures[floorTextureIndex].clone();
            floorTexture.needsUpdate = true;

            let wallTextureIndex;
            if (validTextures.length > 1) {
                do { wallTextureIndex = Math.floor(Math.random() * validTextures.length); } while (wallTextureIndex === floorTextureIndex);
                wallTexture = validTextures[wallTextureIndex].clone();
            } else {
                wallTexture = validTextures[0].clone();
                console.warn("Solo una textura válida disponible, usándola para suelo y paredes.");
            }
            wallTexture.needsUpdate = true;

            crackedTexture = floorTexture.clone();
            crackedTexture.needsUpdate = true;

            if (renderer && renderer.capabilities) {
                const maxAnisotropy = renderer.capabilities.getMaxAnisotropy();
                if (floorTexture) floorTexture.anisotropy = maxAnisotropy;
                if (wallTexture) wallTexture.anisotropy = maxAnisotropy;
                if (crackedTexture) crackedTexture.anisotropy = maxAnisotropy;
            }

            console.log("Textura suelo seleccionada:", floorTexture ? floorTexture.image.src : "Ninguna (color sólido)");
            console.log("Textura pared seleccionada:", wallTexture ? wallTexture.image.src : "Ninguna (color sólido)");
            console.log("Textura agrietada seleccionada (base):", crackedTexture ? crackedTexture.image.src : "Ninguna");
        }


        function init(customMazeData = null) {
            if (scene) {
                while(scene.children.length > 0){
                    const object = scene.children[0];
                    if(object.geometry) object.geometry.dispose();
                    if(object.material){
                        if(Array.isArray(object.material)){
                            object.material.forEach(material => material.dispose());
                        } else {
                            object.material.dispose();
                        }
                    }
                    scene.remove(object);
                }
            }
            if (renderer) { gameActive = false; }
            collidableObjects = [];
            interactiveObjects = [];
            staticTorches = [];
            pitTrapObjects = [];
            playerFallingIntoPit = null;


            scene = new THREE.Scene(); scene.background = new THREE.Color(0x050508); scene.fog = new THREE.Fog(0x050508, 10, 35);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            if (!renderer) {
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.shadowMap.enabled = true; renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 0.8;
                containerDiv.appendChild(renderer.domElement);

                if (isTouchDevice) {
                    if (!touchControlsSetupDone) setupTouchControls();
                } else {
                    if (!keyboardControlsSetupDone) setupKeyboardAndMouseControls();
                }
            }


            clock = new THREE.Clock();
            const ambientLight = new THREE.AmbientLight(0x404040, 0.15); scene.add(ambientLight);
            minimapCanvas = document.getElementById('minimapCanvas');
            minimapCanvas.width = minimapWidth; minimapCanvas.height = minimapHeight; minimapCtx = minimapCanvas.getContext('2d');
            if (!minimapCtx) { console.error("No se pudo obtener el contexto 2D del minimapa."); }

            if (customMazeData) {
                console.log("Iniciando con laberinto personalizado:", customMazeData.name);
                maze = JSON.parse(JSON.stringify(customMazeData.grid));
                currentMazeLayout = JSON.parse(JSON.stringify(maze));
                currentMazeWidth = customMazeData.width;
                currentMazeHeight = customMazeData.height;
            } else {
                console.log("Iniciando con laberinto autogenerado.");
                currentMazeWidth = DEFAULT_MAZE_WIDTH;
                currentMazeHeight = DEFAULT_MAZE_HEIGHT;
                maze = generateMaze(currentMazeWidth, currentMazeHeight);
                currentMazeLayout = JSON.parse(JSON.stringify(maze));
            }

            visibilityMaze = [];
            for (let z = 0; z < currentMazeHeight; z++) {
                visibilityMaze[z] = [];
                for (let x = 0; x < currentMazeWidth; x++) {
                    visibilityMaze[z][x] = false;
                }
            }

            buildMazeGeometry(currentMazeWidth, currentMazeHeight, currentMazeLayout);

            const playerGeometry = new THREE.CylinderGeometry(PLAYER_RADIUS, PLAYER_RADIUS, PLAYER_HEIGHT, 16);
            const playerMaterial = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.6 });
            player = new THREE.Mesh(playerGeometry, playerMaterial);
            player.castShadow = true; player.rotation.order = 'YXZ';

            const startPos = findCell(5, maze, currentMazeWidth, currentMazeHeight);
            if (startPos) {
                initialPlayerPosition.set( (startPos.x - currentMazeWidth / 2 + 0.5) * CELL_SIZE, PLAYER_HEIGHT / 2 + 0.01, (startPos.z - currentMazeHeight / 2 + 0.5) * CELL_SIZE );
            } else {
                console.warn("No se encontró celda de inicio (5) en el laberinto. Colocando en el centro del primer camino disponible o (0,0).");
                let fallbackStart = findCell(1, maze, currentMazeWidth, currentMazeHeight);
                if (!fallbackStart) fallbackStart = {x: Math.floor(currentMazeWidth/2), y: Math.floor(currentMazeHeight/2)};
                if (maze[fallbackStart.z] && maze[fallbackStart.z][fallbackStart.x] === 0) {
                     fallbackStart = {x:1,z:1};
                }
                initialPlayerPosition.set( (fallbackStart.x - currentMazeWidth / 2 + 0.5) * CELL_SIZE, PLAYER_HEIGHT / 2 + 0.01, (fallbackStart.z - currentMazeHeight / 2 + 0.5) * CELL_SIZE );
            }
            player.position.copy(initialPlayerPosition);
            playerVelocity.set(0,0,0);
            playerOnGround = true;
            scene.add(player);

            playerTorchLight = new THREE.PointLight( TORCH_COLOR, TORCH_PLAYER_INTENSITY, TORCH_PLAYER_DISTANCE, TORCH_PLAYER_DECAY );
            playerTorchLight.castShadow = true;
            playerTorchLight.shadow.mapSize.width = 512; playerTorchLight.shadow.mapSize.height = 512; playerTorchLight.shadow.camera.near = 0.1; playerTorchLight.shadow.camera.far = TORCH_PLAYER_DISTANCE;
            const lightPosX = PLAYER_RADIUS + 0.2; const lightPosY = PLAYER_HEIGHT * 0.45; const lightPosZ = PLAYER_RADIUS + 0.3;
            originalPlayerTorchLightPosition.set(lightPosX, lightPosY, lightPosZ);
            playerTorchLight.position.copy(originalPlayerTorchLightPosition);
            playerTorchLight.userData.baseIntensity = TORCH_PLAYER_INTENSITY;
            player.add(playerTorchLight);

            const torchHolderMat = new THREE.MeshStandardMaterial({ color: 0x604020, roughness: 0.7 }); const flameMat = new THREE.MeshBasicMaterial({ color: 0xffd080, transparent: true, opacity: FLAME_BASE_OPACITY, blending: THREE.AdditiveBlending, depthWrite: false }); const holderGeom = new THREE.CylinderGeometry(0.08, 0.1, 0.7, 8); const flameGeom = new THREE.SphereGeometry(0.2, 10, 8);
            playerTorchGroup = new THREE.Group();
            const torchHolder = new THREE.Mesh(holderGeom, torchHolderMat); playerTorchFlameMesh = new THREE.Mesh(flameGeom, flameMat); torchHolder.position.y = -0.35; playerTorchFlameMesh.position.y = 0.1; playerTorchGroup.add(torchHolder); playerTorchGroup.add(playerTorchFlameMesh);
            originalPlayerTorchGroupPosition.set(lightPosX, lightPosY, lightPosZ);
            originalPlayerTorchGroupRotation.set(Math.PI / 10, 0, -Math.PI / 12, 'YXZ');
            playerTorchGroup.position.copy(originalPlayerTorchGroupPosition);
            playerTorchGroup.rotation.copy(originalPlayerTorchGroupRotation);
            player.add(playerTorchGroup);

            const ceilingSize = Math.max(currentMazeWidth, currentMazeHeight) * CELL_SIZE * 1.2;
            const ceilingGeometry = new THREE.PlaneGeometry(ceilingSize, ceilingSize);
            const ceilingMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, side: THREE.DoubleSide, roughness: 0.9 }).clone();
            if (wallTexture) {
                ceilingMaterial.map = wallTexture.clone(); ceilingMaterial.map.needsUpdate = true; ceilingMaterial.color.set(0xffffff);
                ceilingMaterial.map.repeat.set(ceilingSize / (CELL_SIZE * 2), ceilingSize / (CELL_SIZE * 2));
            }
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.position.y = WALL_HEIGHT + 0.1; ceiling.rotation.x = Math.PI / 2; ceiling.receiveShadow = true; ceiling.userData = { isCeiling: true, originalOpacity: 1.0, isTransparentCapable: true }; scene.add(ceiling); collidableObjects.push(ceiling);

            updateRendererAndCameraSize();

            player.visible = !isFirstPersonView;
            player.castShadow = !isFirstPersonView;
            if (playerTorchGroup) playerTorchGroup.visible = !isFirstPersonView;

            cameraPhi = Math.PI / 3;
            cameraTheta = 0;
            updateCamera();
            gameActive = true;
            if (!animationFrameId) {
                 animate();
            }
        }

        function generateMaze(width, height) {
            let matrix = []; for (let y = 0; y < height; y++) { matrix[y] = []; for (let x = 0; x < width; x++) matrix[y][x] = 0; }
            let stack = [];
            let startX = 1; let startY = 1;
            matrix[startY][startX] = 1;
            stack.push({ x: startX, y: startY });
            function isValid(x, y, currentMatrix) { return y >= 0 && y < height && x >= 0 && x < width && currentMatrix[y][x] === 0; }
            while (stack.length > 0) {
                let current = stack[stack.length - 1];
                let neighbors = [];
                let potential = [ { x: current.x, y: current.y - 2, wallX: current.x, wallY: current.y - 1 }, { x: current.x, y: current.y + 2, wallX: current.x, wallY: current.y + 1 }, { x: current.x + 2, y: current.y, wallX: current.x + 1, wallY: current.y }, { x: current.x - 2, y: current.y, wallX: current.x - 1, wallY: current.y } ];
                potential.forEach(p => { if (isValid(p.x, p.y, matrix)) { neighbors.push(p); } });
                if (neighbors.length > 0) { let next = neighbors[Math.floor(Math.random() * neighbors.length)]; matrix[next.y][next.x] = 1; matrix[next.wallY][next.wallX] = 1; stack.push({ x: next.x, y: next.y });
                } else { stack.pop(); }
            }
            if (matrix[1] && matrix[1][1] !== undefined) matrix[1][1] = 5;
            let deadEnds = findDeadEnds(matrix, width, height);
            let endPlaced = false;
            let potentialEndPos = [];
            for (let y = 1; y < height - 1; y++) { for (let x = 1; x < width - 1; x++) { if (matrix[y][x] === 1) { if (Math.abs(x - startX) + Math.abs(y - startY) > (width + height) / 2.5) { potentialEndPos.push({ x, y }); } } } }
            if (potentialEndPos.length > 0) { let endPos = potentialEndPos.find(p => deadEnds.some(d => d.x === p.x && d.y === p.y)); if (!endPos) { endPos = potentialEndPos[Math.floor(Math.random() * potentialEndPos.length)]; } if(matrix[endPos.y] && matrix[endPos.y][endPos.x] !== undefined) matrix[endPos.y][endPos.x] = 6; endPlaced = true; }
            if (!endPlaced) { const endY = height - 2; const endX = width - 2; if (matrix[endY] && matrix[endY][endX] !== undefined) { if (matrix[endY][endX] === 0) { matrix[endY][endX] = 6; if (matrix[endY-1] && matrix[endY-1][endX] === 0) matrix[endY-1][endX] = 1; else if (matrix[endY+1] && matrix[endY+1][endX] === 0) matrix[endY+1][endX] = 1; else if (matrix[endY][endX-1] === 0) matrix[endY][endX-1] = 1; else if (matrix[endY][endX+1] === 0) matrix[endY][endX+1] = 1; } else { matrix[endY][endX] = 6; } } console.warn("Fallback para colocar el punto final."); }
            return matrix;
        }
        function findCell(type, targetMaze, mazeW, mazeH) { for (let z = 0; z < mazeH; z++) { for (let x = 0; x < mazeW; x++) { if (targetMaze[z] && targetMaze[z][x] === type) return { x, z }; } } return null; }
        function findDeadEnds(targetMaze, mazeW, mazeH) { let deadEnds = []; for (let y = 1; y < mazeH - 1; y++) { for (let x = 1; x < mazeW - 1; x++) { if (targetMaze[y][x] !== 0) { let pathNeighbors = 0; if (targetMaze[y+1] && targetMaze[y+1][x] !== 0) pathNeighbors++; if (targetMaze[y-1] && targetMaze[y-1][x] !== 0) pathNeighbors++; if (targetMaze[y][x+1] !== 0) pathNeighbors++; if (targetMaze[y][x-1] !== 0) pathNeighbors++; if (pathNeighbors === 1) { deadEnds.push({ x, y }); } } } } return deadEnds; }

        function buildMazeGeometry(mazeW, mazeH, layout) {
            collidableObjects = [];
            interactiveObjects = [];
            staticTorches = [];
            pitTrapObjects = [];
            endZone = null;

            const wallMaterialBase = new THREE.MeshStandardMaterial({
                map: wallTexture ? wallTexture.clone() : null,
                roughness: 0.9, metalness: 0.1,
                color: wallTexture ? 0xffffff : 0x605548
            });
            if (wallMaterialBase.map) wallMaterialBase.map.needsUpdate = true;


            const mainFloorMaterial = new THREE.MeshStandardMaterial({
                map: floorTexture ? floorTexture.clone() : null,
                roughness: 0.95, metalness: 0.1, side: THREE.DoubleSide,
                color: floorTexture ? 0xffffff : 0x444038
            });
            if (mainFloorMaterial.map) {
                mainFloorMaterial.map.needsUpdate = true;
                mainFloorMaterial.map.wrapS = mainFloorMaterial.map.wrapT = THREE.RepeatWrapping;
                mainFloorMaterial.map.repeat.set(mazeW, mazeH);
            }

            const pitTrapCoverMaterialBase = new THREE.MeshStandardMaterial({
                map: floorTexture ? floorTexture.clone() : null,
                roughness: 0.95, metalness: 0.1,
                color: floorTexture ? 0xffffff : 0x444038
            });
            if (pitTrapCoverMaterialBase.map) {
                 pitTrapCoverMaterialBase.map.needsUpdate = true;
                 pitTrapCoverMaterialBase.map.repeat.set(1,1);
            }

            const endMaterial = new THREE.MeshStandardMaterial({ color: 0x33ff33, emissive: 0x22dd22, transparent: true, opacity: 0.6 });
            const torchHolderMaterial = new THREE.MeshStandardMaterial({ color: 0x504030, roughness: 0.8 });
            const flameMaterialBase = new THREE.MeshBasicMaterial({ color: 0xffd080, transparent: true, opacity: FLAME_BASE_OPACITY, blending: THREE.AdditiveBlending, depthWrite: false });

            const wallGeometry = new THREE.BoxGeometry(CELL_SIZE, WALL_HEIGHT, CELL_SIZE);
            const mainFloorGeometry = new THREE.PlaneGeometry(mazeW * CELL_SIZE, mazeH * CELL_SIZE);
            const endGeometry = new THREE.CylinderGeometry(CELL_SIZE * 0.3, CELL_SIZE * 0.3, 0.2, 16);
            const torchHolderGeometry = new THREE.BoxGeometry(0.2, 0.8, 0.2);
            const flameGeometry = new THREE.SphereGeometry(0.25, 10, 8);
            const pitCoverGeometry = new THREE.BoxGeometry(CELL_SIZE, PIT_COVER_THICKNESS, CELL_SIZE);
            const pitHoleGeometry = new THREE.BoxGeometry(CELL_SIZE * 0.95, WALL_HEIGHT * 2, CELL_SIZE * 0.95);

            const mainFloor = new THREE.Mesh(mainFloorGeometry, mainFloorMaterial);
            mainFloor.rotation.x = -Math.PI / 2;
            mainFloor.receiveShadow = true;
            mainFloor.userData = { isFloor: true };
            scene.add(mainFloor);

            let torchLocations = [];
            for (let z = 0; z < mazeH; z++) {
                for (let x = 0; x < mazeW; x++) {
                    if (!layout[z] || layout[z][x] === undefined) { layout[z][x] = 0; }
                    const cellTypeInLayout = layout[z][x];

                    const posX = (x - mazeW / 2 + 0.5) * CELL_SIZE;
                    const posYBase = WALL_HEIGHT / 2;
                    const posZ = (z - mazeH / 2 + 0.5) * CELL_SIZE;

                    if (cellTypeInLayout === 0) {
                        const wallMatInstance = wallMaterialBase.clone();
                        if (wallMatInstance.map) {
                            wallMatInstance.map = wallMaterialBase.map.clone();
                            wallMatInstance.map.needsUpdate = true;
                            wallMatInstance.map.repeat.set(1, WALL_HEIGHT / CELL_SIZE);
                        }
                        const wall = new THREE.Mesh(wallGeometry, wallMatInstance);
                        wall.position.set(posX, posYBase, posZ);
                        wall.castShadow = true; wall.receiveShadow = true;
                        wall.userData = { isWall: true, originalOpacity: 1.0, isTransparentCapable: true };
                        scene.add(wall);
                        collidableObjects.push(wall);
                    } else if (cellTypeInLayout === BROKEN_PIT_TRAP_CELL_TYPE_LAYOUT) {
                        const pitHole = new THREE.Mesh(pitHoleGeometry, PIT_HOLE_MATERIAL);
                        pitHole.position.set(posX, -WALL_HEIGHT, posZ);
                        pitHole.visible = true;
                        scene.add(pitHole);
                        pitTrapObjects.push({ mesh: null, holeMesh: pitHole, state: 'broken', gridX: x, gridZ: z, worldX: posX, worldZ: posZ, hasBeenRevealedByActivation: true });
                    } else if (cellTypeInLayout === PIT_TRAP_CELL_TYPE) {
                        const pitCoverMatInstance = pitTrapCoverMaterialBase.clone();
                        if (pitCoverMatInstance.map) {
                            pitCoverMatInstance.map = pitTrapCoverMaterialBase.map.clone();
                            pitCoverMatInstance.map.needsUpdate = true;
                            pitCoverMatInstance.map.repeat.set(1,1);
                        }
                        const pitCover = new THREE.Mesh(pitCoverGeometry, pitCoverMatInstance);
                        pitCover.position.set(posX, -PIT_COVER_THICKNESS / 2, posZ);
                        pitCover.castShadow = true; pitCover.receiveShadow = true;
                        pitCover.userData = { isPitTrapCover: true, gridX: x, gridZ: z, isCollidable: true };
                        scene.add(pitCover);
                        collidableObjects.push(pitCover);

                        const pitHole = new THREE.Mesh(pitHoleGeometry, PIT_HOLE_MATERIAL);
                        pitHole.position.set(posX, -WALL_HEIGHT, posZ);
                        pitHole.visible = false;
                        scene.add(pitHole);
                        pitTrapObjects.push({ mesh: pitCover, holeMesh: pitHole, state: 'intact', gridX: x, gridZ: z, worldX: posX, worldZ: posZ, hasBeenRevealedByActivation: false });
                    } else {
                        if (Math.random() < STATIC_TORCH_FREQUENCY) {
                            let possibleTorchWalls = [];
                            if (z > 0 && layout[z-1][x] === 0) possibleTorchWalls.push({ side: 'N' });
                            if (z < mazeH - 1 && layout[z+1][x] === 0) possibleTorchWalls.push({ side: 'S' });
                            if (x > 0 && layout[z][x-1] === 0) possibleTorchWalls.push({ side: 'W' });
                            if (x < mazeW - 1 && layout[z][x+1] === 0) possibleTorchWalls.push({ side: 'E' });
                            if (possibleTorchWalls.length > 0) {
                                const chosenWallData = possibleTorchWalls[Math.floor(Math.random() * possibleTorchWalls.length)];
                                let tooClose = torchLocations.some(loc => Math.abs(loc.x - posX) < CELL_SIZE * 1.5 && Math.abs(loc.z - posZ) < CELL_SIZE * 1.5 );
                                if (!tooClose) { addStaticTorch(posX, posZ, chosenWallData.side, torchHolderGeometry, flameGeometry, torchHolderMaterial, flameMaterialBase, mazeW, mazeH); torchLocations.push({x: posX, z: posZ}); }
                            }
                        }
                        if (cellTypeInLayout === 6) {
                            endZone = new THREE.Mesh(endGeometry, endMaterial);
                            endZone.position.set(posX, 0.1, posZ);
                            endZone.userData = { type: 'end' };
                            scene.add(endZone);
                            interactiveObjects.push(endZone);
                        }
                    }
                }
            }
        }

        function addStaticTorch(pathCellX, pathCellZ, attachSide, holderGeom, flameGeom, holderMat, flameMatBase, mazeW, mazeH) {
            const torchY = WALL_HEIGHT * 0.6; const holder = new THREE.Mesh(holderGeom, holderMat.clone()); const flameMaterial = flameMatBase.clone(); const flame = new THREE.Mesh(flameGeom, flameMaterial); const light = new THREE.PointLight( TORCH_COLOR, TORCH_STATIC_INTENSITY, TORCH_STATIC_DISTANCE, TORCH_STATIC_DECAY ); light.castShadow = false; light.userData.baseIntensity = TORCH_STATIC_INTENSITY; staticTorches.push({ light: light, flameMesh: flame }); const torchOffsetFromWall = TORCH_WALL_OFFSET; const halfCell = CELL_SIZE / 2; let torchPosX = pathCellX; let torchPosZ = pathCellZ; let holderRotationY = 0;
            if (attachSide === 'N') { torchPosZ = pathCellZ - halfCell + torchOffsetFromWall; holderRotationY = Math.PI; } else if (attachSide === 'S') { torchPosZ = pathCellZ + halfCell - torchOffsetFromWall; holderRotationY = 0; } else if (attachSide === 'W') { torchPosX = pathCellX - halfCell + torchOffsetFromWall; holderRotationY = Math.PI / 2; } else if (attachSide === 'E') { torchPosX = pathCellX + halfCell - torchOffsetFromWall; holderRotationY = -Math.PI / 2; }
            holder.position.set(torchPosX, torchY, torchPosZ); holder.rotation.y = holderRotationY; flame.position.set(torchPosX, torchY + 0.5, torchPosZ); light.position.set(torchPosX, torchY + 0.4, torchPosZ); scene.add(holder); scene.add(flame); scene.add(light);
        }


        let touchControlsSetupDone = false;
        function isInsideUIScreen(target) { return target.closest('#loading-screen') || target.closest('#custom-game-screen') || target.closest('#scenario-editor-screen'); }
        function updateJoystickThumb() { const dX=joystickCurrentPos.x-joystickStartPos.x, dY=joystickCurrentPos.y-joystickStartPos.y, dist=Math.sqrt(dX*dX+dY*dY); const angle=Math.atan2(dY,dX); const tD=Math.min(dist, JOYSTICK_VISUAL_RADIUS/2-joystickThumb.offsetWidth/4); const tX=Math.cos(angle)*tD, tY=Math.sin(angle)*tD; joystickThumb.style.transform=`translate(${tX}px, ${tY}px)`; }
        function updateMovementFromJoystick() {
            const dx = joystickCurrentPos.x - joystickStartPos.x;
            const dy = joystickCurrentPos.y - joystickStartPos.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist === 0) {
                moveForward = 0; moveRight = 0; return;
            }
            let normalizedX = dx / JOYSTICK_EFFECTIVE_RADIUS;
            let normalizedY = dy / JOYSTICK_EFFECTIVE_RADIUS;
            const magnitude = Math.min(1.0, dist / JOYSTICK_EFFECTIVE_RADIUS);
            if (magnitude < JOYSTICK_DEADZONE) {
                moveForward = 0; moveRight = 0; return;
            }
            moveForward = -normalizedY * magnitude;
            moveRight   =  normalizedX * magnitude;
            moveForward = Math.max(-1, Math.min(1, moveForward));
            moveRight   = Math.max(-1, Math.min(1, moveRight));
        }
        function setupTouchControls() {
            if (touchControlsSetupDone) return;
            document.body.addEventListener('pointerdown', handlePointerDown); document.body.addEventListener('pointermove', handlePointerMove); document.body.addEventListener('pointerup', handlePointerEnd); document.body.addEventListener('pointercancel', handlePointerEnd);
            jumpButton.addEventListener('touchstart', (e) => { e.preventDefault(); if (playerOnGround && gameActive && !playerFallingIntoPit) playerVelocity.y = JUMP_VELOCITY; }, { passive: false });
            actionButton.addEventListener('touchstart', (e) => { e.preventDefault(); if (gameActive) toggleView(); }, { passive: false });
            touchControlsSetupDone = true;
        }
        function handlePointerDown(event) { if (isInsideUIScreen(event.target)) { return; } if (event.target === jumpButton || event.target === actionButton || event.target.closest('#minimapCanvas')) return; event.preventDefault(); const tX=event.clientX, tY=event.clientY, sW=window.innerWidth; if (tX < sW/2 && joystickPointerId===-1){ joystickPointerId=event.pointerId; joystickStartPos={x:tX,y:tY}; joystickCurrentPos={x:tX,y:tY}; joystickArea.style.display='flex'; joystickArea.style.left=`${tX}px`; joystickArea.style.top=`${tY}px`; joystickThumb.style.transform='translate(0px, 0px)'; updateMovementFromJoystick(); } else if (tX >= sW/2 && cameraPointerId===-1){ cameraPointerId=event.pointerId; cameraTouchStartPos={x:tX, y:tY}; } }
        function handlePointerMove(event) { if (isInsideUIScreen(event.target)) { return; } if (event.target === jumpButton || event.target === actionButton || event.target.closest('#minimapCanvas')) return; event.preventDefault(); if(event.pointerId===joystickPointerId){ joystickCurrentPos={x:event.clientX, y:event.clientY}; updateJoystickThumb(); updateMovementFromJoystick(); } else if(event.pointerId===cameraPointerId){ const tX=event.clientX, tY=event.clientY; updateCameraLook(tX-cameraTouchStartPos.x, tY-cameraTouchStartPos.y); cameraTouchStartPos={x:tX,y:tY}; } }
        function handlePointerEnd(event) { if (isInsideUIScreen(event.target)) { return; } if (event.target === jumpButton || event.target === actionButton || event.target.closest('#minimapCanvas')) return; if(event.pointerId===joystickPointerId){ joystickPointerId=-1; joystickArea.style.display='none'; moveForward=0; moveRight=0; } else if(event.pointerId===cameraPointerId){ cameraPointerId=-1; } }


        let keyboardControlsSetupDone = false;
        function setupKeyboardAndMouseControls() {
            if (keyboardControlsSetupDone) return;
            document.addEventListener('keydown', (event) => { keyStates[event.code] = true; handleKeyPress(event.code); }); document.addEventListener('keyup', (event) => { keyStates[event.code] = false; });
            renderer.domElement.addEventListener('mousedown', (event) => { if (event.button === 0 && !isPointerLocked && gameActive) { renderer.domElement.requestPointerLock(); } });
            renderer.domElement.addEventListener('contextmenu', (event) => { event.preventDefault(); if (gameActive) { toggleView(); } });
            document.addEventListener('pointerlockchange', () => { isPointerLocked = document.pointerLockElement === renderer.domElement; if (isPointerLocked) { if (pointerLockInfoDiv) pointerLockInfoDiv.style.display = 'none'; renderer.domElement.style.cursor = 'none'; } else { if (pointerLockInfoDiv && !isTouchDevice) pointerLockInfoDiv.style.display = 'block'; renderer.domElement.style.cursor = 'grab'; keyStates = {}; moveForward=0; moveRight=0; } }, false);
            document.addEventListener('pointerlockerror', () => { console.error('Error blocking mouse pointer.'); if (pointerLockInfoDiv && !isTouchDevice) pointerLockInfoDiv.style.display = 'block'; }, false);
            document.addEventListener('mousemove', (event) => { if (isPointerLocked && gameActive) { updateCameraLook(event.movementX, event.movementY); } });
            keyboardControlsSetupDone = true;
        }
        function handleKeyPress(code) { if (!gameActive) return; if (code === 'KeyV') { toggleView(); } }
        function updateMovementFromKeyboard() { if (isTouchDevice || !isPointerLocked || playerFallingIntoPit) { moveForward=0; moveRight=0; return; } let newMoveForward = 0; let newMoveRight = 0; if (keyStates['KeyW'] || keyStates['ArrowUp']) newMoveForward = 1; if (keyStates['KeyS'] || keyStates['ArrowDown']) newMoveForward = -1; if (keyStates['KeyA'] || keyStates['ArrowLeft']) newMoveRight = -1; if (keyStates['KeyD'] || keyStates['ArrowRight']) newMoveRight = 1; if (joystickPointerId === -1) { moveForward = newMoveForward; moveRight = newMoveRight; } if (keyStates['Space'] && playerOnGround) { playerVelocity.y = JUMP_VELOCITY; } }
        function updateCameraLook(deltaX, deltaY) { cameraTheta -= deltaX * CAMERA_SENSITIVITY; cameraPhi -= deltaY * CAMERA_SENSITIVITY; cameraPhi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraPhi)); }


        function toggleView() { if (!player || !camera || !playerTorchLight || !playerTorchGroup || !scene) return; isFirstPersonView = !isFirstPersonView; player.visible = !isFirstPersonView; if (isFirstPersonView) { showMessage("Vista: Primera Persona", 1500); playerTorchLight.castShadow = false; if (playerTorchLight.parent) playerTorchLight.parent.remove(playerTorchLight); scene.add(playerTorchLight); if (playerTorchGroup.parent) playerTorchGroup.parent.remove(playerTorchGroup); camera.add(playerTorchGroup); playerTorchGroup.position.copy(FPS_TORCH_GROUP_OFFSET); playerTorchGroup.rotation.copy(FPS_TORCH_GROUP_ROTATION); playerTorchGroup.visible = true; } else { showMessage("Vista: Tercera Persona", 1500); playerTorchLight.castShadow = true; if (playerTorchLight.parent === scene) scene.remove(playerTorchLight); player.add(playerTorchLight); playerTorchLight.position.copy(originalPlayerTorchLightPosition); playerTorchLight.rotation.set(0,0,0); if (playerTorchGroup.parent === camera) camera.remove(playerTorchGroup); player.add(playerTorchGroup); playerTorchGroup.position.copy(originalPlayerTorchGroupPosition); playerTorchGroup.rotation.copy(originalPlayerTorchGroupRotation); playerTorchGroup.visible = true; } updateCamera(); }


        function updatePlayer(deltaTime) {
            if (!gameActive || !player) return;
            if (!isTouchDevice) { updateMovementFromKeyboard(); }

            let currentSpeed = PLAYER_SPEED;
            let isSprinting = (!isTouchDevice && keyStates['ShiftLeft'] && moveForward > 0);
            if (playerOnGround && !playerFallingIntoPit && ( (moveForward > SPRINT_THRESHOLD && joystickPointerId !== -1) || isSprinting) ) {
                currentSpeed = SPRINT_SPEED;
            }

            let dampingFactor = playerOnGround ? 0.85 : 0.98;
            if (!playerOnGround) playerVelocity.y += GRAVITY * deltaTime;
            playerVelocity.y = Math.max(playerVelocity.y, -30);

            const previousY = player.position.y;

            if (!playerFallingIntoPit) {
                const forward = new THREE.Vector3(0, 0, -1); forward.applyQuaternion(player.quaternion); forward.y = 0; forward.normalize();
                const right = new THREE.Vector3(1, 0, 0); right.applyQuaternion(player.quaternion); right.y = 0; right.normalize();
                const targetVelocityXZ = new THREE.Vector3();
                targetVelocityXZ.addScaledVector(forward, -moveForward * currentSpeed);
                targetVelocityXZ.addScaledVector(right,   -moveRight * currentSpeed);
                playerVelocity.x += (targetVelocityXZ.x - playerVelocity.x) * 0.25;
                playerVelocity.z += (targetVelocityXZ.z - playerVelocity.z) * 0.25;
            } else {
                playerVelocity.x *= 0.9;
                playerVelocity.z *= 0.9;
            }
            playerVelocity.x *= dampingFactor;
            playerVelocity.z *= dampingFactor;

            const deltaPosition = playerVelocity.clone().multiplyScalar(deltaTime);
            playerOnGround = false;
            const collisionSizeVec = new THREE.Vector3(PLAYER_RADIUS * 2, PLAYER_HEIGHT, PLAYER_RADIUS * 2);

            const verticalCheckCenter = player.position.clone().add(new THREE.Vector3(0, deltaPosition.y, 0));
            collisionCheckTempBox.setFromCenterAndSize(verticalCheckCenter, collisionSizeVec);

            for (const obj of collidableObjects) {
                if (obj.userData.isFloor || obj.userData.isCeiling) continue;
                if (obj.userData.isPitTrapCover && !obj.userData.isCollidable) continue;

                const oB = new THREE.Box3().setFromObject(obj);
                if (collisionCheckTempBox.intersectsBox(oB)) {
                    if (deltaPosition.y < 0 && collisionCheckTempBox.min.y < oB.max.y) {
                        playerVelocity.y = 0;
                        deltaPosition.y = oB.max.y - (player.position.y - PLAYER_HEIGHT / 2) + 0.001;
                        playerOnGround = true;
                    } else if (deltaPosition.y > 0 && collisionCheckTempBox.max.y > oB.min.y) {
                        playerVelocity.y = 0;
                        deltaPosition.y = oB.min.y - (player.position.y + PLAYER_HEIGHT / 2) - 0.001;
                    }
                    break;
                }
            }

            const groundY = 0;
            const feetY = player.position.y + deltaPosition.y - PLAYER_HEIGHT / 2;

            if (playerFallingIntoPit) {
                if (player.position.y + deltaPosition.y < PIT_FALL_DEPTH) {
                    loseGame("Caíste en un foso!");
                }
            } else {
                if (feetY <= groundY && playerVelocity.y <= 0 && !playerOnGround) {
                    playerVelocity.y = 0;
                    deltaPosition.y = groundY - (player.position.y - PLAYER_HEIGHT / 2);
                    playerOnGround = true;
                }
            }

            player.position.y += deltaPosition.y;

            if (!playerFallingIntoPit) {
                const horizontalCheckPos = player.position.clone().add(new THREE.Vector3(deltaPosition.x, 0, deltaPosition.z));
                collisionCheckTempBox.setFromCenterAndSize(horizontalCheckPos, collisionSizeVec);

                let collisionX = false; let collisionZ = false;
                for (const obj of collidableObjects) {
                    if (obj.userData.isFloor || obj.userData.isCeiling) continue;
                    if (obj.userData.isPitTrapCover && !obj.userData.isCollidable) continue;

                    const oB = new THREE.Box3().setFromObject(obj);

                    const tempBoxX = new THREE.Box3().setFromCenterAndSize(player.position.clone().add(new THREE.Vector3(deltaPosition.x, 0, 0)), collisionSizeVec);
                    if (tempBoxX.intersectsBox(oB)) {
                        if (oB.max.y > player.position.y - PLAYER_HEIGHT/2 && oB.max.y < player.position.y - PLAYER_HEIGHT/2 + PLAYER_STEP_HEIGHT && playerOnGround && deltaPosition.x !== 0) {
                            const stepUpAmount = oB.max.y - (player.position.y - PLAYER_HEIGHT/2) + 0.01;
                            player.position.y += stepUpAmount;
                        } else {
                            collisionX = true;
                        }
                    }
                    const tempBoxZ = new THREE.Box3().setFromCenterAndSize(player.position.clone().add(new THREE.Vector3(0, 0, deltaPosition.z)), collisionSizeVec);
                    if (tempBoxZ.intersectsBox(oB)) {
                         if (oB.max.y > player.position.y - PLAYER_HEIGHT/2 && oB.max.y < player.position.y - PLAYER_HEIGHT/2 + PLAYER_STEP_HEIGHT && playerOnGround && deltaPosition.z !== 0) {
                            const stepUpAmount = oB.max.y - (player.position.y - PLAYER_HEIGHT/2) + 0.01;
                            player.position.y += stepUpAmount;
                        } else {
                            collisionZ = true;
                        }
                    }
                    if (collisionX && collisionZ) break;
                }
                if(collisionX) { playerVelocity.x = 0; deltaPosition.x = 0; }
                if(collisionZ) { playerVelocity.z = 0; deltaPosition.z = 0; }
            }

            player.position.x += deltaPosition.x;
            player.position.z += deltaPosition.z;


            player.rotation.y = cameraTheta + Math.PI;

            if (!playerFallingIntoPit) {
                for (const trap of pitTrapObjects) {
                    if (trap.state === 'intact') {
                        const distSq = player.position.clone().setY(0).distanceToSquared(new THREE.Vector3(trap.worldX, 0, trap.worldZ));
                        if (playerOnGround && distSq < PIT_TRAP_TRIGGER_RADIUS_SQUARED && Math.abs(player.position.y - PLAYER_HEIGHT / 2) < PLAYER_STEP_HEIGHT + 0.01) {
                            triggerPitTrap(trap);
                        }
                    }
                }
            }

            if (endZone && gameActive && !playerFallingIntoPit) {
                const pXZ = new THREE.Vector2(player.position.x, player.position.z);
                const eZXZ = new THREE.Vector2(endZone.position.x, endZone.position.z);
                if (playerOnGround && pXZ.distanceTo(eZXZ) < PLAYER_RADIUS + CELL_SIZE * 0.3) winGame();
            }
        }

        function triggerPitTrap(trap) {
            if (trap.state !== 'intact' || !gameActive) return;

            if (!trap.hasBeenRevealedByActivation) {
                trap.hasBeenRevealedByActivation = true;
            }

            trap.state = 'breaking';
            if (trap.mesh && trap.mesh.userData) trap.mesh.userData.isCollidable = false;
            currentMazeLayout[trap.gridZ][trap.gridX] = BROKEN_PIT_TRAP_CELL_TYPE_LAYOUT;

            if(crackedTexture && trap.mesh && trap.mesh.material.map !== crackedTexture) {
                const newMaterial = trap.mesh.material.clone();
                newMaterial.map = crackedTexture.clone();
                newMaterial.map.needsUpdate = true;
                newMaterial.map.repeat.set(1,1);
                trap.mesh.material = newMaterial;
            }
            if (trap.holeMesh) trap.holeMesh.visible = true;

            if (trap.mesh) {
                new TWEEN.Tween(trap.mesh.rotation)
                    .to({ x: trap.mesh.rotation.x - Math.PI / 2.1 }, PIT_TRAP_BREAK_ANIMATION_TIME * 0.8)
                    .easing(TWEEN.Easing.Quadratic.In)
                    .onComplete(() => {
                         new TWEEN.Tween(trap.mesh.position)
                            .to({ y: -1000 }, PIT_TRAP_BREAK_ANIMATION_TIME * 0.7) // Mover muy abajo
                            .easing(TWEEN.Easing.Quadratic.In)
                            .onComplete(() => {
                                trap.state = 'broken';
                                if(trap.mesh) {
                                     trap.mesh.visible = false;
                                }
                            })
                            .start();
                    })
                    .start();
            }


            const playerGridX = Math.round(player.position.x / CELL_SIZE + currentMazeWidth / 2 - 0.5);
            const playerGridZ = Math.round(player.position.z / CELL_SIZE + currentMazeHeight / 2 - 0.5);

            if (playerGridX === trap.gridX && playerGridZ === trap.gridZ && playerOnGround) {
                playerFallingIntoPit = { x: trap.gridX, z: trap.gridZ };
                playerOnGround = false;
                playerVelocity.y = -1.0;
                showMessage("¡El suelo se rompe!", 2000);
            }
        }


        function updateCamera() { if (!player || !camera) return; if (isFirstPersonView) { camera.position.copy(player.position); camera.position.y += PLAYER_HEIGHT * FIRST_PERSON_EYE_HEIGHT_FACTOR; camera.rotation.order = 'YXZ'; camera.rotation.y = cameraTheta; camera.rotation.x = cameraPhi - CAMERA_PITCH_OFFSET_FPS; camera.rotation.z = 0; camera.updateMatrixWorld(); if (playerTorchLight && playerTorchLight.parent === scene) { lightWorldPosHelper.copy(FPS_TORCH_LIGHT_OFFSET); camera.localToWorld(lightWorldPosHelper); playerTorchLight.position.copy(lightWorldPosHelper); } for (const obj of currentlyTransparentObjects) { if (obj.material && typeof obj.material.opacity !== 'undefined' && obj.userData.isTransparentCapable) { obj.material.transparent = false; obj.material.opacity = obj.userData.originalOpacity || 1.0; } } currentlyTransparentObjects.clear(); } else { const targetPosition = new THREE.Vector3(); const offset = new THREE.Vector3(); offset.x = CAMERA_DISTANCE * Math.sin(cameraPhi) * Math.sin(cameraTheta); offset.y = CAMERA_DISTANCE * Math.cos(cameraPhi) + CAMERA_HEIGHT_OFFSET; offset.z = CAMERA_DISTANCE * Math.sin(cameraPhi) * Math.cos(cameraTheta); targetPosition.copy(player.position).add(offset); const cameraRaycaster = new THREE.Raycaster(); const rayOrigin = player.position.clone().add(new THREE.Vector3(0, PLAYER_HEIGHT * 0.3, 0)); const directionToCamera = targetPosition.clone().sub(rayOrigin).normalize(); const rayLength = rayOrigin.distanceTo(targetPosition); cameraRaycaster.set(rayOrigin, directionToCamera); cameraRaycaster.far = rayLength; const cameraCheckObjects = collidableObjects.filter(obj => obj !== player && !obj.userData.isFloor && obj.userData.isTransparentCapable && !(obj.userData.isPitTrapCover && !obj.userData.isCollidable) ); const intersects = cameraRaycaster.intersectObjects(cameraCheckObjects, false); let objectsToMakeTransparentThisFrame = new Set(); for (const intersect of intersects) { if (intersect.object.userData.isTransparentCapable) { objectsToMakeTransparentThisFrame.add(intersect.object); } } for (const obj of currentlyTransparentObjects) { if (!objectsToMakeTransparentThisFrame.has(obj)) { if (obj.material && typeof obj.material.opacity !== 'undefined' && obj.userData.isTransparentCapable) { obj.material.transparent = false; obj.material.opacity = obj.userData.originalOpacity || 1.0; } } } for (const obj of objectsToMakeTransparentThisFrame) { if (obj.material && typeof obj.material.opacity !== 'undefined' && obj.userData.isTransparentCapable) { obj.material.transparent = true; obj.material.opacity = OBSTACLE_OPACITY; } } currentlyTransparentObjects = objectsToMakeTransparentThisFrame; let finalCameraPosition = targetPosition.clone(); if (intersects.length > 0) { let closestDistance = rayLength; for (const intersect of intersects) { if (intersect.distance < closestDistance) { closestDistance = intersect.distance; } } finalCameraPosition.copy(rayOrigin).addScaledVector(directionToCamera, Math.max(0.5, closestDistance - 0.3)); } finalCameraPosition.y = Math.max(finalCameraPosition.y, player.position.y + MIN_CAMERA_Y_ABOVE_GROUND); camera.position.copy(finalCameraPosition); const lookAtTarget = player.position.clone().add(new THREE.Vector3(0, PLAYER_HEIGHT * 0.3, 0)); camera.lookAt(lookAtTarget); } }
        function drawMinimap() {
            if (!minimapCtx || !player || !currentMazeLayout.length || !visibilityMaze.length || !currentMazeWidth || !currentMazeHeight) return;
            const playerGridX = Math.round(player.position.x / CELL_SIZE + currentMazeWidth / 2 - 0.5);
            const playerGridZ = Math.round(player.position.z / CELL_SIZE + currentMazeHeight / 2 - 0.5);
            minimapCtx.clearRect(0, 0, minimapWidth, minimapHeight); minimapCtx.save(); minimapCtx.translate(minimapWidth / 2, minimapHeight / 2); minimapCtx.rotate(cameraTheta);
            const radius = MINIMAP_RADIUS_CELLS; const cellSizePx = MINIMAP_CELL_SIZE_PX;

            for (let relZ = -radius; relZ <= radius; relZ++) {
                for (let relX = -radius; relX <= radius; relX++) {
                    const checkX = playerGridX + relX; const checkZ = playerGridZ + relZ;
                    let fillColor;
                    if (!visibilityMaze[checkZ] || typeof visibilityMaze[checkZ][checkX] === 'undefined' || !visibilityMaze[checkZ][checkX]) {
                        fillColor = MINIMAP_UNSEEN_COLOR;
                    } else {
                        if (checkX < 0 || checkX >= currentMazeWidth || checkZ < 0 || checkZ >= currentMazeHeight) {
                            fillColor = MINIMAP_UNSEEN_COLOR;
                        } else {
                            const cellTypeInLayout = currentMazeLayout[checkZ][checkX];
                            const originalCellType = maze[checkZ][checkX];

                            if (cellTypeInLayout === 0) fillColor = MINIMAP_WALL_COLOR;
                            else if (cellTypeInLayout === BROKEN_PIT_TRAP_CELL_TYPE_LAYOUT) fillColor = MINIMAP_PITTRAP_BROKEN_COLOR;
                            else if (cellTypeInLayout === 6) fillColor = MINIMAP_END_COLOR;
                            else if (originalCellType === PIT_TRAP_CELL_TYPE) {
                                const trapObject = pitTrapObjects.find(t => t.gridX === checkX && t.gridZ === checkZ);
                                if (trapObject && trapObject.hasBeenRevealedByActivation && cellTypeInLayout === PIT_TRAP_CELL_TYPE) {
                                    fillColor = MINIMAP_PITTRAP_INTACT_COLOR;
                                } else {
                                    fillColor = MINIMAP_PATH_COLOR;
                                }
                            }
                            else fillColor = MINIMAP_PATH_COLOR;
                        }
                    }
                    minimapCtx.fillStyle = fillColor;
                    const drawX = relX * cellSizePx - cellSizePx / 2; const drawY = relZ * cellSizePx - cellSizePx / 2;
                    minimapCtx.fillRect(drawX, drawY, cellSizePx, cellSizePx);
                }
            }
            minimapCtx.restore(); minimapCtx.beginPath(); const playerMarkerSize = cellSizePx * 0.9; const halfSize = playerMarkerSize / 2; minimapCtx.moveTo(minimapWidth / 2, minimapHeight / 2 - halfSize * 0.8); minimapCtx.lineTo(minimapWidth / 2 - halfSize * 0.6, minimapHeight / 2 + halfSize * 0.5); minimapCtx.lineTo(minimapWidth / 2 + halfSize * 0.6, minimapHeight / 2 + halfSize * 0.5); minimapCtx.closePath(); minimapCtx.fillStyle = MINIMAP_PLAYER_COLOR; minimapCtx.fill();
        }
        function hasLineOfSight(x0, z0, x1, z1) { let dx = Math.abs(x1 - x0); let sx = x0 < x1 ? 1 : -1; let dz = -Math.abs(z1 - z0); let sz = z0 < z1 ? 1 : -1; let err = dx + dz; let currentX = x0; let currentZ = z0; let steps = 0; const maxSteps = currentMazeWidth + currentMazeHeight; while (steps < maxSteps) { steps++; if (currentX === x1 && currentZ === z1) return true; if (!(currentX === x0 && currentZ === z0)) { if (currentX >= 0 && currentX < currentMazeWidth && currentZ >= 0 && currentZ < currentMazeHeight) { if (currentMazeLayout[currentZ][currentX] === 0 && maze[currentZ][currentX] === 0) { if (visibilityMaze[currentZ] && typeof visibilityMaze[currentZ][currentX] !== 'undefined') { visibilityMaze[currentZ][currentX] = true; } return false; } } else { return false; } } let e2 = 2 * err; let moved = false; if (e2 >= dz) { if (currentX === x1 && currentZ === z1 && !(currentX === x0 && currentZ === z0)) break; err += dz; currentX += sx; moved = true; } if (e2 <= dx) { if (currentX === x1 && currentZ === z1 && !(currentX === x0 && currentZ === z0)) break; err += dx; currentZ += sz; moved = true; } if (!moved && (currentX !== x1 || currentZ !== z1)) { return false; } } return (currentX === x1 && currentZ === z1); }

        function updateVisibility() {
            if (!player || !visibilityMaze.length || !currentMazeLayout.length || !currentMazeWidth || !currentMazeHeight) return;
            const playerGridX = Math.round(player.position.x / CELL_SIZE + currentMazeWidth / 2 - 0.5);
            const playerGridZ = Math.round(player.position.z / CELL_SIZE + currentMazeHeight / 2 - 0.5);
            const visionRadius = PLAYER_VISION_RADIUS_CELLS;

            if (playerGridX >= 0 && playerGridX < currentMazeWidth && playerGridZ >= 0 && playerGridZ < currentMazeHeight) {
                if(visibilityMaze[playerGridZ]) visibilityMaze[playerGridZ][playerGridX] = true;
            }
            for (let relZ = -visionRadius; relZ <= visionRadius; relZ++) {
                for (let relX = -visionRadius; relX <= visionRadius; relX++) {
                    if (relX === 0 && relZ === 0) continue;
                    if (relX * relX + relZ * relZ <= visionRadius * visionRadius) {
                        const checkX = playerGridX + relX; const checkZ = playerGridZ + relZ;
                        if (checkX >= 0 && checkX < currentMazeWidth && checkZ >= 0 && checkZ < currentMazeHeight) {
                            if (hasLineOfSight(playerGridX, playerGridZ, checkX, checkZ)) {
                                if(visibilityMaze[checkZ]) visibilityMaze[checkZ][checkX] = true;
                            }
                        }
                    }
                }
            }
        }


        let animationFrameId;
        function animate() {
            if (!gameActive && !TWEEN.getAll().length && playerFallingIntoPit === null) {
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                return;
            }
            animationFrameId = requestAnimationFrame(animate);
            const dT = Math.min(0.05, clock.getDelta());
            TWEEN.update();

            if (gameActive || playerFallingIntoPit !== null) {
                updatePlayer(dT);
            }

            if (gameActive) {
                const flicker = (Math.random() - 0.5) * TORCH_FLICKER_AMOUNT;
                if (playerTorchLight && playerTorchLight.userData.baseIntensity) { playerTorchLight.intensity = Math.max(0, playerTorchLight.userData.baseIntensity + flicker); }
                if (playerTorchFlameMesh && playerTorchFlameMesh.material) { const pVO = (Math.random()-0.5)*FLAME_OPACITY_VAR; const pVS = (Math.random()-0.5)*FLAME_SCALE_Y_VAR; playerTorchFlameMesh.material.opacity = Math.max(0.1,Math.min(1.0,FLAME_BASE_OPACITY+pVO)); playerTorchFlameMesh.scale.y = Math.max(0.1,FLAME_BASE_SCALE_Y+pVS); playerTorchFlameMesh.scale.x = playerTorchFlameMesh.scale.z = Math.max(0.1,FLAME_BASE_SCALE_Y*0.8+pVS*0.5); }
                for (const torch of staticTorches) { const sLF = (Math.random()-0.5)*TORCH_FLICKER_AMOUNT*1.1; const vO = (Math.random()-0.5)*FLAME_OPACITY_VAR; const vS = (Math.random()-0.5)*FLAME_SCALE_Y_VAR; if (torch.light?.userData.baseIntensity) { torch.light.intensity = Math.max(0, torch.light.userData.baseIntensity + sLF); } if (torch.flameMesh?.material) { torch.flameMesh.material.opacity = Math.max(0.1,Math.min(1.0,FLAME_BASE_OPACITY+vO)); torch.flameMesh.scale.y = Math.max(0.1,FLAME_BASE_SCALE_Y+vS); torch.flameMesh.scale.x = torch.flameMesh.scale.z = Math.max(0.1,FLAME_BASE_SCALE_Y*0.8 + vS * 0.5); } }
            }
            updateCamera();
            updateVisibility();
            drawMinimap();

            if(renderer && scene && camera) renderer.render(scene, camera);
        }
        function onWindowResize() { updateRendererAndCameraSize(); }
        let messageTimeout = null; function showMessage(text, duration = 2500) { if (messageTimeout) clearTimeout(messageTimeout); messageDiv.textContent = text; messageDiv.style.display = 'block'; messageTimeout = setTimeout(() => { messageDiv.style.display = 'none'; messageTimeout = null; }, duration); }

        function winGame() {
            if (!gameActive) return; gameActive = false; TWEEN.removeAll();
            showMessage("¡HAS ESCAPADO!", 10000); console.log("Juego ganado!");
            if (isPointerLocked && document.pointerLockElement) document.exitPointerLock();
            setTimeout(() => { window.location.reload(); }, 5000);
        }

        function loseGame(reason = "Has perdido.") {
            if (!gameActive && playerFallingIntoPit === null) return;
            gameActive = false;

            showMessage(reason, 3000);
            console.log("Juego perdido:", reason);
            if (isPointerLocked && document.pointerLockElement) document.exitPointerLock();

            setTimeout(() => {
                player.position.copy(initialPlayerPosition);
                playerVelocity.set(0, 0, 0);
                playerOnGround = true;
                playerFallingIntoPit = null;
                moveForward = 0;
                moveRight = 0;
                keyStates = {};
                cameraPhi = Math.PI / 3;
                cameraTheta = player.rotation.y - Math.PI;
                updateCamera();

                for (const trap of pitTrapObjects) {
                    if (trap.state === 'broken' || trap.state === 'breaking') { // También resetear si está 'breaking'
                        trap.state = 'intact';
                        currentMazeLayout[trap.gridZ][trap.gridX] = PIT_TRAP_CELL_TYPE;

                        if (trap.mesh) {
                            trap.mesh.visible = true;
                            trap.mesh.userData.isCollidable = true;
                            trap.mesh.position.set(trap.worldX, -PIT_COVER_THICKNESS / 2, trap.worldZ);
                            trap.mesh.rotation.set(0, 0, 0);
                            if (floorTexture && trap.mesh.material.map !== floorTexture) { // Restaurar material original
                                 // Re-crear el material base para la tapa.
                                const originalCoverMaterial = new THREE.MeshStandardMaterial({
                                    map: floorTexture.clone(), // Usar un clon de la textura de suelo original
                                    roughness: 0.95, metalness: 0.1,
                                    color: floorTexture ? 0xffffff : 0x444038
                                });
                                if (originalCoverMaterial.map) {
                                    originalCoverMaterial.map.needsUpdate = true;
                                    originalCoverMaterial.map.repeat.set(1,1);
                                }
                                trap.mesh.material = originalCoverMaterial;
                            }
                        }
                        if (trap.holeMesh) {
                            trap.holeMesh.visible = false;
                        }
                        // trap.hasBeenRevealedByActivation se MANTIENE true.
                    }
                }
                TWEEN.removeAll();


                gameActive = true;
                if (!animationFrameId && TWEEN.getAll().length === 0) {
                     animate();
                }
                showMessage("Inténtalo de nuevo...", 2000);
            }, 3000);
        }

        function updateRendererAndCameraSize() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            let maxDim = Math.max(width, height);
            let currentMaxRes = isTouchDevice ? MAX_RESOLUTION_DIMENSION_MOBILE : MAX_RESOLUTION_DIMENSION;

            const scaleFactor = maxDim > currentMaxRes ? currentMaxRes / maxDim : 1;
            const renderWidth = Math.floor(width * scaleFactor);
            const renderHeight = Math.floor(height * scaleFactor);

            if(renderer && camera) {
                renderer.setSize(renderWidth, renderHeight, false);
                renderer.domElement.style.width = '100%';
                renderer.domElement.style.height = '100%';
                camera.aspect = renderWidth / renderHeight;
                camera.updateProjectionMatrix();
            }
            console.log(`Render size: ${renderWidth}x${renderHeight} (Touch: ${isTouchDevice}, Scale: ${scaleFactor.toFixed(2)})`);
        }

        function showCustomGameUI() { gameActive = false; if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null;} if (isPointerLocked && document.pointerLockElement) document.exitPointerLock(); if(startOptionsDiv) startOptionsDiv.style.display = 'none'; if(loadingTextElement) loadingTextElement.style.display = 'none'; if(loadingScreenElement) loadingScreenElement.style.display = 'none'; customGameScreen.style.display = 'flex'; scenarioEditorScreen.style.display = 'none'; loadAndDisplayCustomScenarios(); }
        backToMainMenuBtn.addEventListener('click', () => { customGameScreen.style.display = 'none'; if(loadingScreenElement) loadingScreenElement.style.display = 'flex'; if(startOptionsDiv) startOptionsDiv.style.display = 'flex'; });
        async function loadAndDisplayCustomScenarios() { try { const scenarios = await getAllScenariosDB(); customScenarioListUL.innerHTML = ''; if (scenarios && scenarios.length > 0) { noCustomScenariosMsg.style.display = 'none'; scenarios.forEach(scenario => { const listItem = document.createElement('li'); listItem.classList.add('scenario-item'); listItem.innerHTML = `<span>${escapeHTML(scenario.name)} (${scenario.width}x${scenario.height})</span><div class="scenario-actions"><button class="action-btn play-scenario-btn" data-id="${scenario.id}">Jugar</button><button class="action-btn edit-scenario-btn" data-id="${scenario.id}">Editar</button><button class="action-btn export-scenario-btn" data-id="${scenario.id}">Exportar</button><button class="action-btn delete-scenario-btn" data-id="${scenario.id}">Eliminar</button></div>`; customScenarioListUL.appendChild(listItem); }); addScenarioActionListeners(); } else { noCustomScenariosMsg.style.display = 'block'; } } catch (error) { console.error("Error loading scenarios:", error); noCustomScenariosMsg.textContent = "Error loading scenarios."; noCustomScenariosMsg.style.display = 'block'; } }
        function addScenarioActionListeners() { document.querySelectorAll('.play-scenario-btn').forEach(btn => { btn.addEventListener('click', async (e) => { const scenarioId = parseInt(e.target.dataset.id); const scenarioToPlay = await getScenarioByIdDB(scenarioId); if (scenarioToPlay) { customGameScreen.style.display = 'none'; if(loadingTextElement) loadingTextElement.style.display = 'block'; if(loadingScreenElement) loadingScreenElement.style.display = 'flex'; preloadTextures(() => { init(scenarioToPlay); finalizeLoadingScreen(); }); } else { alert("Error: Could not load scenario to play."); } }); }); document.querySelectorAll('.edit-scenario-btn').forEach(btn => { btn.addEventListener('click', (e) => { const scenarioId = parseInt(e.target.dataset.id); openScenarioEditor(scenarioId); }); }); document.querySelectorAll('.export-scenario-btn').forEach(btn => { btn.addEventListener('click', async (e) => { const scenarioId = parseInt(e.target.dataset.id); const scenario = await getScenarioByIdDB(scenarioId); if (scenario) { const { id, ...exportData } = scenario; exportScenarioAsJSON(exportData); } }); }); document.querySelectorAll('.delete-scenario-btn').forEach(btn => { btn.addEventListener('click', async (e) => { const scenarioId = parseInt(e.target.dataset.id); if (confirm("Are you sure you want to delete this scenario?")) { try { await deleteScenarioDB(scenarioId); loadAndDisplayCustomScenarios(); } catch (error) { console.error("Error deleting scenario:", error); alert("Error deleting scenario."); } } }); }); }
        function exportScenarioAsJSON(scenarioData) { const jsonString = JSON.stringify(scenarioData, null, 2); const blob = new Blob([jsonString], { type: "application/json" }); const url = URL.createObjectURL(blob); const a = document.createElement("a"); a.href = url; a.download = `${scenarioData.name.replace(/[^a-z0-9\s-]/gi, '_').trim().replace(/\s+/g, '-').toLowerCase() || 'custom_scenario'}.json`; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); }
        importScenarioBtn.addEventListener('click', () => { importFileInput.click(); });
        importFileInput.addEventListener('change', (event) => { const file = event.target.files[0]; if (file) { const reader = new FileReader(); reader.onload = async (e) => { try { const importedScenario = JSON.parse(e.target.result); if (importedScenario.name && importedScenario.width && importedScenario.height && importedScenario.grid && Array.isArray(importedScenario.grid) && importedScenario.grid.length === importedScenario.height && importedScenario.grid.every(row => Array.isArray(row) && row.length === importedScenario.width)) { let scenarioToSave = { name: importedScenario.name, width: importedScenario.width, height: importedScenario.height, grid: importedScenario.grid }; const existingScenarios = await getAllScenariosDB(); const existingByName = existingScenarios.find(s => s.name === scenarioToSave.name); if (existingByName) { if (confirm(`A scenario named "${scenarioToSave.name}" already exists. Do you want to overwrite it?`)) { scenarioToSave.id = existingByName.id; } else { importFileInput.value = ''; return; } } await saveScenarioDB(scenarioToSave); loadAndDisplayCustomScenarios(); alert(`Scenario "${importedScenario.name}" imported successfully.`); } else { alert("The JSON file does not have the expected scenario format or is corrupt."); } } catch (error) { console.error("Error importing scenario:", error); alert("Error processing the JSON file. Ensure it is valid."); } importFileInput.value = ''; }; reader.readAsText(file); } });
        createNewScenarioBtn.addEventListener('click', () => { openScenarioEditor(null); });
        backToCustomScreenBtn.addEventListener('click', () => { if (hasUnsavedChanges) { if (!confirm("You have unsaved changes. Are you sure you want to leave the editor? Changes will be lost.")) { return; } } scenarioEditorScreen.style.display = 'none'; customGameScreen.style.display = 'flex'; currentEditingScenario = null; hasUnsavedChanges = false; editorMessageSpan.textContent = ''; });
        async function openScenarioEditor(scenarioId) { customGameScreen.style.display = 'none'; scenarioEditorScreen.style.display = 'flex'; hasUnsavedChanges = false; editorMessageSpan.textContent = ''; playEditedScenarioBtn.disabled = true; if (scenarioId !== null) { const scenario = await getScenarioByIdDB(scenarioId); if (!scenario) { alert("Error: Could not load scenario."); backToCustomScreenBtn.click(); return; } currentEditingScenario = JSON.parse(JSON.stringify(scenario)); scenarioNameInput.value = currentEditingScenario.name; dimensionSelectorDiv.style.display = 'none'; scenarioNameInput.style.display = 'block'; brushToolsDiv.style.display = 'flex'; editorActionsDiv.style.display = 'flex'; setupEditorGrid(currentEditingScenario.width, currentEditingScenario.height, currentEditingScenario.grid); checkEditorStateForPlayability(); } else { currentEditingScenario = { id: null, name: "", width: 0, height: 0, grid: [] }; scenarioNameInput.value = ''; dimensionSelectorDiv.style.display = 'flex'; scenarioNameInput.style.display = 'none'; brushToolsDiv.style.display = 'none'; editorActionsDiv.style.display = 'none'; editorGridContainer.innerHTML = ''; } document.querySelectorAll('.brush-btn').forEach(b => b.classList.remove('active')); document.querySelector('.brush-btn[data-type="wall"]').classList.add('active'); selectedBrush = 'wall'; }
        confirmSizeBtn.addEventListener('click', () => { const [w, h] = scenarioSizeSelect.value.split('x').map(Number); currentEditingScenario.width = w; currentEditingScenario.height = h; currentEditingScenario.grid = Array(h).fill(null).map(() => Array(w).fill(0)); dimensionSelectorDiv.style.display = 'none'; scenarioNameInput.style.display = 'block'; scenarioNameInput.value = "Nuevo Laberinto"; currentEditingScenario.name = "Nuevo Laberinto"; brushToolsDiv.style.display = 'flex'; editorActionsDiv.style.display = 'flex'; setupEditorGrid(w, h, currentEditingScenario.grid); hasUnsavedChanges = true; checkEditorStateForPlayability(); });
        function setupEditorGrid(width, height, gridData) { editorGridContainer.innerHTML = ''; editorGridContainer.style.gridTemplateColumns = `repeat(${width}, 1fr)`; editorGridContainer.style.gridTemplateRows = `repeat(${height}, 1fr)`; editorGridData = JSON.parse(JSON.stringify(gridData)); editorCellElements = []; for (let r = 0; r < height; r++) { editorCellElements[r] = []; for (let c = 0; c < width; c++) { const cell = document.createElement('div'); cell.classList.add('grid-cell'); cell.dataset.row = r; cell.dataset.col = c; if (r === 0 || r === height - 1 || c === 0 || c === width - 1) { cell.classList.add('border'); editorGridData[r][c] = 0; } updateCellVisual(cell, editorGridData[r][c]); cell.addEventListener('click', handleGridCellClick); editorGridContainer.appendChild(cell); editorCellElements[r][c] = cell; } } }
        function updateCellVisual(cellElement, cellType) { cellElement.classList.remove('path', 'start', 'end', 'wall', 'pittrap'); let symbol = ''; switch (cellType) { case 0: cellElement.classList.add('wall'); break; case 1: cellElement.classList.add('path'); break; case 5: cellElement.classList.add('start'); symbol = 'S'; break; case 6: cellElement.classList.add('end'); symbol = 'E'; break; case PIT_TRAP_CELL_TYPE: cellElement.classList.add('pittrap'); symbol = 'T'; break; default: cellElement.classList.add('wall'); break; } cellElement.textContent = symbol; }
        function handleGridCellClick(event) { const cell = event.target; const r = parseInt(cell.dataset.row); const c = parseInt(cell.dataset.col); if (cell.classList.contains('border')) return; let newType; switch (selectedBrush) { case 'wall': newType = 0; break; case 'path': newType = 1; break; case 'start': newType = 5; break; case 'end': newType = 6; break; case 'pittrap': newType = PIT_TRAP_CELL_TYPE; break; default: return; } if (newType === 5 || newType === 6) { for (let i = 0; i < editorGridData.length; i++) { for (let j = 0; j < editorGridData[i].length; j++) { if (editorGridData[i][j] === newType) { editorGridData[i][j] = 1; if (editorCellElements[i] && editorCellElements[i][j]) { updateCellVisual(editorCellElements[i][j], 1); } } } } } editorGridData[r][c] = newType; updateCellVisual(cell, newType); hasUnsavedChanges = true; checkEditorStateForPlayability(); }
        document.querySelectorAll('.brush-btn').forEach(button => { button.addEventListener('click', () => { document.querySelectorAll('.brush-btn').forEach(b => b.classList.remove('active')); button.classList.add('active'); selectedBrush = button.dataset.type; }); });
        saveScenarioBtn.addEventListener('click', async () => { const scenarioName = scenarioNameInput.value.trim(); if (!scenarioName) { editorMessageSpan.textContent = "Please enter a scenario name."; return; } const validationResult = validateEditorGrid(); if (!validationResult.valid) { editorMessageSpan.textContent = validationResult.message; return; } currentEditingScenario.name = scenarioName; currentEditingScenario.grid = JSON.parse(JSON.stringify(editorGridData)); try { if (currentEditingScenario.id !== null && currentEditingScenario.id !== undefined) { const allScenarios = await getAllScenariosDB(); const nameConflict = allScenarios.find(s => s.name === currentEditingScenario.name && s.id !== currentEditingScenario.id); if (nameConflict) { if (!confirm(`A scenario named "${currentEditingScenario.name}" already exists. Do you want to overwrite the current scenario with this name anyway? (This will not affect the other scenario).`)) { editorMessageSpan.textContent = "Save cancelled. Name conflict."; return; } } } else { const allScenarios = await getAllScenariosDB(); const nameConflict = allScenarios.find(s => s.name === currentEditingScenario.name); if (nameConflict) { if (!confirm(`A scenario named "${currentEditingScenario.name}" already exists. Do you want to overwrite it?`)) { editorMessageSpan.textContent = "Save cancelled. Name conflict."; return; } currentEditingScenario.id = nameConflict.id; } } const savedScenario = await saveScenarioDB(currentEditingScenario); currentEditingScenario.id = savedScenario.id; hasUnsavedChanges = false; editorMessageSpan.textContent = "Scenario saved!"; playEditedScenarioBtn.disabled = false; setTimeout(() => editorMessageSpan.textContent = "", 2000); loadAndDisplayCustomScenarios(); } catch (error) { console.error("Error saving scenario:", error); editorMessageSpan.textContent = "Error saving. Check console."; } });
        playEditedScenarioBtn.addEventListener('click', () => { if (hasUnsavedChanges) { editorMessageSpan.textContent = "Save changes before playing."; return; } if (!currentEditingScenario || currentEditingScenario.id === null || currentEditingScenario.id === undefined) { editorMessageSpan.textContent = "Save the scenario first."; return; } const validation = validateEditorGrid(); if (!validation.valid) { editorMessageSpan.textContent = "The maze is not valid for playing: " + validation.message; return; } scenarioEditorScreen.style.display = 'none'; if(loadingTextElement) loadingTextElement.style.display = 'block'; if(loadingScreenElement) loadingScreenElement.style.display = 'flex'; const scenarioToPlay = JSON.parse(JSON.stringify(currentEditingScenario)); preloadTextures(() => { init(scenarioToPlay); finalizeLoadingScreen(); }); });
        function checkEditorStateForPlayability() { const isSaved = (currentEditingScenario && currentEditingScenario.id !== null && currentEditingScenario.id !== undefined); if (hasUnsavedChanges || !isSaved) { playEditedScenarioBtn.disabled = true; if (hasUnsavedChanges) { editorMessageSpan.textContent = "Unsaved changes."; } else if (!isSaved) { editorMessageSpan.textContent = "Save to enable 'Play'."; } if (!hasUnsavedChanges && isSaved && editorMessageSpan.textContent.startsWith("The maze is not valid")) { editorMessageSpan.textContent = ""; } } else { const validation = validateEditorGrid(); playEditedScenarioBtn.disabled = !validation.valid; editorMessageSpan.textContent = validation.valid ? "Ready to play or save." : validation.message; } }
        function validateEditorGrid() { if (!editorGridData || editorGridData.length === 0 || !editorGridData[0] || editorGridData[0].length === 0) return {valid: false, message: "The grid is empty."}; let startPoint = null, endPoint = null; const rows = editorGridData.length; const cols = editorGridData[0].length; for (let r = 0; r < rows; r++) { if (!editorGridData[r]) { console.error(`Row ${r} is null/undefined in editorGridData`); continue; } for (let c = 0; c < cols; c++) { const cellValue = editorGridData[r][c]; if (cellValue === undefined || cellValue === null) { console.warn(`Cell [${r}][${c}] is null/undefined, treating as wall (0).`); editorGridData[r][c] = 0; if (editorCellElements && editorCellElements[r] && editorCellElements[r][c]) { updateCellVisual(editorCellElements[r][c], 0); } } if (editorGridData[r][c] === 5) { if (startPoint) return {valid: false, message: "Only one start point (S) is allowed."}; startPoint = {r, c}; } if (editorGridData[r][c] === 6) { if (endPoint) return {valid: false, message: "Only one end point (E) is allowed."}; endPoint = {r, c}; } if (editorGridData[r][c] === PIT_TRAP_CELL_TYPE && (r === 0 || r === rows - 1 || c === 0 || c === cols - 1)) { return { valid: false, message: "Pit traps (T) cannot be on the border." }; } } } if (!startPoint) return {valid: false, message: "Missing a start point (S)."}; if (!endPoint) return {valid: false, message: "Missing an end point (E)."}; if (editorGridData[startPoint.r][startPoint.c] === 0 || editorGridData[startPoint.r][startPoint.c] === PIT_TRAP_CELL_TYPE) return { valid: false, message: "Start (S) must be on a regular path cell, not wall or trap." }; if (editorGridData[endPoint.r][endPoint.c] === 0 || editorGridData[endPoint.r][endPoint.c] === PIT_TRAP_CELL_TYPE) return { valid: false, message: "End (E) must be on a regular path cell, not wall or trap." }; if (startPoint.r === 0 || startPoint.r === rows - 1 || startPoint.c === 0 || startPoint.c === cols - 1) return { valid: false, message: "Start (S) cannot be on the border." }; if (endPoint.r === 0 || endPoint.r === rows - 1 || endPoint.c === 0 || endPoint.c === cols - 1) return { valid: false, message: "End (E) cannot be on the border." }; const queue = [[startPoint.r, startPoint.c]]; const visited = Array(rows).fill(null).map(() => Array(cols).fill(false)); visited[startPoint.r][startPoint.c] = true; let pathFound = false; const dr = [-1, 1, 0, 0]; const dc = [0, 0, -1, 1]; while (queue.length > 0) { const [r, c] = queue.shift(); if (r === endPoint.r && c === endPoint.c) { pathFound = true; break; } for (let i = 0; i < 4; i++) { const nr = r + dr[i]; const nc = c + dc[i]; if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) { if (!visited[nr][nc] && (editorGridData[nr][nc] === 1 || editorGridData[nr][nc] === PIT_TRAP_CELL_TYPE || editorGridData[nr][nc] === 5 || editorGridData[nr][nc] === 6 )) { visited[nr][nc] = true; queue.push([nr, nc]); } } } } if (!pathFound) return {valid: false, message: "The end point is not accessible from the start."}; return {valid: true, message: "Valid maze."}; }
        function escapeHTML(str) { if (str === null || str === undefined) return ""; return String(str).replace(/[&<>"']/g, function (match) { return { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[match]; }); }


        function startGameSequence() {
            console.log("Showing start options...");
            if(gameVersionSpan) gameVersionSpan.textContent = GAME_VERSION;
            if(loadingScreenElement) loadingScreenElement.style.display = 'flex';
            if(startOptionsDiv) startOptionsDiv.style.display = 'flex';
            if(loadingTextElement) loadingTextElement.style.display = 'none';

            initDB().then(() => {
                console.log("Database ready for use from startGameSequence.");
                 if (startCustomGameButton) startCustomGameButton.disabled = false;
            }).catch(error => {
                console.error("Database initialization failed. Custom game will not work correctly.", error);
                alert("Could not initialize database for custom scenarios. This feature might not be available.");
                if (startCustomGameButton) startCustomGameButton.disabled = true;
            });

            startAutoGameButton.addEventListener('click', () => {
                if(startOptionsDiv) startOptionsDiv.style.display = 'none';
                if(loadingTextElement) loadingTextElement.style.display = 'block';
                console.log("Starting game with autogenerated maze...");
                preloadTextures(() => {
                    console.log("Texture preload complete. Starting game...");
                    init();
                    finalizeLoadingScreen();
                });
            });

            startCustomGameButton.addEventListener('click', showCustomGameUI);
            if (!window.onresize) window.addEventListener('resize', onWindowResize, false);
        }
        function finalizeLoadingScreen() {
            setTimeout(() => {
                if(loadingScreenElement) {
                    loadingScreenElement.style.opacity = '0';
                    setTimeout(() => {
                        loadingScreenElement.style.display = 'none';
                        loadingScreenElement.style.opacity = '1';
                    }, 500);
                }
                console.log("Loading screen hidden. Game started.");
                 if (!isTouchDevice && pointerLockInfoDiv && pointerLockInfoDiv.style.display !== 'none' && !isPointerLocked) {
                    pointerLockInfoDiv.style.display = 'block';
                }
            }, 200);
        }
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', startGameSequence);
        } else {
            startGameSequence();
        }
    </script>
</body>
</html>
