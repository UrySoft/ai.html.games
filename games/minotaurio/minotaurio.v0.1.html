<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Minotaurio - Laberinto Subterr√°neo</title>
    <style>
        /* General Body and Game View Styles */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            touch-action: none;
            font-family: 'Georgia', 'Palatino Linotype', 'Book Antiqua', 'Palatino', serif; /* Base Greek-inspired font */
            color: #e0e0e0; /* Default text color for consistency */
        }
        canvas { display: block; width: 100%; height: 100%; }

        /* Functional UI Styles (Joystick, Action Buttons, Minimap - less aesthetic changes) */
        #joystick-area { position: absolute; width: 120px; height: 120px; background: rgba(200, 200, 200, 0.15); border-radius: 50%; display: none; justify-content: center; align-items: center; z-index: 10; pointer-events: none; transform: translate(-50%, -50%); }
        #joystick-thumb { width: 50px; height: 50px; background: rgba(200, 200, 200, 0.4); border-radius: 50%; }
        #action-buttons { position: absolute; bottom: 30px; right: 20px; display: flex; flex-direction: column; gap: 15px; z-index: 10; }
        .action-button {
            width: 60px; height: 60px;
            background: rgba(180, 40, 40, 0.7); /* Deep red */
            border-radius: 50%; display: flex; justify-content: center; align-items: center; color: white; font-weight: bold; font-size: 12px; text-align: center; user-select: none; border: 2px solid rgba(255, 255, 255, 0.3); cursor: pointer;
        }
        #message { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); background-color: rgba(20, 20, 20, 0.8); color: white; padding: 10px 20px; border-radius: 5px; display: none; z-index: 20; font-family: inherit;} /* Inherit font */
        #minimapCanvas { position: absolute; top: 15px; right: 15px; width: 160px; height: 160px; border: 1px solid rgba(255, 255, 255, 0.4); background-color: rgba(10, 10, 10, 0.6); z-index: 15; image-rendering: pixelated; }
        #pointer-lock-info { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: rgba(0, 0, 0, 0.7); color: white; padding: 20px; border-radius: 10px; font-size: 1.2em; text-align: center; display: none; z-index: 100; font-family: inherit;} /* Inherit font */

        /* --- Loading Screen Styles --- */
        #loading-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: #111; /* Darker background, slightly themed */
            color: #e0e0e0; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; transition: opacity 0.5s ease-out; z-index: 1000;
            padding: 20px; /* Add some padding */
            box-sizing: border-box; /* Include padding in width/height */
            overflow-y: auto; /* Allow scrolling if content is large */
        }
        #loading-screen h1 {
            font-family: 'Georgia', serif; /* Use a strong serif */
            font-size: 4.5em; /* Larger */
            margin-bottom: 0.1em;
            color: #ffc107; /* Gold */
            text-shadow: 3px 3px 6px rgba(0,0,0,0.6); /* Stronger shadow */
            border-bottom: 4px double #ffc107; /* Decorative underline */
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        #loading-screen p {
            font-size: 1.1em;
            color: #ccc;
            margin-bottom: 15px;
            max-width: 700px; /* Limit text width */
            line-height: 1.5; /* Improve readability */
        }
        #loading-screen .version {
            font-size: 1em; /* Smaller version text */
            margin-bottom: 20px;
            color: #aaa;
        }
        #loading-screen .legend-text {
             font-style: italic;
             color: #bbb;
             margin-bottom: 25px;
        }

        #loading-screen .loading-text {
            font-size: 1.5em;
            color: #ccc;
            margin-top: 20px; /* Space above loading text */
        }
        #start-options {
             margin-top: 30px;
             display: flex;
             flex-direction: column;
             gap: 15px;
        }
        .menu-button {
            background-color: #ffc107; /* Gold */
            color: #1a1a1a; /* Dark text on gold */
            border: none;
            padding: 15px 30px;
            font-size: 1.2em; /* Slightly larger font */
            cursor: pointer;
            border-radius: 5px; /* Slightly rounded corners */
            transition: background-color 0.3s ease, transform 0.1s ease;
            min-width: 300px;
            text-transform: uppercase; /* Maybe uppercase? */
             letter-spacing: 1px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        .menu-button:hover {
            background-color: #ffda6b; /* Lighter gold on hover */
            transform: translateY(-2px); /* Subtle hover effect */
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.4);
        }
         .menu-button:active {
             transform: translateY(0);
             box-shadow: 0 2px 3px rgba(0, 0, 0, 0.3);
         }
         .menu-button:disabled {
             background-color: #555;
             color: #999;
             cursor: not-allowed;
             box-shadow: none;
             transform: none;
         }


        /* --- Custom Game Screen Styles --- */
        #custom-game-screen, #scenario-editor-screen {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: #151515; /* Slightly darker */
            color: #e0e0e0; flex-direction: column; align-items: center; padding-top: 50px; z-index: 900; overflow-y: auto;
            box-sizing: border-box;
        }
        #custom-game-screen h2, #scenario-editor-screen h2 {
            color: #ffc107; /* Gold */
            margin-bottom: 25px;
            border-bottom: 2px solid #ffc107; /* Simple underline */
            padding-bottom: 5px;
             font-size: 2em;
        }
        #custom-scenario-list-container { width: 90%; max-width: 700px; margin-bottom: 20px; }
        #no-custom-scenarios { text-align: center; display: none; color: #aaa; }
        #custom-scenario-list { list-style: none; padding: 0; width: 100%;}
        .scenario-item {
            background-color: rgba(255,255,255,0.08); /* Slightly lighter background */
            border: 1px solid rgba(255,255,255,0.15); /* Subtle border */
            padding: 12px 20px; /* More padding */
            margin-bottom: 10px;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
             flex-wrap: wrap; /* Allow wrapping on small screens */
             gap: 10px; /* Space between text and buttons */
        }
        .scenario-item span { font-size: 1.1em; flex-grow: 1; min-width: 150px; } /* Allow text to grow */
        .scenario-actions {
            display: flex;
            gap: 8px; /* Space between action buttons */
            flex-shrink: 0; /* Prevent buttons from shrinking */
        }
        .scenario-actions .action-btn {
            background-color: #007bff; /* Blue */
            color: white;
            border: none;
            padding: 6px 10px; /* Smaller padding */
            font-size: 0.85em; /* Smaller font */
            cursor: pointer;
            border-radius: 3px;
            transition: background-color 0.2s ease;
            min-width: auto; /* Don't need min-width here */
             text-transform: none; /* No uppercase for these */
             letter-spacing: normal;
             box-shadow: none;
             height: auto; /* Auto height based on content */
             display: inline-flex; /* Use inline-flex for centering */
             align-items: center;
             justify-content: center;
        }
        .scenario-actions .action-btn:hover { background-color: #0056b3; transform: none; box-shadow: none;}
        .scenario-actions .delete-scenario-btn { background-color: #dc3545; } /* Red */
        .scenario-actions .delete-scenario-btn:hover { background-color: #c82333; }
        .menu-button.small-padding { padding: 8px 15px; font-size: 0.9em; min-width: auto; }


        /* --- Scenario Editor Styles --- */
        #scenario-editor-screen { background-color: #151515; z-index: 950; padding-top: 20px;}
        #editor-controls { margin-bottom: 15px; display: flex; flex-direction: column; align-items: center; gap: 10px; width: 90%; max-width: 700px;}
        #dimension-selector { display:none; margin-bottom:10px; align-items: center; gap: 10px; flex-wrap: wrap; justify-content: center; } /* Allow wrapping */
        #dimension-selector label { font-size: 1.1em;}
        #scenario-size-select {
            padding: 8px;
            border-radius: 3px;
             background-color: #333;
             color: white;
             border: 1px solid #555;
             font-family: inherit;
             font-size: 1em;
        }
        #confirm-size-btn { margin-left: 0; /* Remove extra margin */ margin-top: 5px; } /* Add some space if wrapped */
        #brush-tools { margin-bottom:10px; display:none; flex-wrap: wrap; justify-content: center;} /* Allow wrapping */
        #brush-tools span { font-size: 1.1em; margin-right: 10px; margin-bottom: 5px; flex-shrink: 0;}
        .brush-btn {
            padding: 8px 12px; margin: 0 5px; border: 1px solid #ccc; background-color: #555; color:white; cursor:pointer; border-radius: 3px;
            transition: background-color 0.2s ease, border-color 0.2s ease;
            font-family: inherit;
            font-size: 0.9em;
            margin-bottom: 5px; /* Add space for wrapping */
        }
        .brush-btn.active {
            background-color: #ffc107; /* Gold when active */
            color:#1a1a1a;
            border-color: #ffc107;
        }
        #scenario-name-input {
            padding: 10px; margin-bottom:10px; display:none; width: 80%; max-width: 300px; border-radius: 3px; border: 1px solid #555; background-color: #333; color: white;
             font-family: inherit;
             font-size: 1.1em;
        }
        #editor-grid-container {
            display: grid; border: 1px solid #444; margin-bottom: 15px;
            background-color: #222;
            /* column/row templates will be defined with JS */
        }
        .grid-cell {
            width: 25px; height: 25px;
            background-color: #403a30; /* Earthy brown/grey */
             border: 1px solid #2a2a2a; box-sizing: border-box; cursor: pointer; display: flex; justify-content: center; align-items: center; font-size: 12px; font-weight: bold;
             color: rgba(255,255,255,0.8); /* Default symbol color */
        }
        .grid-cell.path {
            background-color: #605548; /* Lighter earthy brown/grey */
        }
        .grid-cell.start { background-color: #4CAF50; color: white; } /* Green for start */
        .grid-cell.end { background-color: #F44336; color: white; } /* Red for end */
        .grid-cell.border { cursor: not-allowed; background-color: #111 !important; color: #444 !important;} /* Border color and text color */
        #editor-actions { display: flex; gap: 10px; margin-bottom: 15px; display:none; flex-wrap: wrap; justify-content: center;} /* Allow wrapping */
        #editor-message { color: #ffc107; margin-left:10px; align-self: center; font-size: 1em; margin-top: 5px; text-align: center;} /* Style message */

        /* Style for the back button in custom screen */
        #back-to-main-menu-btn {
            background-color: #6c757d; /* Grey button */
            color: white;
        }
         #back-to-main-menu-btn:hover {
            background-color: #5a6268;
         }
         /* Style for the back button in editor screen */
        #back-to-custom-screen-btn {
            background-color: #6c757d; /* Grey button */
            color: white;
        }
         #back-to-custom-screen-btn:hover {
            background-color: #5a6268;
         }


    </style>
</head>
<body>
    <div id="loading-screen">
        <h1>Minotaurio</h1>
        <p class="version">Versi√≥n <span id="game-version"></span></p>

        <p class="legend-text">
            En el coraz√≥n de la antigua Creta, reinaba el Rey Minos, pero la oscuridad acechaba.
            Nacido de una uni√≥n imp√≠a, el Minotauro, una bestia de hombre y toro, exig√≠a sacrificio.
            Encerrado en un vasto e ineludible Laberinto dise√±ado por el ingenioso D√©dalo,
            se alimentaba de la juventud de Atenas. Cada a√±o, j√≥venes valientes y doncellas
            eran enviados a las retorcidas profundidades, nunca para regresar, perdidos
            ante la bestia o el laberinto mismo. El miedo se apoder√≥ de la tierra,
            pues ¬øqui√©n podr√≠a navegar la oscuridad? ¬øQui√©n podr√≠a enfrentar el rugiente terror en su centro?
        </p>

        <div id="start-options" style="margin-top: 30px; display: flex; flex-direction: column; gap: 15px;">
            <button id="start-auto-game" class="menu-button">Iniciar Juego (Laberinto Aleatorio)</button>
            <button id="start-custom-game" class="menu-button">Juego Personalizado</button>
        </div>
        <p class="loading-text" id="loading-text-element" style="display: none;">Cargando texturas y laberinto...</p>
    </div>

    <div id="custom-game-screen">
        <h2>Juego Personalizado</h2>
        <div id="custom-scenario-list-container">
            <p id="no-custom-scenarios">No tienes escenarios guardados.</p>
            <ul id="custom-scenario-list"></ul>
        </div>
        <div id="custom-game-actions" style="display: flex; flex-wrap: wrap; justify-content: center; gap: 15px; margin-bottom: 20px;">
            <button id="create-new-scenario-btn" class="menu-button">Crear Nuevo Escenario</button>
            <button id="import-scenario-btn" class="menu-button">Importar Escenario</button>
            <input type="file" id="import-file-input" accept=".json" style="display: none;">
        </div>
        <button id="back-to-main-menu-btn" class="menu-button" style="background-color: #6c757d;">Volver al Men√∫ Principal</button>
    </div>

    <div id="scenario-editor-screen">
        <h2>Editor de Escenarios</h2>
        <div id="editor-controls">
            <div id="dimension-selector">
                <label for="scenario-size-select">Tama√±o del Laberinto:</label>
                <select id="scenario-size-select">
                    <option value="10x10">Peque√±o (10x10)</option>
                    <option value="15x15" selected>Mediano (15x15)</option>
                    <option value="20x20">Grande (20x20)</option>
                </select>
                <button id="confirm-size-btn" class="menu-button small-padding">Confirmar Tama√±o</button>
            </div>
            <input type="text" id="scenario-name-input" placeholder="Nombre del Escenario">
            <div id="brush-tools">
                <span>Herramienta: </span>
                <button class="brush-btn active" data-type="wall">Pared</button>
                <button class="brush-btn" data-type="path">Camino</button>
                <button class="brush-btn" data-type="start">Inicio</button>
                <button class="brush-btn" data-type="end">Fin</button>
            </div>
        </div>
        <div id="editor-grid-container"></div>
        <div id="editor-actions">
            <button id="save-scenario-btn" class="menu-button small-padding">Guardar</button>
            <button id="play-edited-scenario-btn" class="menu-button small-padding" disabled>Jugar</button>
            <span id="editor-message"></span>
        </div>
        <button id="back-to-custom-screen-btn" class="menu-button" style="background-color: #6c757d;">Volver a Escenarios</button>
    </div>


    <div id="pointer-lock-info">Haz clic para controlar la c√°mara con el rat√≥n. Presiona ESC para liberar.</div>
    <div id="container"></div>
    <div id="joystick-area"><div id="joystick-thumb"></div></div>
    <div id="action-buttons">
        <div id="jump-button" class="action-button">SALTAR</div>
        <div id="action-button" class="action-button">VISTA</div>
    </div>
    <div id="message"></div>
    <canvas id="minimapCanvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Constantes y Configuraci√≥n ---
        const GAME_VERSION = "v1.8-custom"; // Versi√≥n actualizada
        const MAX_RESOLUTION_DIMENSION = 1920;
        const DEFAULT_MAZE_WIDTH = 15; const DEFAULT_MAZE_HEIGHT = 15; // Para laberintos autogenerados
        const CELL_SIZE = 4; const WALL_HEIGHT = 7;
        const PLAYER_HEIGHT = 1.8; const PLAYER_RADIUS = 0.4; const PLAYER_SPEED = 3.5; const SPRINT_SPEED = 6.0; const SPRINT_THRESHOLD = 0.9; const JUMP_VELOCITY = 8.0; const GRAVITY = -18.0; const CAMERA_DISTANCE = 6; const CAMERA_HEIGHT_OFFSET = 2.5; const PUSH_DISTANCE = 0.8; const JOYSTICK_VISUAL_RADIUS = 60; const JOYSTICK_EFFECTIVE_RADIUS = 50; const JOYSTICK_DEADZONE = 0.1; const CAMERA_SENSITIVITY = 0.002; const OBSTACLE_OPACITY = 0.20; const TORCH_COLOR = 0xffa545; const TORCH_PLAYER_INTENSITY = 1.6; const TORCH_PLAYER_DISTANCE = 11; const TORCH_PLAYER_DECAY = 1.4;
        const TORCH_STATIC_INTENSITY = 1.8; const TORCH_STATIC_DISTANCE = 12; const TORCH_STATIC_DECAY = 1.8;
        const STATIC_TORCH_FREQUENCY = 0.45;
        const TORCH_FLICKER_AMOUNT = 0.25; const TORCH_WALL_OFFSET = 0.25; const FLAME_BASE_OPACITY = 0.7; const FLAME_OPACITY_VAR = 0.2; const FLAME_BASE_SCALE_Y = 0.35; const FLAME_SCALE_Y_VAR = 0.1; const MIN_CAMERA_Y_ABOVE_GROUND = 0.5;
        const MINIMAP_SIZE = 160; const MINIMAP_RADIUS_CELLS = 5; const MINIMAP_CELL_SIZE_PX = Math.floor(MINIMAP_SIZE / (MINIMAP_RADIUS_CELLS * 2 + 1)); const MINIMAP_PLAYER_COLOR = '#ff4444'; const MINIMAP_WALL_COLOR = '#505050'; const MINIMAP_PATH_COLOR = '#888888'; const MINIMAP_END_COLOR = '#33cc33';
        const PLAYER_VISION_RADIUS_CELLS = 4; const MINIMAP_UNSEEN_COLOR = '#181818';
        const FIRST_PERSON_EYE_HEIGHT_FACTOR = 0.85;
        const CAMERA_PITCH_OFFSET_FPS = Math.PI / 2;
        const FPS_TORCH_LIGHT_OFFSET = new THREE.Vector3(0.2, -0.25, -0.5);
        const FPS_TORCH_GROUP_OFFSET = new THREE.Vector3(0.35, -0.45, -0.7);
        const FPS_TORCH_GROUP_ROTATION = new THREE.Euler(Math.PI / 10, Math.PI / 8, -Math.PI / 12, 'YXZ');

        // --- TEXTURAS ---
        const textureURLs = [ 'https://urysoft.github.io/ai.html.games/general/assets/images/textura1.jpeg', 'https://urysoft.github.io/ai.html.games/general/assets/images/textura2.jpeg', 'https://urysoft.github.io/ai.html.games/general/assets/images/textura3.jpeg', 'https://urysoft.github.io/ai.html.games/general/assets/images/textura4.jpeg', 'https://urysoft.github.io/ai.html.games/general/assets/images/textura5.jpeg', 'https://urysoft.github.io/ai.html.games/general/assets/images/textura6.jpeg', 'https://urysoft.github.io/ai.html.games/general/assets/images/textura7.jpeg' ];
        const textureLoader = new THREE.TextureLoader();
        let loadedTextures = [];
        let floorTexture, wallTexture;

        // --- Variables Globales del Juego ---
        let scene, camera, renderer, player, clock;
        let maze = []; // Contendr√° la cuadr√≠cula del laberinto actual
        let currentMazeWidth, currentMazeHeight; // Dimensiones del laberinto actual
        let collidableObjects = []; let interactiveObjects = []; let playerVelocity = new THREE.Vector3(); let playerOnGround = false; let moveForward = 0, moveRight = 0; let cameraPhi = Math.PI / 3; let cameraTheta = 0; let endZone = null; let gameActive = true;
        const joystickArea = document.getElementById('joystick-area'); const joystickThumb = document.getElementById('joystick-thumb'); const jumpButton = document.getElementById('jump-button'); const actionButton = document.getElementById('action-button'); const messageDiv = document.getElementById('message'); const containerDiv = document.getElementById('container');
        let joystickPointerId = -1; let cameraPointerId = -1; let joystickStartPos = { x: 0, y: 0 }; let joystickCurrentPos = { x: 0, y: 0 }; let cameraTouchStartPos = { x: 0, y: 0 };
        let currentlyTransparentObjects = new Set(); let playerTorchLight = null; let staticTorches = [];
        let playerTorchGroup = null; let playerTorchFlameMesh = null;
        let originalPlayerTorchLightPosition = new THREE.Vector3();
        let originalPlayerTorchGroupPosition = new THREE.Vector3();
        let originalPlayerTorchGroupRotation = new THREE.Euler();
        let minimapCanvas = null; let minimapCtx = null; let minimapWidth = MINIMAP_SIZE; let minimapHeight = MINIMAP_SIZE;
        let visibilityMaze = [];
        const loadingScreenElement = document.getElementById('loading-screen');
        const gameVersionSpan = document.getElementById('game-version');
        const pointerLockInfoDiv = document.getElementById('pointer-lock-info');
        let isFirstPersonView = false;
        let keyStates = {}; let isPointerLocked = false;
        let isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        const lightWorldPosHelper = new THREE.Vector3();
        const collisionCheckTempBox = new THREE.Box3();

        // --- Variables UI y Editor ---
        const startAutoGameButton = document.getElementById('start-auto-game');
        const startCustomGameButton = document.getElementById('start-custom-game');
        const loadingTextElement = document.getElementById('loading-text-element');
        const startOptionsDiv = document.getElementById('start-options');
        const customGameScreen = document.getElementById('custom-game-screen');
        const scenarioEditorScreen = document.getElementById('scenario-editor-screen');
        const customScenarioListUL = document.getElementById('custom-scenario-list'); // Renombrado para claridad
        const noCustomScenariosMsg = document.getElementById('no-custom-scenarios');
        const createNewScenarioBtn = document.getElementById('create-new-scenario-btn');
        const importScenarioBtn = document.getElementById('import-scenario-btn');
        const importFileInput = document.getElementById('import-file-input');
        const backToMainMenuBtn = document.getElementById('back-to-main-menu-btn');
        const backToCustomScreenBtn = document.getElementById('back-to-custom-screen-btn');
        const dimensionSelectorDiv = document.getElementById('dimension-selector');
        const scenarioSizeSelect = document.getElementById('scenario-size-select');
        const confirmSizeBtn = document.getElementById('confirm-size-btn');
        const brushToolsDiv = document.getElementById('brush-tools');
        const scenarioNameInput = document.getElementById('scenario-name-input');
        const editorGridContainer = document.getElementById('editor-grid-container');
        const editorActionsDiv = document.getElementById('editor-actions');
        const saveScenarioBtn = document.getElementById('save-scenario-btn');
        const playEditedScenarioBtn = document.getElementById('play-edited-scenario-btn');
        const editorMessageSpan = document.getElementById('editor-message');

        let currentEditingScenario = null; // { id, name, width, height, grid }
        let editorGridData = []; // Array 2D para los datos de la cuadr√≠cula del editor
        let selectedBrush = 'wall';
        let hasUnsavedChanges = false;
        let editorCellElements = []; // Para acceder a los divs de las celdas


        // --- IndexedDB Wrapper ---
        const DB_NAME = "MinotaurioCustomScenariosDB";
        const DB_VERSION = 1;
        const STORE_NAME = "scenarios";
        let db;

        function initDB() {
            return new Promise((resolve, reject) => {
                if (!window.indexedDB) {
                    console.warn("IndexedDB no soportado por este navegador. Juego Personalizado no funcionar√°.");
                    alert("Tu navegador no soporta IndexedDB, necesario para guardar escenarios personalizados.");
                    reject("IndexedDB not supported");
                    return;
                }
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onupgradeneeded = (event) => {
                    const dbInstance = event.target.result;
                    if (!dbInstance.objectStoreNames.contains(STORE_NAME)) {
                        const store = dbInstance.createObjectStore(STORE_NAME, { keyPath: "id", autoIncrement: true });
                        store.createIndex("name", "name", { unique: false }); // Permitir nombres duplicados, pero la UI lo gestionar√°
                    }
                    console.log("IndexedDB: Actualizaci√≥n/creaci√≥n de base de datos completada.");
                };
                request.onsuccess = (event) => {
                    db = event.target.result;
                    console.log("IndexedDB: Conexi√≥n exitosa.");
                    resolve(db);
                };
                request.onerror = (event) => {
                    console.error("IndexedDB: Error al abrir la base de datos", event.target.error);
                    reject(event.target.error);
                };
            });
        }

        // Fix for DataError when adding new scenarios to IndexedDB
        function saveScenarioDB(scenarioData) {
            return new Promise((resolve, reject) => {
                if (!db) { reject("DB no inicializada"); return; }

                const transaction = db.transaction([STORE_NAME], "readwrite");
                const store = transaction.objectStore(STORE_NAME);

                let request;
                let dataToStore; // The object that will actually be stored in IndexedDB

                // If scenarioData has a valid ID, it's an existing scenario, use put.
                // Otherwise (id is null or undefined), it's a new scenario, use add.
                if (scenarioData.id !== null && scenarioData.id !== undefined) {
                     // For 'put', we need the keyPath property ('id') in the object.
                     // Use a copy to avoid potential side effects, though passing the original is often fine for put.
                     dataToStore = { ...scenarioData };
                     request = store.put(dataToStore);
                } else {
                     // For 'add' on an auto-incrementing store, the keyPath property ('id')
                     // must *not* be present or must be undefined.
                     // Using object destructuring to create a new object without the 'id' property.
                     const { id, ...dataWithoutId } = scenarioData;
                     dataToStore = dataWithoutId;
                     request = store.add(dataToStore);
                }

                request.onsuccess = (event) => {
                    // event.target.result contains the key assigned by IndexedDB
                    const resultId = event.target.result;

                    console.log("Escenario guardado/actualizado en DB:", scenarioData.name, "ID asignado/actualizado:", resultId);

                    // Create and resolve with the object including the correct final ID
                    // This updates the original scenarioData object reference outside this function
                    scenarioData.id = resultId;
                    resolve(scenarioData);
                };

                request.onerror = (event) => {
                    console.error("Error al guardar escenario en DB:", event.target.error);
                    if (event.target.error.name === 'ConstraintError') {
                        alert("Error de restricci√≥n al guardar el escenario. Puede que ya exista un escenario con un nombre o identificador similar (si hay reglas de unicidad). Revisa la consola.");
                    } else if (event.target.error.name === 'DataError') {
                         alert("Error de datos al guardar el escenario. Revisa el formato o los valores. Revisa la consola.");
                    }
                    reject(event.target.error);
                };
            });
        }


        function getAllScenariosDB() {
            return new Promise((resolve, reject) => {
                if (!db) { resolve([]); return; } // Devuelve array vac√≠o si no hay DB
                const transaction = db.transaction([STORE_NAME], "readonly");
                const store = transaction.objectStore(STORE_NAME);
                const request = store.getAll();
                request.onsuccess = () => { resolve(request.result); };
                request.onerror = (event) => {
                    console.error("Error al obtener todos los escenarios:", event.target.error);
                    reject(event.target.error);
                };
            });
        }

        function getScenarioByIdDB(id) {
            return new Promise((resolve, reject) => {
                if (!db) { reject("DB no inicializada"); return; }
                const transaction = db.transaction([STORE_NAME], "readonly");
                const store = transaction.objectStore(STORE_NAME);
                const request = store.get(id);
                request.onsuccess = () => { resolve(request.result);};
                request.onerror = (event) => {
                    console.error("Error al obtener escenario por ID:", id, event.target.error);
                    reject(event.target.error);
                };
            });
        }

        function deleteScenarioDB(id) {
            return new Promise((resolve, reject) => {
                if (!db) { reject("DB no inicializada"); return; }
                const transaction = db.transaction([STORE_NAME], "readwrite");
                const store = transaction.objectStore(STORE_NAME);
                const request = store.delete(id);
                request.onsuccess = () => {
                    console.log("Escenario eliminado de DB, ID:", id);
                    resolve();
                };
                request.onerror = (event) => {
                    console.error("Error al eliminar escenario de DB:", event.target.error);
                    reject(event.target.error);
                };
            });
        }


        // --- Pre-cargar texturas ---
        function preloadTextures(callback) {
            let texturesToLoad = textureURLs.length; if (texturesToLoad === 0) { console.log("No hay texturas definidas para cargar."); selectRandomTextures(); callback(); return; } textureURLs.forEach((url, index) => { textureLoader.load( url, (texture) => { texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping; loadedTextures[index] = texture; texturesToLoad--; if (texturesToLoad === 0) { console.log("Todas las texturas cargadas exitosamente."); selectRandomTextures(); callback(); } }, undefined, (error) => { console.error('Error al cargar textura:', url, error); texturesToLoad--; if (texturesToLoad === 0) { console.warn("Algunas texturas no pudieron cargarse. Continuando con las disponibles..."); selectRandomTextures(); callback(); } } ); });
        }
        function selectRandomTextures() {
            if (loadedTextures.length === 0) { console.warn("No hay texturas cargadas para seleccionar. Se usar√°n colores s√≥lidos."); floorTexture = null; wallTexture = null; return; } const validTextures = loadedTextures.filter(t => t); if (validTextures.length === 0) { console.warn("Todas las texturas cargadas son inv√°lidas. Se usar√°n colores s√≥lidos."); floorTexture = null; wallTexture = null; return; } let floorTextureIndex = Math.floor(Math.random() * validTextures.length); floorTexture = validTextures[floorTextureIndex]; let wallTextureIndex; if (validTextures.length > 1) { do { wallTextureIndex = Math.floor(Math.random() * validTextures.length); } while (wallTextureIndex === floorTextureIndex); wallTexture = validTextures[wallTextureIndex]; } else { wallTexture = validTextures[0]; console.warn("Solo una textura v√°lida disponible, us√°ndola para suelo y paredes."); } console.log("Textura suelo seleccionada:", floorTexture ? floorTexture.image.src : "Ninguna (color s√≥lido)"); console.log("Textura pared seleccionada:", wallTexture ? wallTexture.image.src : "Ninguna (color s√≥lido)");
        }


        // --- Inicializaci√≥n del Juego ---
        function init(customMazeData = null) {
            // Limpiar escena anterior si existe (importante si se llama init m√∫ltiples veces)
            if (scene) {
                while(scene.children.length > 0){
                    const object = scene.children[0];
                    if(object.geometry) object.geometry.dispose();
                    if(object.material){
                        if(Array.isArray(object.material)){
                            object.material.forEach(material => material.dispose());
                        } else {
                            object.material.dispose();
                        }
                    }
                    scene.remove(object);
                }
            }
            if (renderer) { // Detener bucle de animaci√≥n anterior
                gameActive = false; // Detiene el requestAnimationFrame del juego anterior
                // No llamar a renderer.dispose() aqu√≠ si se va a reutilizar el renderer
            }
            collidableObjects = [];
            interactiveObjects = [];
            staticTorches = []; // Limpiar antorchas est√°ticas


            scene = new THREE.Scene(); scene.background = new THREE.Color(0x050508); scene.fog = new THREE.Fog(0x050508, 10, 35); // Aumentar un poco la niebla
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            // Reutilizar renderer si ya existe
            if (!renderer) {
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.shadowMap.enabled = true; renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 0.8;
                containerDiv.appendChild(renderer.domElement);
            }

            clock = new THREE.Clock();
            const ambientLight = new THREE.AmbientLight(0x404040, 0.15); scene.add(ambientLight);
            minimapCanvas = document.getElementById('minimapCanvas'); // Ya deber√≠a existir
            minimapCanvas.width = minimapWidth; minimapCanvas.height = minimapHeight; minimapCtx = minimapCanvas.getContext('2d');
            if (!minimapCtx) { console.error("No se pudo obtener el contexto 2D del minimapa."); }

            if (customMazeData) {
                console.log("Iniciando con laberinto personalizado:", customMazeData.name);
                maze = JSON.parse(JSON.stringify(customMazeData.grid)); // Deep copy
                currentMazeWidth = customMazeData.width;
                currentMazeHeight = customMazeData.height;
            } else {
                console.log("Iniciando con laberinto autogenerado.");
                currentMazeWidth = DEFAULT_MAZE_WIDTH;
                currentMazeHeight = DEFAULT_MAZE_HEIGHT;
                maze = generateMaze(currentMazeWidth, currentMazeHeight);
            }

            visibilityMaze = [];
            for (let z = 0; z < currentMazeHeight; z++) {
                visibilityMaze[z] = [];
                for (let x = 0; x < currentMazeWidth; x++) {
                    visibilityMaze[z][x] = false;
                }
            }

            buildMazeGeometry(currentMazeWidth, currentMazeHeight, maze);

            const playerGeometry = new THREE.CylinderGeometry(PLAYER_RADIUS, PLAYER_RADIUS, PLAYER_HEIGHT, 16);
            const playerMaterial = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.6 });
            player = new THREE.Mesh(playerGeometry, playerMaterial);
            player.castShadow = true; player.rotation.order = 'YXZ';

            const startPos = findCell(5, maze, currentMazeWidth, currentMazeHeight);
            if (startPos) {
                player.position.set( (startPos.x - currentMazeWidth / 2 + 0.5) * CELL_SIZE, PLAYER_HEIGHT / 2 + 0.01, (startPos.z - currentMazeHeight / 2 + 0.5) * CELL_SIZE );
            } else {
                console.warn("No se encontr√≥ celda de inicio (5) en el laberinto. Colocando en el centro del primer camino disponible o (0,0).");
                let fallbackStart = findCell(1, maze, currentMazeWidth, currentMazeHeight); // Buscar un camino
                if (!fallbackStart) fallbackStart = {x: Math.floor(currentMazeWidth/2), y: Math.floor(currentMazeHeight/2)}; // √öltimo recurso
                if (maze[fallbackStart.z] && maze[fallbackStart.z][fallbackStart.x] === 0) { // Si el fallback es pared, intentar buscar otro
                     fallbackStart = {x:1,z:1}; // Default si todo falla
                }
                player.position.set( (fallbackStart.x - currentMazeWidth / 2 + 0.5) * CELL_SIZE, PLAYER_HEIGHT / 2 + 0.01, (fallbackStart.z - currentMazeHeight / 2 + 0.5) * CELL_SIZE );
            }
            scene.add(player);

            playerTorchLight = new THREE.PointLight( TORCH_COLOR, TORCH_PLAYER_INTENSITY, TORCH_PLAYER_DISTANCE, TORCH_PLAYER_DECAY );
            playerTorchLight.castShadow = true;
            playerTorchLight.shadow.mapSize.width = 512; playerTorchLight.shadow.mapSize.height = 512; playerTorchLight.shadow.camera.near = 0.1; playerTorchLight.shadow.camera.far = TORCH_PLAYER_DISTANCE;
            const lightPosX = PLAYER_RADIUS + 0.2; const lightPosY = PLAYER_HEIGHT * 0.45; const lightPosZ = PLAYER_RADIUS + 0.3;
            originalPlayerTorchLightPosition.set(lightPosX, lightPosY, lightPosZ);
            playerTorchLight.position.copy(originalPlayerTorchLightPosition);
            playerTorchLight.userData.baseIntensity = TORCH_PLAYER_INTENSITY;
            player.add(playerTorchLight);

            const torchHolderMat = new THREE.MeshStandardMaterial({ color: 0x604020, roughness: 0.7 }); const flameMat = new THREE.MeshBasicMaterial({ color: 0xffd080, transparent: true, opacity: FLAME_BASE_OPACITY, blending: THREE.AdditiveBlending, depthWrite: false }); const holderGeom = new THREE.CylinderGeometry(0.08, 0.1, 0.7, 8); const flameGeom = new THREE.SphereGeometry(0.2, 10, 8);
            playerTorchGroup = new THREE.Group();
            const torchHolder = new THREE.Mesh(holderGeom, torchHolderMat); playerTorchFlameMesh = new THREE.Mesh(flameGeom, flameMat); torchHolder.position.y = -0.35; playerTorchFlameMesh.position.y = 0.1; playerTorchGroup.add(torchHolder); playerTorchGroup.add(playerTorchFlameMesh);
            originalPlayerTorchGroupPosition.set(lightPosX, lightPosY, lightPosZ);
            originalPlayerTorchGroupRotation.set(Math.PI / 10, 0, -Math.PI / 12, 'YXZ');
            playerTorchGroup.position.copy(originalPlayerTorchGroupPosition);
            playerTorchGroup.rotation.copy(originalPlayerTorchGroupRotation);
            player.add(playerTorchGroup);

            const ceilingSize = Math.max(currentMazeWidth, currentMazeHeight) * CELL_SIZE * 1.2;
            const ceilingGeometry = new THREE.PlaneGeometry(ceilingSize, ceilingSize);
            const ceilingMaterial = new THREE.MeshStandardMaterial({ color: 0x333333, side: THREE.DoubleSide, roughness: 0.9 }).clone();
            if (wallTexture) {
                ceilingMaterial.map = wallTexture.clone(); ceilingMaterial.map.needsUpdate = true; ceilingMaterial.color.set(0xffffff);
                ceilingMaterial.map.repeat.set(ceilingSize / (CELL_SIZE * 2), ceilingSize / (CELL_SIZE * 2)); // Ajustar repetici√≥n
            }
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.position.y = WALL_HEIGHT + 0.1; ceiling.rotation.x = Math.PI / 2; ceiling.receiveShadow = true; ceiling.userData = { isCeiling: true, originalOpacity: 1.0, isTransparentCapable: true }; scene.add(ceiling); collidableObjects.push(ceiling);

            updateRendererAndCameraSize();
            // Re-configurar controles puede ser necesario si se limpian con el DOM,
            // pero si los listeners est√°n en body o window, pueden persistir.
            // Por seguridad, se puede hacer una funci√≥n removeEventListeners if init se llama mucho.
            // Por ahora, asumimos que los listeners de controles se configuran una vez y persisten.
            if (isTouchDevice) {
                setupTouchControls(); // Si no se han a√±adido ya
            } else {
                setupKeyboardAndMouseControls(); // Si no se han a√±adido ya
                if (pointerLockInfoDiv) pointerLockInfoDiv.style.display = 'block';
                joystickArea.style.display = 'none';
                document.getElementById('action-buttons').style.display = 'none';
            }
            // window.addEventListener('resize', onWindowResize, false); // Asegurar que solo hay uno

            player.visible = !isFirstPersonView;
            player.castShadow = !isFirstPersonView;
            if (playerTorchGroup) playerTorchGroup.visible = !isFirstPersonView;

            cameraPhi = Math.PI / 3; // Resetear √°ngulos de c√°mara
            cameraTheta = 0;
            updateCamera(); // Llamada inicial para posicionar la c√°mara correctamente
            gameActive = true;
            animate();
        }

        // --- Generaci√≥n de Laberinto ---
        function generateMaze(width, height) {
            let matrix = []; for (let y = 0; y < height; y++) { matrix[y] = []; for (let x = 0; x < width; x++) matrix[y][x] = 0; } // 0 = pared
            let stack = [];
            // Empezar en una celda impar para asegurar que los pasillos se alineen bien si w/h son impares.
            let startX = 1; let startY = 1;
            matrix[startY][startX] = 1; // 1 = camino
            stack.push({ x: startX, y: startY });

            function isValid(x, y, currentMatrix) {
                return y >= 0 && y < height && x >= 0 && x < width && currentMatrix[y][x] === 0;
            }

            while (stack.length > 0) {
                let current = stack[stack.length - 1];
                let neighbors = [];
                // N, S, E, W (con salto de 2 celdas para el camino, 1 para la pared intermedia)
                let potential = [
                    { x: current.x, y: current.y - 2, wallX: current.x, wallY: current.y - 1 }, // Norte
                    { x: current.x, y: current.y + 2, wallX: current.x, wallY: current.y + 1 }, // Sur
                    { x: current.x + 2, y: current.y, wallX: current.x + 1, wallY: current.y }, // Este
                    { x: current.x - 2, y: current.y, wallX: current.x - 1, wallY: current.y }  // Oeste
                ];

                potential.forEach(p => {
                    if (isValid(p.x, p.y, matrix)) {
                        neighbors.push(p);
                    }
                });

                if (neighbors.length > 0) {
                    let next = neighbors[Math.floor(Math.random() * neighbors.length)];
                    matrix[next.y][next.x] = 1; // Celda de destino es camino
                    matrix[next.wallY][next.wallX] = 1; // Pared intermedia se convierte en camino
                    stack.push({ x: next.x, y: next.y });
                } else {
                    stack.pop();
                }
            }

            // Asegurar que (1,1) es el inicio si no se ha modificado
            if (matrix[1] && matrix[1][1] !== undefined) matrix[1][1] = 5; // 5 = Punto de inicio

            // Colocar punto final (6)
            let deadEnds = findDeadEnds(matrix, width, height);
            let endPlaced = false;
            let potentialEndPos = [];

            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    if (matrix[y][x] === 1) { // Es un camino
                        // Criterio de distancia para el punto final
                        if (Math.abs(x - startX) + Math.abs(y - startY) > (width + height) / 2.5) {
                            potentialEndPos.push({ x, y });
                        }
                    }
                }
            }

            if (potentialEndPos.length > 0) {
                // Priorizar dead ends lejanos si existen
                let endPos = potentialEndPos.find(p => deadEnds.some(d => d.x === p.x && d.y === p.y));
                if (!endPos) { // Si no, tomar uno al azar de los lejanos
                    endPos = potentialEndPos[Math.floor(Math.random() * potentialEndPos.length)];
                }
                if(matrix[endPos.y] && matrix[endPos.y][endPos.x] !== undefined) matrix[endPos.y][endPos.x] = 6; // 6 = Punto final
                endPlaced = true;
            }

            if (!endPlaced) { // Fallback si no se pudo colocar el final de forma inteligente
                const endY = height - 2;
                const endX = width - 2;
                if (matrix[endY] && matrix[endY][endX] !== undefined) {
                     if (matrix[endY][endX] === 0) { // Si es pared, intentar hacerla camino y la adyacente
                        matrix[endY][endX] = 6;
                        if (matrix[endY-1] && matrix[endY-1][endX] === 0) matrix[endY-1][endX] = 1;
                        else if (matrix[endY+1] && matrix[endY+1][endX] === 0) matrix[endY+1][endX] = 1;
                        else if (matrix[endY][endX-1] === 0) matrix[endY][endX-1] = 1;
                        else if (matrix[endY][endX+1] === 0) matrix[endY][endX+1] = 1;
                     } else {
                        matrix[endY][endX] = 6;
                     }
                }
                console.warn("Fallback para colocar el punto final.");
            }
            return matrix;
        }

        function findCell(type, targetMaze, mazeW, mazeH) {
            for (let z = 0; z < mazeH; z++) {
                for (let x = 0; x < mazeW; x++) {
                    if (targetMaze[z] && targetMaze[z][x] === type) return { x, z };
                }
            }
            return null;
        }

        function findDeadEnds(targetMaze, mazeW, mazeH) {
            let deadEnds = [];
            for (let y = 1; y < mazeH - 1; y++) { // Evitar bordes si son siempre pared
                for (let x = 1; x < mazeW - 1; x++) {
                    if (targetMaze[y][x] !== 0) { // Si no es una pared
                        let pathNeighbors = 0;
                        if (targetMaze[y+1] && targetMaze[y+1][x] !== 0) pathNeighbors++; // Sur
                        if (targetMaze[y-1] && targetMaze[y-1][x] !== 0) pathNeighbors++; // Norte
                        if (targetMaze[y][x+1] !== 0) pathNeighbors++; // Este
                        if (targetMaze[y][x-1] !== 0) pathNeighbors++; // Oeste

                        if (pathNeighbors === 1) {
                            deadEnds.push({ x, y });
                        }
                    }
                }
            }
            return deadEnds;
        }


        // --- Construcci√≥n de Geometr√≠a (CON TEXTURAS) ---
        function buildMazeGeometry(mazeW, mazeH, currentLevelMaze) {
            collidableObjects = []; // Limpiar antes de reconstruir
            interactiveObjects = [];
            staticTorches = [];
            endZone = null;

            const wallMaterialBase = new THREE.MeshStandardMaterial({ map: wallTexture, roughness: 0.9, metalness: 0.1, color: wallTexture ? 0xffffff : 0x605548 });
            const floorMaterial = new THREE.MeshStandardMaterial({ map: floorTexture, roughness: 0.95, metalness: 0.1, side: THREE.DoubleSide, color: floorTexture ? 0xffffff : 0x444038 });
            if (floorTexture) {
                floorTexture.repeat.set(mazeW / 2, mazeH / 2); // Usar dimensiones actuales
                if (renderer && renderer.capabilities) floorTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                floorTexture.needsUpdate = true;
            }
            if (wallTexture) {
                if (renderer && renderer.capabilities) wallTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                wallTexture.needsUpdate = true;
            }

            const endMaterial = new THREE.MeshStandardMaterial({ color: 0x33ff33, emissive: 0x22dd22, transparent: true, opacity: 0.6 });
            const torchHolderMaterial = new THREE.MeshStandardMaterial({ color: 0x504030, roughness: 0.8 });
            const flameMaterialBase = new THREE.MeshBasicMaterial({ color: 0xffd080, transparent: true, opacity: FLAME_BASE_OPACITY, blending: THREE.AdditiveBlending, depthWrite: false });

            const wallGeometry = new THREE.BoxGeometry(CELL_SIZE, WALL_HEIGHT, CELL_SIZE);
            const floorGeometry = new THREE.PlaneGeometry(mazeW * CELL_SIZE, mazeH * CELL_SIZE); // Usar dimensiones actuales
            const endGeometry = new THREE.CylinderGeometry(CELL_SIZE * 0.3, CELL_SIZE * 0.3, 0.2, 16);
            const torchHolderGeometry = new THREE.BoxGeometry(0.2, 0.8, 0.2);
            const flameGeometry = new THREE.SphereGeometry(0.25, 10, 8);

            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            floor.userData = { isFloor: true };
            scene.add(floor);
            // collidableObjects.push(floor); // El suelo no suele ser un colisionable que detenga, sino que define y_min

            let torchLocations = [];
            for (let z = 0; z < mazeH; z++) {
                for (let x = 0; x < mazeW; x++) {
                    if (!currentLevelMaze[z] || currentLevelMaze[z][x] === undefined) {
                        console.warn(`Celda indefinida en [${z}][${x}] para laberinto ${mazeW}x${mazeH}. Tratando como pared.`);
                        currentLevelMaze[z][x] = 0; // Asegurar que sea una pared if there is corrupted data
                    }
                    const cellType = currentLevelMaze[z][x];
                    const posX = (x - mazeW / 2 + 0.5) * CELL_SIZE;
                    const posYBase = WALL_HEIGHT / 2;
                    const posZ = (z - mazeH / 2 + 0.5) * CELL_SIZE;

                    if (cellType === 0) { // Pared
                        const wallMatInstance = wallMaterialBase.clone();
                        if (wallTexture) {
                            wallMatInstance.map = wallTexture.clone();
                            wallMatInstance.map.needsUpdate = true;
                            wallMatInstance.map.repeat.set(1, WALL_HEIGHT / CELL_SIZE); // Adjust repeat for individual walls
                        }
                        const wall = new THREE.Mesh(wallGeometry, wallMatInstance);
                        wall.position.set(posX, posYBase, posZ);
                        wall.castShadow = true; // Walls can cast shadows
                        wall.receiveShadow = true;
                        wall.userData = { isWall: true, originalOpacity: 1.0, isTransparentCapable: true };
                        scene.add(wall);
                        collidableObjects.push(wall);
                    } else { // Path, Start, or End
                        // Place static torches on paths
                        if (Math.random() < STATIC_TORCH_FREQUENCY) {
                            let possibleTorchWalls = [];
                            // Check adjacent walls
                            if (z > 0 && currentLevelMaze[z-1][x] === 0) possibleTorchWalls.push({ wallX: x, wallZ: z-1, side: 'N' }); // Wall to the North
                            if (z < mazeH - 1 && currentLevelMaze[z+1][x] === 0) possibleTorchWalls.push({ wallX: x, wallZ: z+1, side: 'S' }); // South
                            if (x > 0 && currentLevelMaze[z][x-1] === 0) possibleTorchWalls.push({ wallX: x-1, wallZ: z, side: 'W' }); // West
                            if (x < mazeW - 1 && currentLevelMaze[z][x+1] === 0) possibleTorchWalls.push({ wallX: x+1, wallZ: z, side: 'E' }); // East

                            if (possibleTorchWalls.length > 0) {
                                const chosenWallData = possibleTorchWalls[Math.floor(Math.random() * possibleTorchWalls.length)];
                                // Avoid torches too close together
                                let tooClose = torchLocations.some(loc =>
                                    Math.abs(loc.x - posX) < CELL_SIZE * 1.5 && Math.abs(loc.z - posZ) < CELL_SIZE * 1.5
                                );
                                if (!tooClose) {
                                    addStaticTorch(posX, posZ, chosenWallData.side, torchHolderGeometry, flameGeometry, torchHolderMaterial, flameMaterialBase, mazeW, mazeH);
                                    torchLocations.push({x: posX, z: posZ});
                                }
                            }
                        }

                        if (cellType === 6) { // End
                            endZone = new THREE.Mesh(endGeometry, endMaterial);
                            endZone.position.set(posX, 0.1, posZ);
                            endZone.userData = { type: 'end' };
                            scene.add(endZone);
                            interactiveObjects.push(endZone);
                        }
                        // Type 5 (start) only defines the player's position, not a special visible object (unless desired)
                    }
                }
            }
        }

        function addStaticTorch(pathCellX, pathCellZ, attachSide, holderGeom, flameGeom, holderMat, flameMatBase, mazeW, mazeH) {
            // pathCellX, pathCellZ are the WORLD coordinates of the path cell the torch originates from.
            // attachSide indicates which wall of this path cell the torch will be attached to.
            const torchY = WALL_HEIGHT * 0.6;

            const holder = new THREE.Mesh(holderGeom, holderMat.clone()); // Clone material for unique instances
            const flameMaterial = flameMatBase.clone();
            const flame = new THREE.Mesh(flameGeom, flameMaterial);
            const light = new THREE.PointLight( TORCH_COLOR, TORCH_STATIC_INTENSITY, TORCH_STATIC_DISTANCE, TORCH_STATIC_DECAY );
            light.castShadow = false; // Shadows from static torches can be expensive
            light.userData.baseIntensity = TORCH_STATIC_INTENSITY;
            staticTorches.push({ light: light, flameMesh: flame });

            const torchOffsetFromWall = TORCH_WALL_OFFSET; // Distance from the torch to the wall surface
            const halfCell = CELL_SIZE / 2;

            let torchPosX = pathCellX;
            let torchPosZ = pathCellZ;
            let holderRotationY = 0;

            // The torch is placed "on the wall" of the current path cell (pathCellX, pathCellZ)
            if (attachSide === 'N') { // Wall to the North of the path cell, torch faces South
                torchPosZ = pathCellZ - halfCell + torchOffsetFromWall;
                holderRotationY = Math.PI;
            } else if (attachSide === 'S') { // Wall to the South, torch faces North
                torchPosZ = pathCellZ + halfCell - torchOffsetFromWall;
                holderRotationY = 0;
            } else if (attachSide === 'W') { // Wall to the West, torch faces East
                torchPosX = pathCellX - halfCell + torchOffsetFromWall;
                holderRotationY = Math.PI / 2;
            } else if (attachSide === 'E') { // Wall to the East, torch faces West
                torchPosX = pathCellX + halfCell - torchOffsetFromWall;
                holderRotationY = -Math.PI / 2;
            }

            holder.position.set(torchPosX, torchY, torchPosZ);
            holder.rotation.y = holderRotationY;
            flame.position.set(torchPosX, torchY + 0.5, torchPosZ); // Flame above the holder
            light.position.set(torchPosX, torchY + 0.4, torchPosZ); // Light near the flame

            scene.add(holder);
            scene.add(flame);
            scene.add(light);
        }


        // --- Touch Controls ---
        let touchControlsSetupDone = false;

        // Helper function to check if event target is inside a UI screen
        function isInsideUIScreen(target) {
             return target.closest('#loading-screen') ||
                    target.closest('#custom-game-screen') ||
                    target.closest('#scenario-editor-screen');
        }

        function updateJoystickThumb() {
            const dX=joystickCurrentPos.x-joystickStartPos.x, dY=joystickCurrentPos.y-joystickStartPos.y, dist=Math.sqrt(dX*dX+dY*dY); const angle=Math.atan2(dY,dX); const tD=Math.min(dist, JOYSTICK_VISUAL_RADIUS/2-joystickThumb.offsetWidth/4); const tX=Math.cos(angle)*tD, tY=Math.sin(angle)*tD; joystickThumb.style.transform=`translate(${tX}px, ${tY}px)`;
        }

        function updateMovementFromJoystick() {
            const dx=joystickCurrentPos.x-joystickStartPos.x, dy=joystickCurrentPos.y-joystickStartPos.y, dist=Math.sqrt(dx*dx+dy*dy); if(dist===0){moveForward=0; moveRight=0; return;} const nX=dx/JOYSTICK_EFFECTIVE_RADIUS, nY=dy/JOYSTICK_EFFECTIVE_RADIUS; const mag=Math.min(1.0, dist/JOYSTICK_EFFECTIVE_RADIUS); let fwd=-nY*mag, rgt=nX*mag; if(dist/JOYSTICK_EFFECTIVE_RADIUS<JOYSTICK_DEADZONE){fwd=0; rgt=0;} moveForward=Math.max(-1,Math.min(1,fwd)); moveRight=Math.max(-1,Math.min(1,rgt));
        }


        function setupTouchControls() {
            if (touchControlsSetupDone) return;
            // Add check at the beginning of handlers to ignore UI clicks
            document.body.addEventListener('pointerdown', handlePointerDown);
            document.body.addEventListener('pointermove', handlePointerMove);
            document.body.addEventListener('pointerup', handlePointerEnd);
            document.body.addEventListener('pointercancel', handlePointerEnd);
            jumpButton.addEventListener('touchstart', (e) => { e.preventDefault(); if (playerOnGround && gameActive) playerVelocity.y = JUMP_VELOCITY; }, { passive: false });
            actionButton.addEventListener('touchstart', (e) => { e.preventDefault(); if (gameActive) toggleView(); }, { passive: false });
            touchControlsSetupDone = true;
        }

        function handlePointerDown(event) {
             // If the event is inside a UI screen, let the browser handle it
            if (isInsideUIScreen(event.target)) {
                return;
            }

             // Existing logic - skip if target is specific game button/area
             if (event.target === jumpButton || event.target === actionButton || event.target.closest('#minimapCanvas')) return;

             event.preventDefault(); // Prevent default behavior (like scrolling, text selection) for game controls

             const tX=event.clientX, tY=event.clientY, sW=window.innerWidth;
             if (tX < sW/2 && joystickPointerId===-1){
                 joystickPointerId=event.pointerId;
                 joystickStartPos={x:tX,y:tY};
                 joystickCurrentPos={x:tX,y:tY};
                 joystickArea.style.display='flex';
                 joystickArea.style.left=`${tX}px`;
                 joystickArea.style.top=`${tY}px`;
                 joystickThumb.style.transform='translate(0px, 0px)';
                 updateMovementFromJoystick();
             } else if (tX >= sW/2 && cameraPointerId===-1){
                 cameraPointerId=event.pointerId;
                 cameraTouchStartPos={x:tX, y:tY};
             }
        }

        function handlePointerMove(event) {
            // If the event is inside a UI screen, let the browser handle it
            if (isInsideUIScreen(event.target)) {
                return;
            }

            // Existing logic - skip if target is specific game button/area
            if (event.target === jumpButton || event.target === actionButton || event.target.closest('#minimapCanvas')) return;

            event.preventDefault(); // Prevent default behavior

             if(event.pointerId===joystickPointerId){
                 joystickCurrentPos={x:event.clientX, y:event.clientY};
                 updateJoystickThumb();
                 updateMovementFromJoystick();
             } else if(event.pointerId===cameraPointerId){
                 const tX=event.clientX, tY=event.clientY;
                 updateCameraLook(tX-cameraTouchStartPos.x, tY-cameraTouchStartPos.y);
                 cameraTouchStartPos={x:tX,y:tY};
             }
        }

        function handlePointerEnd(event) {
            // If the event is inside a UI screen, let the browser handle it
            if (isInsideUIScreen(event.target)) {
                return;
            }

            // Existing logic - skip if target is specific game button/area
            if (event.target === jumpButton || event.target === actionButton || event.target.closest('#minimapCanvas')) return;

            // event.preventDefault(); // Usually not needed for pointerup

             if(event.pointerId===joystickPointerId){
                 joystickPointerId=-1;
                 joystickArea.style.display='none';
                 moveForward=0;
                 moveRight=0;
             } else if(event.pointerId===cameraPointerId){
                 cameraPointerId=-1;
             }
        }


        // --- Keyboard and Mouse Controls ---
        let keyboardControlsSetupDone = false;
        function setupKeyboardAndMouseControls() {
            if (keyboardControlsSetupDone) return;
            document.addEventListener('keydown', (event) => { keyStates[event.code] = true; handleKeyPress(event.code); });
            document.addEventListener('keyup', (event) => { keyStates[event.code] = false; });
            renderer.domElement.addEventListener('mousedown', (event) => { if (event.button === 0 && !isPointerLocked && gameActive) { renderer.domElement.requestPointerLock(); } });
            renderer.domElement.addEventListener('contextmenu', (event) => { event.preventDefault(); if (gameActive) { toggleView(); } });
            document.addEventListener('pointerlockchange', () => { isPointerLocked = document.pointerLockElement === renderer.domElement; if (isPointerLocked) { if (pointerLockInfoDiv) pointerLockInfoDiv.style.display = 'none'; renderer.domElement.style.cursor = 'none'; } else { if (pointerLockInfoDiv && !isTouchDevice) pointerLockInfoDiv.style.display = 'block'; renderer.domElement.style.cursor = 'grab'; keyStates = {}; moveForward=0; moveRight=0; /* Reset movement on losing focus */ } }, false);
            document.addEventListener('pointerlockerror', () => { console.error('Error blocking mouse pointer.'); if (pointerLockInfoDiv && !isTouchDevice) pointerLockInfoDiv.style.display = 'block'; }, false);
            document.addEventListener('mousemove', (event) => { if (isPointerLocked && gameActive) { updateCameraLook(event.movementX, event.movementY); } });
            keyboardControlsSetupDone = true;
        }
        function handleKeyPress(code) {
            if (!gameActive) return; if (code === 'KeyV') { toggleView(); }
        }
        function updateMovementFromKeyboard() {
            if (isTouchDevice || !isPointerLocked) { moveForward=0; moveRight=0; return; } let newMoveForward = 0; let newMoveRight = 0; if (keyStates['KeyW'] || keyStates['ArrowUp']) newMoveForward = 1; if (keyStates['KeyS'] || keyStates['ArrowDown']) newMoveForward = -1; if (keyStates['KeyA'] || keyStates['ArrowLeft']) newMoveRight = -1; if (keyStates['KeyD'] || keyStates['ArrowRight']) newMoveRight = 1; if (joystickPointerId === -1) { moveForward = newMoveForward; moveRight = newMoveRight; } if (keyStates['Space'] && playerOnGround) { playerVelocity.y = JUMP_VELOCITY; }
        }
        function updateCameraLook(deltaX, deltaY) {
            cameraTheta -= deltaX * CAMERA_SENSITIVITY; cameraPhi -= deltaY * CAMERA_SENSITIVITY; cameraPhi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraPhi));
        }


        // --- Toggle View ---
        function toggleView() {
            if (!player || !camera || !playerTorchLight || !playerTorchGroup || !scene) return; isFirstPersonView = !isFirstPersonView; player.visible = !isFirstPersonView; if (isFirstPersonView) { showMessage("Vista: Primera Persona", 1500); playerTorchLight.castShadow = false; if (playerTorchLight.parent) playerTorchLight.parent.remove(playerTorchLight); scene.add(playerTorchLight); if (playerTorchGroup.parent) playerTorchGroup.parent.remove(playerTorchGroup); camera.add(playerTorchGroup); playerTorchGroup.position.copy(FPS_TORCH_GROUP_OFFSET); playerTorchGroup.rotation.copy(FPS_TORCH_GROUP_ROTATION); playerTorchGroup.visible = true; } else { showMessage("Vista: Tercera Persona", 1500); playerTorchLight.castShadow = true; if (playerTorchLight.parent === scene) scene.remove(playerTorchLight); player.add(playerTorchLight); playerTorchLight.position.copy(originalPlayerTorchLightPosition); playerTorchLight.rotation.set(0,0,0); if (playerTorchGroup.parent === camera) camera.remove(playerTorchGroup); player.add(playerTorchGroup); playerTorchGroup.position.copy(originalPlayerTorchGroupPosition); playerTorchGroup.rotation.copy(originalPlayerTorchGroupRotation); playerTorchGroup.visible = true; } updateCamera();
        }


        // --- Player Logic and Collisions ---
        function updatePlayer(deltaTime) {
            if (!gameActive || !player) return; if (!isTouchDevice) { updateMovementFromKeyboard(); } player.rotation.y = cameraTheta + Math.PI; let currentSpeed = PLAYER_SPEED; let isSprinting = (!isTouchDevice && keyStates['ShiftLeft'] && moveForward > 0); if (playerOnGround && ( (moveForward > SPRINT_THRESHOLD && joystickPointerId !== -1) || isSprinting) ) { currentSpeed = SPRINT_SPEED; } let dampingFactor = playerOnGround ? 0.85 : 0.98; if (!playerOnGround) playerVelocity.y += GRAVITY * deltaTime; playerVelocity.y = Math.max(playerVelocity.y, -30); const forward = new THREE.Vector3(0, 0, -1); forward.applyQuaternion(player.quaternion); forward.y = 0; forward.normalize(); const right = new THREE.Vector3(1, 0, 0); right.applyQuaternion(player.quaternion); right.y = 0; right.normalize(); const targetVelocityXZ = new THREE.Vector3(); targetVelocityXZ.addScaledVector(forward, -moveForward * currentSpeed); targetVelocityXZ.addScaledVector(right,   -moveRight * currentSpeed); playerVelocity.x += (targetVelocityXZ.x - playerVelocity.x) * 0.25; playerVelocity.z += (targetVelocityXZ.z - playerVelocity.z) * 0.25; playerVelocity.x *= dampingFactor; playerVelocity.z *= dampingFactor; const deltaPosition = playerVelocity.clone().multiplyScalar(deltaTime); playerOnGround = false; const collisionSizeVec = new THREE.Vector3(PLAYER_RADIUS * 2, PLAYER_HEIGHT, PLAYER_RADIUS * 2); const verticalCheckCenter = player.position.clone().add(new THREE.Vector3(0, deltaPosition.y, 0)); collisionCheckTempBox.setFromCenterAndSize(verticalCheckCenter, collisionSizeVec); for (const obj of collidableObjects) { if (obj.userData.isFloor || obj.userData.isCeiling) continue; const oB = new THREE.Box3().setFromObject(obj); if (collisionCheckTempBox.intersectsBox(oB)) { if (deltaPosition.y < 0 && collisionCheckTempBox.min.y < oB.max.y) { playerVelocity.y = 0; deltaPosition.y = oB.max.y - (player.position.y - PLAYER_HEIGHT / 2) + 0.001; playerOnGround = true; } else if (deltaPosition.y > 0 && collisionCheckTempBox.max.y > oB.min.y) { playerVelocity.y = 0; deltaPosition.y = oB.min.y - (player.position.y + PLAYER_HEIGHT / 2) - 0.001; } break; } } const groundY = 0; const feetY = player.position.y + deltaPosition.y - PLAYER_HEIGHT / 2; if (feetY <= groundY && playerVelocity.y <= 0) { playerVelocity.y = 0; deltaPosition.y = groundY - (player.position.y - PLAYER_HEIGHT / 2); playerOnGround = true; } const finalVerticalPos = player.position.clone().add(new THREE.Vector3(0, deltaPosition.y, 0)); const horizontalCheckCenter = finalVerticalPos.clone().add(new THREE.Vector3(deltaPosition.x, 0, deltaPosition.z)); collisionCheckTempBox.setFromCenterAndSize(horizontalCheckCenter, collisionSizeVec); for (const obj of collidableObjects) { if (obj.userData.isFloor || obj.userData.isCeiling) continue; const oB = new THREE.Box3().setFromObject(obj); if (collisionCheckTempBox.intersectsBox(oB)) { const currentBoxX = new THREE.Box3().setFromCenterAndSize(finalVerticalPos.clone().add(new THREE.Vector3(deltaPosition.x, 0, 0)), collisionSizeVec); if (currentBoxX.intersectsBox(oB)) { playerVelocity.x = 0; deltaPosition.x = 0; } const currentBoxZ = new THREE.Box3().setFromCenterAndSize(finalVerticalPos.clone().add(new THREE.Vector3(0, 0, deltaPosition.z)), collisionSizeVec); if (currentBoxZ.intersectsBox(oB)) { playerVelocity.z = 0; deltaPosition.z = 0; } } } player.position.add(deltaPosition); if (endZone && gameActive) { const pXZ = new THREE.Vector2(player.position.x, player.position.z); const eZXZ = new THREE.Vector2(endZone.position.x, endZone.position.z); if (playerOnGround && pXZ.distanceTo(eZXZ) < PLAYER_RADIUS + CELL_SIZE * 0.3) winGame(); }
        }


        // --- Camera Update ---
        function updateCamera() {
            if (!player || !camera) return; if (isFirstPersonView) { camera.position.copy(player.position); camera.position.y += PLAYER_HEIGHT * FIRST_PERSON_EYE_HEIGHT_FACTOR; camera.rotation.order = 'YXZ'; camera.rotation.y = cameraTheta; camera.rotation.x = cameraPhi - CAMERA_PITCH_OFFSET_FPS; camera.rotation.z = 0; camera.updateMatrixWorld(); if (playerTorchLight && playerTorchLight.parent === scene) { lightWorldPosHelper.copy(FPS_TORCH_LIGHT_OFFSET); camera.localToWorld(lightWorldPosHelper); playerTorchLight.position.copy(lightWorldPosHelper); } for (const obj of currentlyTransparentObjects) { if (obj.material && typeof obj.material.opacity !== 'undefined' && obj.userData.isTransparentCapable) { obj.material.transparent = false; obj.material.opacity = obj.userData.originalOpacity || 1.0; } } currentlyTransparentObjects.clear(); } else { const targetPosition = new THREE.Vector3(); const offset = new THREE.Vector3(); offset.x = CAMERA_DISTANCE * Math.sin(cameraPhi) * Math.sin(cameraTheta); offset.y = CAMERA_DISTANCE * Math.cos(cameraPhi) + CAMERA_HEIGHT_OFFSET; offset.z = CAMERA_DISTANCE * Math.sin(cameraPhi) * Math.cos(cameraTheta); targetPosition.copy(player.position).add(offset); const cameraRaycaster = new THREE.Raycaster(); const rayOrigin = player.position.clone().add(new THREE.Vector3(0, PLAYER_HEIGHT * 0.3, 0)); const directionToCamera = targetPosition.clone().sub(rayOrigin).normalize(); const rayLength = rayOrigin.distanceTo(targetPosition); cameraRaycaster.set(rayOrigin, directionToCamera); cameraRaycaster.far = rayLength; const cameraCheckObjects = collidableObjects.filter(obj => obj !== player && !obj.userData.isFloor && obj.userData.isTransparentCapable); const intersects = cameraRaycaster.intersectObjects(cameraCheckObjects, false); let objectsToMakeTransparentThisFrame = new Set(); for (const intersect of intersects) { if (intersect.object.userData.isTransparentCapable) { objectsToMakeTransparentThisFrame.add(intersect.object); } } for (const obj of currentlyTransparentObjects) { if (!objectsToMakeTransparentThisFrame.has(obj)) { if (obj.material && typeof obj.material.opacity !== 'undefined' && obj.userData.isTransparentCapable) { obj.material.transparent = false; obj.material.opacity = obj.userData.originalOpacity || 1.0; } } } for (const obj of objectsToMakeTransparentThisFrame) { if (obj.material && typeof obj.material.opacity !== 'undefined' && obj.userData.isTransparentCapable) { obj.material.transparent = true; obj.material.opacity = OBSTACLE_OPACITY; } } currentlyTransparentObjects = objectsToMakeTransparentThisFrame; let finalCameraPosition = targetPosition.clone(); if (intersects.length > 0) { let closestDistance = rayLength; for (const intersect of intersects) { if (intersect.distance < closestDistance) { closestDistance = intersect.distance; } } finalCameraPosition.copy(rayOrigin).addScaledVector(directionToCamera, Math.max(0.5, closestDistance - 0.3)); } finalCameraPosition.y = Math.max(finalCameraPosition.y, player.position.y + MIN_CAMERA_Y_ABOVE_GROUND); camera.position.copy(finalCameraPosition); const lookAtTarget = player.position.clone().add(new THREE.Vector3(0, PLAYER_HEIGHT * 0.3, 0)); camera.lookAt(lookAtTarget); }
        }

        // --- Minimap Function ---
        function drawMinimap() {
            if (!minimapCtx || !player || !maze.length || !visibilityMaze.length || !currentMazeWidth || !currentMazeHeight) return;
            const playerGridX = Math.round(player.position.x / CELL_SIZE + currentMazeWidth / 2 - 0.5);
            const playerGridZ = Math.round(player.position.z / CELL_SIZE + currentMazeHeight / 2 - 0.5);
            minimapCtx.clearRect(0, 0, minimapWidth, minimapHeight); minimapCtx.save(); minimapCtx.translate(minimapWidth / 2, minimapHeight / 2); minimapCtx.rotate(cameraTheta);
            const radius = MINIMAP_RADIUS_CELLS; const cellSizePx = MINIMAP_CELL_SIZE_PX;
            for (let relZ = -radius; relZ <= radius; relZ++) {
                for (let relX = -radius; relX <= radius; relX++) {
                    const checkX = playerGridX + relX; const checkZ = playerGridZ + relZ;
                    let fillColor;
                    if (!visibilityMaze[checkZ] || typeof visibilityMaze[checkZ][checkX] === 'undefined' || !visibilityMaze[checkZ][checkX]) {
                        fillColor = MINIMAP_UNSEEN_COLOR;
                    } else {
                        if (checkX < 0 || checkX >= currentMazeWidth || checkZ < 0 || checkZ >= currentMazeHeight) {
                            fillColor = MINIMAP_UNSEEN_COLOR; // Outside maze but visible on minimap
                        } else {
                            const cellType = maze[checkZ][checkX];
                            if (cellType === 0) fillColor = MINIMAP_WALL_COLOR;
                            else if (cellType === 6) fillColor = MINIMAP_END_COLOR;
                            else fillColor = MINIMAP_PATH_COLOR;
                        }
                    }
                    minimapCtx.fillStyle = fillColor;
                    const drawX = relX * cellSizePx - cellSizePx / 2; const drawY = relZ * cellSizePx - cellSizePx / 2;
                    minimapCtx.fillRect(drawX, drawY, cellSizePx, cellSizePx);
                }
            }
            minimapCtx.restore(); minimapCtx.beginPath(); const playerMarkerSize = cellSizePx * 0.9; const halfSize = playerMarkerSize / 2; minimapCtx.moveTo(minimapWidth / 2, minimapHeight / 2 - halfSize * 0.8); minimapCtx.lineTo(minimapWidth / 2 - halfSize * 0.6, minimapHeight / 2 + halfSize * 0.5); minimapCtx.lineTo(minimapWidth / 2 + halfSize * 0.6, minimapHeight / 2 + halfSize * 0.5); minimapCtx.closePath(); minimapCtx.fillStyle = MINIMAP_PLAYER_COLOR; minimapCtx.fill();
        }

        // --- Fog of War ---
        function hasLineOfSight(x0, z0, x1, z1) {
            let dx = Math.abs(x1 - x0); let sx = x0 < x1 ? 1 : -1; let dz = -Math.abs(z1 - z0); let sz = z0 < z1 ? 1 : -1; let err = dx + dz; let currentX = x0; let currentZ = z0; let steps = 0; const maxSteps = currentMazeWidth + currentMazeHeight;
            while (steps < maxSteps) {
                steps++;
                if (currentX === x1 && currentZ === z1) return true;
                // Don't mark the start cell of the ray as a blocking wall
                if (!(currentX === x0 && currentZ === z0)) {
                    if (currentX >= 0 && currentX < currentMazeWidth && currentZ >= 0 && currentZ < currentMazeHeight) {
                        if (maze[currentZ][currentX] === 0) { // Is a wall
                            if (visibilityMaze[currentZ] && typeof visibilityMaze[currentZ][currentX] !== 'undefined') {
                                visibilityMaze[currentZ][currentX] = true; // Reveal the wall that blocked vision
                            }
                            return false; // Blocked
                        }
                    } else { return false; /* Outside maze bounds */ }
                }
                let e2 = 2 * err; let moved = false;
                if (e2 >= dz) { if (currentX === x1 && currentZ === z1 && !(currentX === x0 && currentZ === z0)) break; err += dz; currentX += sx; moved = true; }
                if (e2 <= dx) { if (currentX === x1 && currentZ === z1 && !(currentX === x0 && currentZ === z0)) break; err += dx; currentZ += sz; moved = true; }
                if (!moved && (currentX !== x1 || currentZ !== z1)) { return false; /* Stuck, should rarely happen */ }
            }
            return (currentX === x1 && currentZ === z1); // Final check
        }
        function updateVisibility() {
            if (!player || !visibilityMaze.length || !maze.length || !currentMazeWidth || !currentMazeHeight) return;
            const playerGridX = Math.round(player.position.x / CELL_SIZE + currentMazeWidth / 2 - 0.5);
            const playerGridZ = Math.round(player.position.z / CELL_SIZE + currentMazeHeight / 2 - 0.5);
            const visionRadius = PLAYER_VISION_RADIUS_CELLS;
            if (playerGridX >= 0 && playerGridX < currentMazeWidth && playerGridZ >= 0 && playerGridZ < currentMazeHeight) {
                if(visibilityMaze[playerGridZ]) visibilityMaze[playerGridZ][playerGridX] = true;
            }
            for (let relZ = -visionRadius; relZ <= visionRadius; relZ++) {
                for (let relX = -visionRadius; relX <= visionRadius; relX++) {
                    if (relX === 0 && relZ === 0) continue;
                    if (relX * relX + relZ * relZ <= visionRadius * visionRadius) {
                        const checkX = playerGridX + relX; const checkZ = playerGridZ + relZ;
                        if (checkX >= 0 && checkX < currentMazeWidth && checkZ >= 0 && checkZ < currentMazeHeight) {
                            if (hasLineOfSight(playerGridX, playerGridZ, checkX, checkZ)) {
                                if(visibilityMaze[checkZ]) visibilityMaze[checkZ][checkX] = true;
                            }
                        }
                    }
                }
            }
        }


        // --- Animation Loop ---
        let animationFrameId;
        function animate() {
            if (!gameActive) {
                if (animationFrameId) cancelAnimationFrame(animationFrameId);
                return;
            }
            animationFrameId = requestAnimationFrame(animate);
            const dT = Math.min(0.05, clock.getDelta()); // Cap delta time
            const flicker = (Math.random() - 0.5) * TORCH_FLICKER_AMOUNT;

            if (playerTorchLight && playerTorchLight.userData.baseIntensity) { playerTorchLight.intensity = Math.max(0, playerTorchLight.userData.baseIntensity + flicker); }
            if (playerTorchFlameMesh && playerTorchFlameMesh.material) { const pVO = (Math.random()-0.5)*FLAME_OPACITY_VAR; const pVS = (Math.random()-0.5)*FLAME_SCALE_Y_VAR; playerTorchFlameMesh.material.opacity = Math.max(0.1,Math.min(1.0,FLAME_BASE_OPACITY+pVO)); playerTorchFlameMesh.scale.y = Math.max(0.1,FLAME_BASE_SCALE_Y+pVS); playerTorchFlameMesh.scale.x = playerTorchFlameMesh.scale.z = Math.max(0.1,FLAME_BASE_SCALE_Y*0.8+pVS*0.5); }
            for (const torch of staticTorches) { const sLF = (Math.random()-0.5)*TORCH_FLICKER_AMOUNT*1.1; const vO = (Math.random()-0.5)*FLAME_OPACITY_VAR; const vS = (Math.random()-0.5)*FLAME_SCALE_Y_VAR; if (torch.light?.userData.baseIntensity) { torch.light.intensity = Math.max(0, torch.light.userData.baseIntensity + sLF); } if (torch.flameMesh?.material) { torch.flameMesh.material.opacity = Math.max(0.1,Math.min(1.0,FLAME_BASE_OPACITY+vO)); torch.flameMesh.scale.y = Math.max(0.1,FLAME_BASE_SCALE_Y+vS); torch.flameMesh.scale.x = torch.flameMesh.scale.z = Math.max(0.1,FLAME_BASE_SCALE_Y*0.8 + vS * 0.5); } }

            updatePlayer(dT);
            updateCamera();
            updateVisibility();
            drawMinimap();

            if(renderer && scene && camera) renderer.render(scene, camera);
        }


        // --- Utilities ---
        function onWindowResize() { updateRendererAndCameraSize(); }
        let messageTimeout = null; function showMessage(text, duration = 2500) { if (messageTimeout) clearTimeout(messageTimeout); messageDiv.textContent = text; messageDiv.style.display = 'block'; messageTimeout = setTimeout(() => { messageDiv.style.display = 'none'; messageTimeout = null; }, duration); }
        function winGame() { if (!gameActive) return; gameActive = false; showMessage("¬°HAS ESCAPADO!", 10000); console.log("Juego ganado!"); if (isPointerLocked && document.pointerLockElement) document.exitPointerLock(); setTimeout(() => { // Go back to main menu or scenario list if came from there
            // For now, reload the page, but ideally would go to selection screen.
            // showCustomGameUI(); // Could be an option
            window.location.reload(); // Simple for now
        }, 5000); }
        function updateRendererAndCameraSize() {
            const width = window.innerWidth; const height = window.innerHeight; const maxDim = Math.max(width, height); const scaleFactor = maxDim > MAX_RESOLUTION_DIMENSION ? MAX_RESOLUTION_DIMENSION / maxDim : 1; const renderWidth = Math.floor(width * scaleFactor); const renderHeight = Math.floor(height * scaleFactor); if(renderer && camera) { renderer.setSize(renderWidth, renderHeight, false); camera.aspect = renderWidth / renderHeight; camera.updateProjectionMatrix(); }
        }

        // --- Custom Game and Editor UI Logic (Continuation) ---
        function showCustomGameUI() {
            gameActive = false; // Stop the game if it was running
            if (isPointerLocked && document.pointerLockElement) document.exitPointerLock();
            if(startOptionsDiv) startOptionsDiv.style.display = 'none';
            if(loadingTextElement) loadingTextElement.style.display = 'none';
            if(loadingScreenElement) loadingScreenElement.style.display = 'none';
            customGameScreen.style.display = 'flex';
            scenarioEditorScreen.style.display = 'none';
            loadAndDisplayCustomScenarios();
        }

        backToMainMenuBtn.addEventListener('click', () => {
            customGameScreen.style.display = 'none';
            if(loadingScreenElement) loadingScreenElement.style.display = 'flex';
            if(startOptionsDiv) startOptionsDiv.style.display = 'flex';
        });

        async function loadAndDisplayCustomScenarios() {
            try {
                const scenarios = await getAllScenariosDB();
                customScenarioListUL.innerHTML = '';
                if (scenarios && scenarios.length > 0) {
                    noCustomScenariosMsg.style.display = 'none';
                    scenarios.forEach(scenario => {
                        const listItem = document.createElement('li');
                        listItem.classList.add('scenario-item');
                        listItem.innerHTML = `
                            <span>${escapeHTML(scenario.name)} (${scenario.width}x${scenario.height})</span>
                            <div class="scenario-actions">
                                <button class="action-btn play-scenario-btn" data-id="${scenario.id}">Jugar</button>
                                <button class="action-btn edit-scenario-btn" data-id="${scenario.id}">Editar</button>
                                <button class="action-btn export-scenario-btn" data-id="${scenario.id}">Exportar</button>
                                <button class="action-btn delete-scenario-btn" data-id="${scenario.id}">Eliminar</button>
                            </div>
                        `;
                        customScenarioListUL.appendChild(listItem);
                    });
                    addScenarioActionListeners();
                } else {
                    noCustomScenariosMsg.style.display = 'block';
                }
            } catch (error) {
                console.error("Error loading scenarios:", error);
                noCustomScenariosMsg.textContent = "Error loading scenarios.";
                noCustomScenariosMsg.style.display = 'block';
            }
        }

        function addScenarioActionListeners() {
            document.querySelectorAll('.play-scenario-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const scenarioId = parseInt(e.target.dataset.id);
                    const scenarioToPlay = await getScenarioByIdDB(scenarioId);
                    if (scenarioToPlay) {
                        customGameScreen.style.display = 'none';
                        if(loadingTextElement) loadingTextElement.style.display = 'block'; // Show "Loading..."
                        if(loadingScreenElement) loadingScreenElement.style.display = 'flex'; // Show loading background
                        preloadTextures(() => {
                            init(scenarioToPlay); // Pass scenario data
                            finalizeLoadingScreen();
                        });
                    } else {
                        alert("Error: Could not load scenario to play.");
                    }
                });
            });
            document.querySelectorAll('.edit-scenario-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const scenarioId = parseInt(e.target.dataset.id);
                    openScenarioEditor(scenarioId);
                });
            });
            document.querySelectorAll('.export-scenario-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const scenarioId = parseInt(e.target.dataset.id);
                    const scenario = await getScenarioByIdDB(scenarioId);
                    if (scenario) {
                        const { id, ...exportData } = scenario; // Remove ID for clean export
                        exportScenarioAsJSON(exportData);
                    }
                });
            });
            document.querySelectorAll('.delete-scenario-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const scenarioId = parseInt(e.target.dataset.id);
                    if (confirm("Are you sure you want to delete this scenario?")) {
                        try {
                            await deleteScenarioDB(scenarioId);
                            loadAndDisplayCustomScenarios();
                        } catch (error) {
                            console.error("Error deleting scenario:", error);
                            alert("Error deleting scenario.");
                        }
                    }
                });
            });
        }

        function exportScenarioAsJSON(scenarioData) {
            const jsonString = JSON.stringify(scenarioData, null, 2);
            const blob = new Blob([jsonString], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `${scenarioData.name.replace(/[^a-z0-9\s-]/gi, '_').trim().replace(/\s+/g, '-').toLowerCase() || 'custom_scenario'}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        importScenarioBtn.addEventListener('click', () => { importFileInput.click(); });
        importFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const importedScenario = JSON.parse(e.target.result);
                        if (importedScenario.name && importedScenario.width && importedScenario.height && importedScenario.grid &&
                            Array.isArray(importedScenario.grid) && importedScenario.grid.length === importedScenario.height &&
                            importedScenario.grid.every(row => Array.isArray(row) && row.length === importedScenario.width)) {

                            let scenarioToSave = { // Create object with expected fields
                                name: importedScenario.name,
                                width: importedScenario.width,
                                height: importedScenario.height,
                                grid: importedScenario.grid
                            };

                            const existingScenarios = await getAllScenariosDB();
                            const existingByName = existingScenarios.find(s => s.name === scenarioToSave.name);

                            if (existingByName) {
                                if (confirm(`A scenario named "${scenarioToSave.name}" already exists. Do you want to overwrite it?`)) {
                                    scenarioToSave.id = existingByName.id; // Assign ID to overwrite
                                } else {
                                    importFileInput.value = ''; return;
                                }
                            }
                            await saveScenarioDB(scenarioToSave);
                            loadAndDisplayCustomScenarios();
                            alert(`Scenario "${importedScenario.name}" imported successfully.`);
                        } else {
                            alert("The JSON file does not have the expected scenario format or is corrupt.");
                        }
                    } catch (error) {
                        console.error("Error importing scenario:", error);
                        alert("Error processing the JSON file. Ensure it is valid.");
                    }
                    importFileInput.value = '';
                };
                reader.readAsText(file);
            }
        });

        createNewScenarioBtn.addEventListener('click', () => {
            openScenarioEditor(null); // null indicates new scenario
        });

        backToCustomScreenBtn.addEventListener('click', () => {
             if (hasUnsavedChanges) {
                if (!confirm("You have unsaved changes. Are you sure you want to leave the editor? Changes will be lost.")) {
                    return;
                }
            }
            scenarioEditorScreen.style.display = 'none';
            customGameScreen.style.display = 'flex';
            currentEditingScenario = null;
            hasUnsavedChanges = false;
            editorMessageSpan.textContent = '';
        });

        async function openScenarioEditor(scenarioId) {
            customGameScreen.style.display = 'none';
            scenarioEditorScreen.style.display = 'flex';
            hasUnsavedChanges = false;
            editorMessageSpan.textContent = '';
            playEditedScenarioBtn.disabled = true; // Disabled until something is playable and saved

            if (scenarioId !== null) { // Editing
                const scenario = await getScenarioByIdDB(scenarioId);
                if (!scenario) { alert("Error: Could not load scenario."); backToCustomScreenBtn.click(); return; }
                currentEditingScenario = JSON.parse(JSON.stringify(scenario)); // Deep copy
                scenarioNameInput.value = currentEditingScenario.name;
                dimensionSelectorDiv.style.display = 'none'; // Hide size selector when editing
                scenarioNameInput.style.display = 'block'; // Show name input when editing
                brushToolsDiv.style.display = 'block'; // Show brush tools when editing
                editorActionsDiv.style.display = 'flex'; // Show actions when editing
                setupEditorGrid(currentEditingScenario.width, currentEditingScenario.height, currentEditingScenario.grid);
                checkEditorStateForPlayability(); // Check if playable on load
            } else { // New
                currentEditingScenario = { id: null, name: "", width: 0, height: 0, grid: [] };
                scenarioNameInput.value = '';
                dimensionSelectorDiv.style.display = 'flex'; // Show size selector for new maps
                scenarioNameInput.style.display = 'none'; // Hide name input initially for new maps
                brushToolsDiv.style.display = 'none'; // Hide brush tools initially for new maps
                editorActionsDiv.style.display = 'none'; // Hide actions initially for new maps
                editorGridContainer.innerHTML = ''; // Clear grid for new maps
            }
            // Reset active brush
            document.querySelectorAll('.brush-btn').forEach(b => b.classList.remove('active'));
            document.querySelector('.brush-btn[data-type="wall"]').classList.add('active');
            selectedBrush = 'wall';
        }

        confirmSizeBtn.addEventListener('click', () => {
            const [w, h] = scenarioSizeSelect.value.split('x').map(Number);
            currentEditingScenario.width = w;
            currentEditingScenario.height = h;
            // Initialize grid filled with walls (0)
            currentEditingScenario.grid = Array(h).fill(null).map(() => Array(w).fill(0));
            // Borders are always wall (already are by fill(0), but explicit in click logic)

            dimensionSelectorDiv.style.display = 'none';
            scenarioNameInput.style.display = 'block';
            scenarioNameInput.value = "Nuevo Laberinto"; // Default name
            currentEditingScenario.name = "Nuevo Laberinto";
            brushToolsDiv.style.display = 'block';
            editorActionsDiv.style.display = 'flex';
            setupEditorGrid(w, h, currentEditingScenario.grid);
            hasUnsavedChanges = true; // New scenario implies changes
            checkEditorStateForPlayability();
        });

        function setupEditorGrid(width, height, gridData) {
            editorGridContainer.innerHTML = ''; // Clear
            editorGridContainer.style.gridTemplateColumns = `repeat(${width}, 1fr)`;
            editorGridContainer.style.gridTemplateRows = `repeat(${height}, 1fr)`;
            editorGridData = JSON.parse(JSON.stringify(gridData)); // Deep copy for editing
            editorCellElements = []; // Reset cell element array

            for (let r = 0; r < height; r++) {
                editorCellElements[r] = [];
                for (let c = 0; c < width; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('grid-cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;

                    // Mark borders
                    if (r === 0 || r === height - 1 || c === 0 || c === width - 1) {
                        cell.classList.add('border');
                        editorGridData[r][c] = 0; // Ensure borders are walls in data
                    }
                    updateCellVisual(cell, editorGridData[r][c]);

                    cell.addEventListener('click', handleGridCellClick);
                    editorGridContainer.appendChild(cell);
                    editorCellElements[r][c] = cell; // Store the element
                }
            }
        }

        function updateCellVisual(cellElement, cellType) {
            cellElement.classList.remove('path', 'start', 'end', 'wall'); // Clear previous classes
            let symbol = '';
            switch (cellType) {
                case 0: cellElement.classList.add('wall'); break; // Wall
                case 1: cellElement.classList.add('path'); break; // Path
                case 5: cellElement.classList.add('start'); symbol = 'S'; break; // Start
                case 6: cellElement.classList.add('end'); symbol = 'E'; break; // End
                default: cellElement.classList.add('wall'); break; // Default to wall
            }
            cellElement.textContent = symbol;
        }

        function handleGridCellClick(event) {
            const cell = event.target;
            const r = parseInt(cell.dataset.row);
            const c = parseInt(cell.dataset.col);

            if (cell.classList.contains('border')) return; // Cannot modify borders

            let newType;
            switch (selectedBrush) {
                case 'wall': newType = 0; break;
                case 'path': newType = 1; break;
                case 'start': newType = 5; break;
                case 'end': newType = 6; break;
                default: return;
            }

            // If placing start (5) or end (6), find and remove the old one
            if (newType === 5 || newType === 6) {
                for (let i = 0; i < editorGridData.length; i++) {
                    for (let j = 0; j < editorGridData[i].length; j++) {
                        if (editorGridData[i][j] === newType) {
                            editorGridData[i][j] = 1; // Convert old one to path
                            if (editorCellElements[i] && editorCellElements[i][j]) {
                                updateCellVisual(editorCellElements[i][j], 1);
                            }
                        }
                    }
                }
            }

            editorGridData[r][c] = newType;
            updateCellVisual(cell, newType);
            hasUnsavedChanges = true;
            checkEditorStateForPlayability();
        }

        document.querySelectorAll('.brush-btn').forEach(button => {
            button.addEventListener('click', () => {
                document.querySelectorAll('.brush-btn').forEach(b => b.classList.remove('active'));
                button.classList.add('active');
                selectedBrush = button.dataset.type;
            });
        });

        saveScenarioBtn.addEventListener('click', async () => {
            const scenarioName = scenarioNameInput.value.trim();
            if (!scenarioName) {
                editorMessageSpan.textContent = "Please enter a scenario name.";
                return;
            }

            // Validations before saving
            const validationResult = validateEditorGrid();
            if (!validationResult.valid) {
                editorMessageSpan.textContent = validationResult.message;
                return;
            }

            currentEditingScenario.name = scenarioName;
            currentEditingScenario.grid = JSON.parse(JSON.stringify(editorGridData)); // Save the current copy

            try {
                // If existing scenario (has ID) and name changed,
                // check if the new name already exists (excluding the current ID).
                if (currentEditingScenario.id !== null && currentEditingScenario.id !== undefined) { // Check for non-null and non-undefined ID
                    const allScenarios = await getAllScenariosDB();
                    const nameConflict = allScenarios.find(s => s.name === currentEditingScenario.name && s.id !== currentEditingScenario.id);
                    if (nameConflict) {
                         if (!confirm(`A scenario named "${currentEditingScenario.name}" already exists. Do you want to overwrite the current scenario with this name anyway? (This will not affect the other scenario).`)) {
                            editorMessageSpan.textContent = "Save cancelled. Name conflict.";
                            return;
                        }
                    }
                } else { // New scenario, check if the name already exists
                     const allScenarios = await getAllScenariosDB();
                     const nameConflict = allScenarios.find(s => s.name === currentEditingScenario.name);
                     if (nameConflict) {
                        if (!confirm(`A scenario named "${currentEditingScenario.name}" already exists. Do you want to overwrite it?`)) {
                            editorMessageSpan.textContent = "Save cancelled. Name conflict.";
                            return;
                        }
                        currentEditingScenario.id = nameConflict.id; // Prepare to overwrite the existing one found by name
                     }
                }


                const savedScenario = await saveScenarioDB(currentEditingScenario);
                currentEditingScenario.id = savedScenario.id; // Update ID if it was new, or confirm if it was existing
                hasUnsavedChanges = false;
                editorMessageSpan.textContent = "Scenario saved!";
                playEditedScenarioBtn.disabled = false; // Enable play after saving
                setTimeout(() => editorMessageSpan.textContent = "", 2000);
                loadAndDisplayCustomScenarios(); // Refresh the list after saving
            } catch (error) {
                console.error("Error saving scenario:", error);
                editorMessageSpan.textContent = "Error saving. Check console.";
            }
        });

        playEditedScenarioBtn.addEventListener('click', () => {
            if (hasUnsavedChanges) {
                editorMessageSpan.textContent = "Save changes before playing.";
                return;
            }
            if (!currentEditingScenario || currentEditingScenario.id === null || currentEditingScenario.id === undefined) { // Check for valid ID
                editorMessageSpan.textContent = "Save the scenario first.";
                return;
            }
            const validation = validateEditorGrid();
            if (!validation.valid) {
                 editorMessageSpan.textContent = "The maze is not valid for playing: " + validation.message;
                 return;
            }

            scenarioEditorScreen.style.display = 'none';
            if(loadingTextElement) loadingTextElement.style.display = 'block';
            if(loadingScreenElement) loadingScreenElement.style.display = 'flex';

            // Use a deep copy of currentEditingScenario to play
            const scenarioToPlay = JSON.parse(JSON.stringify(currentEditingScenario));

            preloadTextures(() => {
                init(scenarioToPlay);
                finalizeLoadingScreen();
            });
        });

        function checkEditorStateForPlayability() {
            // Check if there is a scenario being edited AND if it has been saved at least once (has an ID)
            const isSaved = (currentEditingScenario && currentEditingScenario.id !== null && currentEditingScenario.id !== undefined);

            if (hasUnsavedChanges || !isSaved) {
                playEditedScenarioBtn.disabled = true;
                if (hasUnsavedChanges) {
                     editorMessageSpan.textContent = "Unsaved changes.";
                } else if (!isSaved) {
                    editorMessageSpan.textContent = "Save to enable 'Play'.";
                }
                 // Clear message if it was previously a validation error
                if (!hasUnsavedChanges && isSaved && editorMessageSpan.textContent.startsWith("The maze is not valid")) {
                    editorMessageSpan.textContent = ""; // Or a default message
                }

            } else {
                const validation = validateEditorGrid(); // Validate if it's playable
                playEditedScenarioBtn.disabled = !validation.valid;
                editorMessageSpan.textContent = validation.valid ? "Ready to play or save." : validation.message;
            }
        }

        function validateEditorGrid() {
            if (!editorGridData || editorGridData.length === 0 || !editorGridData[0] || editorGridData[0].length === 0) return {valid: false, message: "The grid is empty."};

            let startPoint = null, endPoint = null;
            const rows = editorGridData.length;
            const cols = editorGridData[0].length;


            for (let r = 0; r < rows; r++) {
                 if (!editorGridData[r]) { console.error(`Row ${r} is null/undefined in editorGridData`); continue; } // Defensive check
                for (let c = 0; c < cols; c++) {
                     // Defensive check for cell existence/value
                     const cellValue = editorGridData[r][c];
                     if (cellValue === undefined || cellValue === null) {
                         console.warn(`Cell [${r}][${c}] is null/undefined, treating as wall (0).`);
                         editorGridData[r][c] = 0; // Correct potentially bad data
                         // Update visual if cell element exists and editorCellElements is populated
                          if (editorCellElements && editorCellElements[r] && editorCellElements[r][c]) {
                            updateCellVisual(editorCellElements[r][c], 0);
                         }
                     }

                    if (editorGridData[r][c] === 5) {
                         if (startPoint) return {valid: false, message: "Only one start point (S) is allowed."};
                         startPoint = {r, c};
                    }
                    if (editorGridData[r][c] === 6) {
                         if (endPoint) return {valid: false, message: "Only one end point (E) is allowed."};
                         endPoint = {r, c};
                    }
                }
            }


            if (!startPoint) return {valid: false, message: "Missing a start point (S)."};
            if (!endPoint) return {valid: false, message: "Missing an end point (E)."};

             // Check if start/end are on a path cell type (not a wall 0) and not on the border
             if (editorGridData[startPoint.r][startPoint.c] === 0) return { valid: false, message: "Start (S) cannot be on a wall." };
             if (editorGridData[endPoint.r][endPoint.c] === 0) return { valid: false, message: "End (E) cannot be on a wall." };

             if (startPoint.r === 0 || startPoint.r === rows - 1 || startPoint.c === 0 || startPoint.c === cols - 1) return { valid: false, message: "Start (S) cannot be on the border." };
             if (endPoint.r === 0 || endPoint.r === rows - 1 || endPoint.c === 0 || endPoint.c === cols - 1) return { valid: false, message: "End (E) cannot be on the border." };


            // Validation of accessibility (BFS)
            const queue = [[startPoint.r, startPoint.c]];
            const visited = Array(rows).fill(null).map(() => Array(cols).fill(false));
            visited[startPoint.r][startPoint.c] = true;
            let pathFound = false;

            const dr = [-1, 1, 0, 0]; // Delta row (N, S)
            const dc = [0, 0, -1, 1]; // Delta col (W, E)

            while (queue.length > 0) {
                const [r, c] = queue.shift();
                if (r === endPoint.r && c === endPoint.c) {
                    pathFound = true;
                    break;
                }
                for (let i = 0; i < 4; i++) {
                    const nr = r + dr[i];
                    const nc = c + dc[i];
                    // Check bounds before accessing editorGridData or visited
                    if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                         // Ensure cell is not a wall (0) and hasn't been visited
                        if (!visited[nr][nc] && editorGridData[nr][nc] !== 0) {
                             visited[nr][nc] = true;
                             queue.push([nr, nc]);
                        }
                    }
                }
            }

            if (!pathFound) return {valid: false, message: "The end point is not accessible from the start."};
            return {valid: true, message: "Valid maze."};
        }

        function escapeHTML(str) {
            if (str === null || str === undefined) return "";
            return String(str).replace(/[&<>"']/g, function (match) {
                return { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[match];
            });
        }


        // --- Start Game ---
        function startGameSequence() {
            console.log("Showing start options...");
            if(gameVersionSpan) gameVersionSpan.textContent = GAME_VERSION;
            if(loadingScreenElement) loadingScreenElement.style.display = 'flex';
            if(startOptionsDiv) startOptionsDiv.style.display = 'flex';
            if(loadingTextElement) loadingTextElement.style.display = 'none';

            // Initialize IndexedDB here
            initDB().then(() => {
                console.log("Database ready for use from startGameSequence.");
                // Enable buttons that depend on DB if necessary
                 if (startCustomGameButton) startCustomGameButton.disabled = false; // Ensure button is enabled if DB is ok
            }).catch(error => {
                console.error("Database initialization failed. Custom game will not work correctly.", error);
                alert("Could not initialize database for custom scenarios. This feature might not be available.");
                if (startCustomGameButton) startCustomGameButton.disabled = true; // Disable if DB fails
            });


            startAutoGameButton.addEventListener('click', () => {
                if(startOptionsDiv) startOptionsDiv.style.display = 'none';
                if(loadingTextElement) loadingTextElement.style.display = 'block';
                console.log("Starting game with autogenerated maze...");
                preloadTextures(() => {
                    console.log("Texture preload complete. Starting game...");
                    init(); // Without argument for autogenerated maze
                    finalizeLoadingScreen();
                });
            });

            startCustomGameButton.addEventListener('click', showCustomGameUI);
             // Ensure global control listeners are added only once
            if (!touchControlsSetupDone && isTouchDevice) setupTouchControls();
            if (!keyboardControlsSetupDone && !isTouchDevice) setupKeyboardAndMouseControls();
            if (!window.onresize) window.addEventListener('resize', onWindowResize, false);
        }

        function finalizeLoadingScreen() {
            setTimeout(() => {
                if(loadingScreenElement) {
                    loadingScreenElement.style.opacity = '0';
                    setTimeout(() => {
                        loadingScreenElement.style.display = 'none';
                        loadingScreenElement.style.opacity = '1'; // Reset for future loads
                    }, 500);
                }
                console.log("Loading screen hidden. Game started.");
                 if (!isTouchDevice && pointerLockInfoDiv && pointerLockInfoDiv.style.display !== 'none' && !isPointerLocked) {
                    pointerLockInfoDiv.style.display = 'block'; // Show if not locked
                }
            }, 200);
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', startGameSequence);
        } else {
            startGameSequence();
        }
    </script>
</body>
</html>
