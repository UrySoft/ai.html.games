<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>City Defender - Juego Actualizado</title>
    <style>
        /* Estilos CSS */
        body, html {
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #000000 0%, #000000 70%, #000000 80%, #87CEEB 100%);
            color: #ffffff;
            font-family: Arial, sans-serif;
            overflow: hidden;
            height: 100%;
        }
        #gameCanvas {
            background-color: transparent;
            display: block;
            margin: 0 auto;
            box-sizing: border-box;
            width: 100%;
            height: calc(100% - 40px); /* Restar espacio para el botón de mejoras */
        }
        #scoreBoard {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 16px;
            z-index: 1;
            white-space: nowrap;
        }
        #scoreBoard span {
            margin-right: 15px;
        }
        #upgradeMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            padding: 20px;
            border: 2px solid #fff;
            display: none;
            text-align: center;
            width: 80%;
            max-width: 500px;
            box-sizing: border-box;
            z-index: 3;
        }
        #upgradeMenu h2, #upgradeMenu p {
            margin: 10px 0;
        }
        .upgrade-section {
            margin-bottom: 20px;
        }
        .upgrade-section h3 {
            margin-bottom: 10px;
        }
        .upgrade-buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
        }
        .upgrade-buttons button {
            margin: 10px 0;
            padding: 10px;
            font-size: 14px;
            width: 48%;
            background-color: #444;
            color: #fff;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .upgrade-buttons button:hover {
            background-color: #555;
        }
        #continueButton {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 16px;
            background-color: #4caf50;
            color: #fff;
            border: none;
            cursor: pointer;
        }
        #continueButton:hover {
            background-color: #66bb6a;
        }
        /* Estilo para el título del juego */
        #gameTitle {
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 20px;
            color: #ffffff;
            text-align: center;
            z-index: 2;
            font-weight: bold;
        }
        #gameSubtitle {
            position: absolute;
            top: 25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: #ffffff;
            text-align: center;
            z-index: 2;
        }
        /* Botón de mejoras */
        #upgradeButton {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40px;
            background-color: #444;
            color: #fff;
            border: none;
            cursor: pointer;
            z-index: 2;
            font-size: 16px;
        }
        #upgradeButton:hover {
            background-color: #555;
        }
    </style>
</head>
<body>
    <!-- Título del juego -->
    <div id="gameTitle">
        City Defender
    </div>
    <!-- Subtítulo con autor y versión actualizada -->
    <div id="gameSubtitle">
        by UrySoft Beta 1.8
    </div>
    <!-- Marcador actualizado -->
    <div id="scoreBoard">
        <span>Puntos: <span id="score">0</span></span>
        <span>Oleada: <span id="wave">1</span></span>
        <span>Coins: <span id="availableCoins">9999</span></span>
        <span>Misiles: <span id="baseShipMissiles">10</span></span>
    </div>
    <canvas id="gameCanvas"></canvas>
    <!-- Botón para acceder al menú de mejoras -->
    <button id="upgradeButton">Mejoras</button>
    <!-- Menú de mejoras actualizado -->
    <div id="upgradeMenu">
        <h2>Mejoras Disponibles</h2>
        <p>Coins disponibles: <span id="coinsToSpend">9999</span></p>
        <!-- Sección de mejoras de la nave -->
        <div class="upgrade-section">
            <h3>Mejoras de la Nave</h3>
            <div class="upgrade-buttons">
                <button id="repairBaseShip">
                    Reparar Nave (+1 vida)<br>
                    Vida actual: <span id="currentBaseShipHealth">6</span>/<span id="maxBaseShipHealth">6</span><br>
                    Costo: 5 coins
                </button>
                <button id="upgradeBaseShipHealth">
                    Aumentar vida máxima (+1)<br>
                    Vida máxima: <span id="maxBaseShipHealthDisplay">6</span><br>
                    Costo: <span id="costUpgradeBaseShipHealth">20</span> coins
                </button>
            </div>
        </div>
        <!-- Sección de mejoras de misiles -->
        <div class="upgrade-section">
            <h3>Mejoras de Misiles</h3>
            <div class="upgrade-buttons">
                <button id="buyMissiles">
                    Comprar Misiles (+5)<br>
                    Misiles actuales: <span id="currentMissiles">10</span>/<span id="maxMissiles">50</span><br>
                    Costo: 5 coins
                </button>
                <button id="upgradeMissileLimit">
                    Misiles simultáneos (+1)<br>
                    Actual: <span id="currentMissileLimit">2</span><br>
                    Costo: <span id="costMissileLimit">10</span> coins
                </button>
                <button id="upgradeMissileSpeed">
                    Velocidad misiles (+0.1)<br>
                    Actual: <span id="currentMissileSpeed">1.00</span><br>
                    Costo: <span id="costMissileSpeed">10</span> coins
                </button>
                <button id="upgradeExplosionSize">
                    Tamaño explosión (+0.1)<br>
                    Actual: <span id="currentExplosionSize">1.00</span><br>
                    Costo: <span id="costExplosionSize">20</span> coins
                </button>
                <button id="upgradeMissileDamage">
                    Daño de misiles (+1)<br>
                    Actual: <span id="currentMissileDamage">1</span><br>
                    Costo: <span id="costMissileDamage">25</span> coins
                </button>
            </div>
        </div>
        <button id="continueButton">Continuar</button>
    </div>
    <script>
        // Variables y constantes
        var canvas = document.getElementById('gameCanvas');
        var ctx = canvas.getContext('2d');

        var baseShip = null; // Nave base flotante
        var baseShipHealth = 6; // Vida de la nave base
        var baseShipMaxHealth = 6;
        var baseShipMissiles = 10; // Misiles de la nave base
        var maxMissiles = 50; // Máximo de misiles que puede almacenar

        var cities = [];
        var enemyMissiles = [];
        var playerMissiles = [];
        var explosions = [];
        var enemyShips = []; // Naves enemigas tipo naveMisiles
        var enemyHangars = []; // Naves enemigas tipo naveHangar
        var enemyFighters = []; // Naves enemigas tipo naveCaza

        var energyBullets = []; // Proyectiles de energía

        var score = 0;
        var wave = 1;
        var enemyShipsPerWave = 1;
        var enemyHangarsPerWave = 0;

        var missileLimit = 2;

        var missileSpeedMultiplier = 1.00;
        var explosionSizeMultiplier = 1.00;
        var explosionDurationMultiplier = 1.00;

        var missileDamage = 1; // Daño inicial de los misiles del jugador

        var canShoot = true;
        var coinsToSpend = 9999; // Jugador inicia con 9999 coins

        var gamePaused = false; // Variable para controlar el estado del juego

        // Ajuste de costos iniciales
        var costMissileLimit = 10;      // Costo inicial de Misiles simultáneos
        var costExplosionSize = 20;     // Costo inicial de Tamaño explosión
        var costMissileSpeed = 10;      // Costo inicial de Velocidad misiles
        var costMissileDamage = 25;     // Costo inicial de Daño de misiles

        var costUpgradeBaseShipHealth = 20; // Costo de aumentar la vida máxima de la nave base

        var particles = []; // Array para las partículas (misiles y explosiones)

        // Ajuste del canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight - 40; // Restar espacio para el botón de mejoras
            initGame();
        }
        window.addEventListener('resize', resizeCanvas, false);
        resizeCanvas();

        // Inicializar el juego
        function initGame() {
            // Reiniciar todas las variables y arrays
            enemyMissiles = [];
            playerMissiles = [];
            explosions = [];
            enemyShips = [];
            enemyHangars = [];
            enemyFighters = [];
            energyBullets = [];
            particles = [];
            canShoot = true;
            gamePaused = false;
            score = 0;
            wave = 1;
            coinsToSpend = 9999; // Jugador inicia con 9999 coins

            // Reiniciar mejoras y costos
            missileLimit = 2;
            missileSpeedMultiplier = 1.00;
            explosionSizeMultiplier = 1.00;
            explosionDurationMultiplier = 1.00;
            missileDamage = 1;
            costMissileLimit = 10;
            costExplosionSize = 20;
            costMissileSpeed = 10;
            costMissileDamage = 25;
            costUpgradeBaseShipHealth = 20;
            baseShipMaxHealth = 6;
            baseShipHealth = baseShipMaxHealth;
            baseShipMissiles = 10;

            document.getElementById('score').innerText = score;
            document.getElementById('wave').innerText = wave;
            document.getElementById('availableCoins').innerText = Math.floor(coinsToSpend);
            document.getElementById('baseShipMissiles').innerText = baseShipMissiles;

            updateUpgradeMenu();

            // Inicializar nave base
            baseShip = {
                x: canvas.width / 2,
                y: canvas.height * 0.75, // Vuela más abajo
                width: canvas.width * 0.08,
                height: canvas.height * 0.04,
                destroyed: false,
                speed: canvas.width * 0.0015,
                direction: 1,
                verticalSpeed: canvas.height * 0.0002, // Velocidad vertical reducida
                verticalDirection: 1
            };

            // Inicializar ciudades
            cities = [];
            var numberOfBuildings = 20;
            var groundHeight = 0; // Eliminar altura del suelo
            for (var i = 0; i < numberOfBuildings; i++) {
                var cityWidth = (canvas.width * 0.02) + Math.random() * (canvas.width * 0.05);
                var cityHeight = (canvas.height * 0.05) + Math.random() * (canvas.height * 0.15);
                var xPosition = Math.random() * (canvas.width - cityWidth);
                var yPosition = canvas.height - cityHeight; // Mover la ciudad más abajo
                cities.push({
                    x: xPosition,
                    y: yPosition,
                    width: cityWidth,
                    height: cityHeight,
                    destroyed: false,
                    color: 'rgb(0,' + (50 + Math.floor(Math.random() * 205)) + ',255)'
                });
            }

            startWave();
        }

        // Obtener posición del puntero
        function getPointerPosition(event) {
            var rect = canvas.getBoundingClientRect();
            var x, y;
            if (event.touches && event.touches.length > 0) {
                x = event.touches[0].clientX - rect.left;
                y = event.touches[0].clientY - rect.top;
            } else {
                x = event.clientX - rect.left;
                y = event.clientY - rect.top;
            }
            return { x: x, y: y };
        }

        // Manejar interacción del jugador
        function handleInteraction(event) {
            event.preventDefault();
            if (!canShoot || gamePaused) return;
            if (playerMissiles.length >= missileLimit) return;
            if (baseShipMissiles <= 0) return;

            var pointer = getPointerPosition(event);
            if (baseShip && !baseShip.destroyed) {
                var dx = pointer.x - baseShip.x;
                var dy = pointer.y - baseShip.y;
                var angle = Math.atan2(dy, dx);

                playerMissiles.push({
                    x: baseShip.x,
                    y: baseShip.y,
                    targetX: pointer.x,
                    targetY: pointer.y,
                    speed: canvas.height * 0.00125 * missileSpeedMultiplier,
                    exploded: false,
                    angle: angle
                });
                baseShipMissiles--;
                document.getElementById('baseShipMissiles').innerText = baseShipMissiles;
                updateUpgradeMenu();
            }
        }

        canvas.addEventListener('click', handleInteraction);
        canvas.addEventListener('touchstart', handleInteraction);

        // Iniciar oleada
        function startWave() {
            canShoot = true;
            var MAX_ENEMY_SHIPS = 5; // Máximo de naves enemigas por oleada
            enemyShipsPerWave = Math.min(Math.floor(wave / 2) + 1, MAX_ENEMY_SHIPS);
            enemyHangarsPerWave = Math.floor(wave / 5); // Cada 5 oleadas, una naveHangar más
            generateEnemyShips();
            gamePaused = false; // Asegurarse de que el juego no esté en pausa
            requestAnimationFrame(gameLoop);
        }

        // Generar naves enemigas
        function generateEnemyShips() {
            // Generar naves tipo naveMisiles
            for (let i = 0; i < enemyShipsPerWave; i++) {
                let enemyShip = {
                    x: Math.random() * canvas.width,
                    y: canvas.height * 0.1,
                    width: canvas.width * 0.03,
                    height: canvas.height * 0.02,
                    speed: canvas.width * 0.0015,
                    direction: Math.random() < 0.5 ? -1 : 1,
                    missilesLeft: 2,
                    destroyed: false,
                    health: 3,          // Vida actual de la nave enemiga (incrementada a 3)
                    maxHealth: 3,       // Vida máxima de la nave enemiga
                    lastShotTime: Date.now() - Math.random() * 3000, // Variación en el tiempo del primer disparo
                    retreatStartTime: null,
                    angle: 0 // Se añadirá para dibujar el misil
                };
                enemyShips.push(enemyShip);
            }

            // Generar naves tipo naveHangar
            for (let i = 0; i < enemyHangarsPerWave; i++) {
                let hangar = {
                    x: Math.random() * canvas.width,
                    y: canvas.height * 0.15, // Vuela más abajo
                    width: canvas.width * 0.06, // Doble de tamaño que naveMisiles
                    height: canvas.height * 0.04,
                    speed: canvas.width * 0.0005, // Movimiento lento
                    direction: Math.random() < 0.5 ? -1 : 1,
                    health: 8,          // Vida actual de la nave hangar (incrementada a 8)
                    maxHealth: 8,       // Vida máxima de la nave hangar
                    lastBurstTime: null,
                    isFiring: false,
                    burstDuration: 2000, // 2 segundos
                    reloadTime: 4000,    // 4 segundos
                    cazasLaunched: 0,
                    maxCazas: 4,
                    lastCazaLaunchTime: Date.now(),
                    cazas: [],           // Lista de naves cazas lanzadas
                    destroyed: false,
                    hasEscaped: false
                };
                enemyHangars.push(hangar);
            }
        }

        // Bucle del juego
        function gameLoop() {
            if (!gamePaused) {
                update();
                draw();
                requestAnimationFrame(gameLoop);
            }
        }

        // Actualizar estado del juego
        function update() {
            var currentTime = Date.now();

            // Movimiento automático de la nave base
            if (baseShip && !baseShip.destroyed) {
                // Movimiento para interceptar el misil enemigo más cercano
                let closestMissile = null;
                let minDistance = Infinity;
                enemyMissiles.forEach(function(missile) {
                    let dx = missile.x - baseShip.x;
                    let dy = missile.y - baseShip.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestMissile = missile;
                    }
                });
                if (closestMissile) {
                    let direction = closestMissile.x > baseShip.x ? 1 : -1;
                    baseShip.x += baseShip.speed * direction;
                } else {
                    // Movimiento horizontal normal
                    baseShip.x += baseShip.speed * baseShip.direction;
                    if (Math.random() < 0.01) {
                        baseShip.direction *= -1;
                    }
                }
                // Limitar movimiento dentro del canvas
                if (baseShip.x < baseShip.width / 2) {
                    baseShip.x = baseShip.width / 2;
                    baseShip.direction *= -1;
                }
                if (baseShip.x > canvas.width - baseShip.width / 2) {
                    baseShip.x = canvas.width - baseShip.width / 2;
                    baseShip.direction *= -1;
                }
            }

            // Actualizar naves enemigas tipo naveMisiles
            enemyShips.forEach(function(ship, index) {
                ship.x += ship.speed * ship.direction;
                if (ship.x < 0 || ship.x > canvas.width) {
                    ship.direction *= -1;
                    ship.y += canvas.height * 0.02;
                }
                // Lanzar misiles
                if (ship.missilesLeft > 0 && currentTime - ship.lastShotTime >= 5000) {
                    ship.lastShotTime = currentTime;
                    let targetOptions = cities.filter(city => !city.destroyed);
                    if (targetOptions.length === 0 && baseShip && !baseShip.destroyed) {
                        targetOptions = [baseShip];
                    } else if (targetOptions.length === 0) {
                        targetOptions = [{ x: canvas.width / 2, y: canvas.height }];
                    }
                    let target = targetOptions[Math.floor(Math.random() * targetOptions.length)];

                    let dx = target.x - ship.x;
                    let dy = target.y - (ship.y + ship.height / 2);
                    let angle = Math.atan2(dy, dx);

                    enemyMissiles.push({
                        x: ship.x,
                        y: ship.y + ship.height / 2,
                        targetX: target.x,
                        targetY: target.y,
                        speed: canvas.height * 0.0004, // Velocidad constante
                        exploded: false,
                        angle: angle
                    });
                    ship.missilesLeft--;
                    // Aproximarse a la ciudad
                    ship.y += canvas.height * 0.02;
                }
                // Esperar antes de huir si ya no tiene misiles
                if (ship.missilesLeft <= 0) {
                    if (!ship.retreatStartTime) {
                        ship.retreatStartTime = currentTime;
                    } else if (currentTime - ship.retreatStartTime >= 15000) {
                        // Huir hacia arriba
                        ship.y -= canvas.height * 0.005;
                        if (ship.y + ship.height < 0) {
                            enemyShips.splice(index, 1);
                        }
                    }
                }
            });

            // Actualizar naves enemigas tipo naveHangar
            enemyHangars.forEach(function(hangar, index) {
                hangar.x += hangar.speed * hangar.direction;
                if (hangar.x < 0 || hangar.x > canvas.width) {
                    hangar.direction *= -1;
                }

                // Disparar ráfagas de ametralladora de energía
                if (!hangar.isFiring && (!hangar.lastBurstTime || currentTime - hangar.lastBurstTime >= hangar.reloadTime)) {
                    // Verificar si hay objetivos cercanos
                    let targets = playerMissiles.concat([baseShip]).filter(obj => obj && !obj.destroyed);
                    let inRange = targets.some(obj => {
                        let dx = obj.x - hangar.x;
                        let dy = obj.y - hangar.y;
                        return Math.sqrt(dx * dx + dy * dy) < canvas.height * 0.3; // Alcance limitado
                    });
                    if (inRange) {
                        hangar.isFiring = true;
                        hangar.lastBurstTime = currentTime;
                        hangar.lastShotTime = currentTime;
                    }
                }

                if (hangar.isFiring) {
                    // Disparar proyectiles de energía cada 0.5 segundos
                    if (currentTime - hangar.lastShotTime >= 500) {
                        hangar.lastShotTime = currentTime;
                        // Crear proyectiles hacia el objetivo más cercano
                        let targets = playerMissiles.concat([baseShip]).filter(obj => obj && !obj.destroyed);
                        let closestTarget = null;
                        let minDistance = Infinity;
                        targets.forEach(obj => {
                            let dx = obj.x - hangar.x;
                            let dy = obj.y - hangar.y;
                            let distance = Math.sqrt(dx * dx + dy * dy);
                            if (distance < minDistance) {
                                minDistance = distance;
                                closestTarget = obj;
                            }
                        });
                        if (closestTarget) {
                            let dx = closestTarget.x - hangar.x;
                            let dy = closestTarget.y - hangar.y;
                            let angle = Math.atan2(dy, dx);
                            energyBullets.push({
                                x: hangar.x,
                                y: hangar.y,
                                vx: Math.cos(angle) * canvas.width * 0.005,
                                vy: Math.sin(angle) * canvas.height * 0.005,
                                size: 3,
                                damage: 1,
                                owner: 'hangar',
                                lifeTime: 500 // Vida útil de la bala en ms
                            });
                        }
                    }
                    if (currentTime - hangar.lastBurstTime >= hangar.burstDuration) {
                        hangar.isFiring = false;
                        hangar.lastBurstTime = currentTime;
                    }
                }

                // Lanzar naves cazas
                if (hangar.cazasLaunched < hangar.maxCazas && currentTime - hangar.lastCazaLaunchTime >= 5000) {
                    hangar.lastCazaLaunchTime = currentTime;
                    hangar.cazasLaunched++;
                    let caza = {
                        x: hangar.x,
                        y: hangar.y + hangar.height / 2,
                        width: canvas.width * 0.02,
                        height: canvas.height * 0.015,
                        speed: canvas.height * 0.001,
                        health: 2,          // Vida actual de la nave caza (incrementada a 2)
                        maxHealth: 2,       // Vida máxima de la nave caza
                        lastShotTime: currentTime,
                        shotInterval: 2000, // Dispara cada 2 segundos
                        orbitRadius: canvas.width * 0.1 + Math.random() * canvas.width * 0.05,
                        orbitAngle: Math.random() * Math.PI * 2,
                        orbitSpeed: 0.02 + Math.random() * 0.02,
                        hangar: hangar,
                        destroyed: false,
                        escaping: false
                    };
                    enemyFighters.push(caza);
                    hangar.cazas.push(caza); // Añadir caza a la lista de cazas del hangar
                }

                // Verificar si todas las cazas han sido destruidas
                if (hangar.cazasLaunched >= hangar.maxCazas && hangar.cazas.every(caza => caza.destroyed || caza.escaping)) {
                    // Iniciar secuencia de huida
                    hangar.destroyed = true; // Marcar hangar como destruido para que las cazas huyan
                    hangar.hasEscaped = true;
                    // Iniciar huida hacia arriba
                    hangar.y -= canvas.height * 0.005;
                    if (hangar.y + hangar.height < 0) {
                        enemyHangars.splice(index, 1);
                    }
                }
            });

            // Actualizar naves cazas
            enemyFighters.forEach(function(caza, index) {
                if (caza.escaping) {
                    // Huye hacia arriba
                    caza.y -= caza.speed;
                    if (caza.y + caza.height < 0) {
                        enemyFighters.splice(index, 1);
                    }
                    return;
                }

                // Verificar si el hangar está destruido o ha huido
                if (caza.hangar.destroyed || caza.hangar.hasEscaped) {
                    caza.escaping = true;
                    return;
                }

                // Movimiento orbital alrededor de la nave defensora
                if (baseShip && !baseShip.destroyed) {
                    caza.orbitAngle += caza.orbitSpeed;
                    caza.x = baseShip.x + Math.cos(caza.orbitAngle) * caza.orbitRadius;
                    caza.y = baseShip.y + Math.sin(caza.orbitAngle) * caza.orbitRadius;

                    // Disparar proyectiles de energía
                    if (currentTime - caza.lastShotTime >= caza.shotInterval) {
                        caza.lastShotTime = currentTime;
                        let dx = baseShip.x - caza.x;
                        let dy = baseShip.y - caza.y;
                        let angle = Math.atan2(dy, dx);
                        energyBullets.push({
                            x: caza.x,
                            y: caza.y,
                            vx: Math.cos(angle) * canvas.width * 0.005,
                            vy: Math.sin(angle) * canvas.height * 0.005,
                            size: 2,
                            damage: 1,
                            owner: 'caza',
                            lifeTime: 500 // Vida útil de la bala en ms
                        });
                    }
                } else {
                    // Si no hay nave defensora, moverse hacia abajo
                    caza.y += caza.speed;
                }

                // Evasión de misiles
                playerMissiles.forEach(function(missile) {
                    let dx = missile.x - caza.x;
                    let dy = missile.y - caza.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < canvas.width * 0.1) {
                        // Ajustar órbita para evadir
                        caza.orbitRadius += (Math.random() - 0.5) * canvas.width * 0.02;
                        caza.orbitSpeed += (Math.random() - 0.5) * 0.01;
                    }
                });

                // Eliminar si sale de la pantalla
                if (caza.y > canvas.height) {
                    enemyFighters.splice(index, 1);
                }
            });

            // Actualizar misiles enemigos
            enemyMissiles.forEach(function(missile, index) {
                let dx = missile.targetX - missile.x;
                let dy = missile.targetY - missile.y;
                let distance = Math.sqrt(dx * dx + dy * dy);
                let moveX = (dx / distance) * missile.speed;
                let moveY = (dy / distance) * missile.speed;

                missile.x += moveX;
                missile.y += moveY;

                // Verificar colisión con la nave de defensa
                if (baseShip && !baseShip.destroyed && checkCollision(baseShip, missile)) {
                    // Destruir el misil y reducir vida de la nave
                    createExplosion(missile.x, missile.y, false);
                    enemyMissiles.splice(index, 1);
                    baseShipHealth--;
                    if (baseShipHealth <= 0) {
                        baseShip.destroyed = true;
                    }
                }

                if (distance < missile.speed) {
                    // Explosión al llegar al destino
                    createExplosion(missile.x, missile.y, false);
                    enemyMissiles.splice(index, 1);

                    // Destruir ciudad
                    cities.forEach(function(city) {
                        if (!city.destroyed && checkCollision(city, missile)) {
                            city.destroyed = true;
                        }
                    });
                }

                // Generar partículas para la estela
                for (let i = 0; i < 3; i++) { // Aumentar el número para alargar la estela
                    createParticle(missile.x, missile.y, missile.angle, 'enemy');
                }
            });

            // Actualizar misiles del jugador
            playerMissiles.forEach(function(missile, index) {
                let dx = missile.targetX - missile.x;
                let dy = missile.targetY - missile.y;
                let distance = Math.sqrt(dx * dx + dy * dy);
                let moveX = (dx / distance) * missile.speed;
                let moveY = (dy / distance) * missile.speed;

                missile.x += moveX;
                missile.y += moveY;

                if (distance < missile.speed) {
                    // Explosión al llegar al destino
                    createExplosion(missile.x, missile.y, true);
                    playerMissiles.splice(index, 1);
                }

                // Generar partículas para la estela
                for (let i = 0; i < 3; i++) { // Aumentar el número para alargar la estela
                    createParticle(missile.x, missile.y, missile.angle, 'player');
                }
            });

            // Actualizar partículas
            particles = particles.filter(function(particle) {
                particle.life -= 1;
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.opacity = particle.life / particle.maxLife;
                return particle.life > 0;
            });

            // Actualizar proyectiles de energía
            energyBullets.forEach(function(bullet, index) {
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;
                bullet.lifeTime -= 16; // Aproximadamente 60 FPS

                if (bullet.owner === 'hangar' || bullet.owner === 'caza') {
                    // Verificar colisión con la nave defensora
                    if (baseShip && !baseShip.destroyed && checkCollision(baseShip, bullet)) {
                        baseShipHealth -= bullet.damage;
                        if (baseShipHealth <= 0) {
                            baseShip.destroyed = true;
                        }
                        energyBullets.splice(index, 1);
                    }
                    // Verificar colisión con misiles del jugador
                    playerMissiles.forEach(function(missile, mIndex) {
                        if (checkCollision(missile, bullet)) {
                            createExplosion(missile.x, missile.y, false);
                            playerMissiles.splice(mIndex, 1);
                            energyBullets.splice(index, 1);
                        }
                    });
                }

                // Eliminar si sale de la pantalla o si su vida útil termina
                if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height || bullet.lifeTime <= 0) {
                    energyBullets.splice(index, 1);
                }
            });

            // Actualizar explosiones
            explosions.forEach(function(explosion, index) {
                // Crear partículas para la explosión
                for (let i = 0; i < 10; i++) {
                    createExplosionParticle(explosion.x, explosion.y, explosion.size);
                }

                explosion.opacity -= explosion.fadeRate;
                if (explosion.opacity <= 0) {
                    explosions.splice(index, 1);
                } else {
                    // Verificar colisiones con misiles enemigos
                    enemyMissiles.forEach(function(missile, mIndex) {
                        let dx = missile.x - explosion.x;
                        let dy = missile.y - explosion.y;
                        let distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < explosion.size) {
                            if (!explosion.affectedMissiles) {
                                explosion.affectedMissiles = [];
                            }
                            if (!explosion.affectedMissiles.includes(missile)) {
                                createExplosion(missile.x, missile.y, false);
                                enemyMissiles.splice(mIndex, 1);
                                score += 5;
                                coinsToSpend += 3; // Recompensa incrementada
                                document.getElementById('score').innerText = score;
                                document.getElementById('availableCoins').innerText = Math.floor(coinsToSpend);
                                explosion.affectedMissiles.push(missile);
                            }
                        }
                    });
                    // Verificar colisiones con naves enemigas tipo naveMisiles
                    enemyShips.forEach(function(ship, sIndex) {
                        let dx = ship.x - explosion.x;
                        let dy = ship.y - explosion.y;
                        let distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < explosion.size) {
                            if (!explosion.affectedShips) {
                                explosion.affectedShips = [];
                            }
                            if (!explosion.affectedShips.includes(ship)) {
                                ship.health -= missileDamage; // Daño basado en mejora
                                explosion.affectedShips.push(ship); // Marcar nave como afectada
                                if (ship.health <= 0) {
                                    createExplosion(ship.x, ship.y, false);
                                    enemyShips.splice(sIndex, 1);
                                    score += 15; // Recompensa ajustada
                                    coinsToSpend += 10; // Recompensa ajustada
                                    document.getElementById('score').innerText = score;
                                    document.getElementById('availableCoins').innerText = Math.floor(coinsToSpend);
                                }
                            }
                        }
                    });
                    // Verificar colisiones con naves enemigas tipo naveHangar
                    enemyHangars.forEach(function(hangar, hIndex) {
                        let dx = hangar.x - explosion.x;
                        let dy = hangar.y - explosion.y;
                        let distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < explosion.size) {
                            if (!explosion.affectedHangars) {
                                explosion.affectedHangars = [];
                            }
                            if (!explosion.affectedHangars.includes(hangar)) {
                                hangar.health -= missileDamage;
                                explosion.affectedHangars.push(hangar);
                                if (hangar.health <= 0) {
                                    createExplosion(hangar.x, hangar.y, false);
                                    hangar.destroyed = true;
                                    enemyHangars.splice(hIndex, 1);
                                    score += 100; // Mayor recompensa
                                    coinsToSpend += 50; // Mayor recompensa
                                    document.getElementById('score').innerText = score;
                                    document.getElementById('availableCoins').innerText = Math.floor(coinsToSpend);
                                }
                            }
                        }
                    });
                    // Verificar colisiones con naves cazas
                    enemyFighters.forEach(function(caza, cIndex) {
                        let dx = caza.x - explosion.x;
                        let dy = caza.y - explosion.y;
                        let distance = Math.sqrt(dx * dx + dy * dy);
                        if (distance < explosion.size) {
                            if (!explosion.affectedCazas) {
                                explosion.affectedCazas = [];
                            }
                            if (!explosion.affectedCazas.includes(caza)) {
                                caza.health -= missileDamage;
                                explosion.affectedCazas.push(caza);
                                if (caza.health <= 0) {
                                    createExplosion(caza.x, caza.y, false);
                                    caza.destroyed = true;
                                    enemyFighters.splice(cIndex, 1);
                                    score += 20; // Recompensa ajustada
                                    coinsToSpend += 15; // Recompensa ajustada
                                    document.getElementById('score').innerText = score;
                                    document.getElementById('availableCoins').innerText = Math.floor(coinsToSpend);
                                }
                            }
                        }
                    });
                }
            });

            // Verificar si el juego ha terminado
            if ((cities.every(city => city.destroyed)) || (baseShip.destroyed || !baseShip)) {
                // Fin del juego
                alert('¡Fin del juego! Puntos: ' + score);
                initGame(); // Reiniciar el juego completamente
                return;
            }

            // Verificar si la oleada ha terminado
            if (enemyShips.length === 0 && enemyHangars.length === 0 && enemyFighters.length === 0 && enemyMissiles.length === 0 && explosions.length === 0) {
                // Oleada completada
                coinsToSpend += 20; // Recompensa incrementada
                wave++;
                document.getElementById('wave').innerText = wave;
                document.getElementById('availableCoins').innerText = Math.floor(coinsToSpend);
                showUpgradeMenu();
            }
        }

        // Funciones para crear partículas y explosiones

        // Función para crear partículas de estela
        function createParticle(x, y, angle, type) {
            var speed = Math.random() * 1 + 0.5;
            var particleAngle = angle + (Math.random() * 0.4 - 0.2); // Variación aleatoria
            var lifeSpan = 50; // Aumentar la vida para alargar la estela
            particles.push({
                x: x,
                y: y,
                vx: -Math.cos(particleAngle) * speed,
                vy: -Math.sin(particleAngle) * speed,
                size: Math.random() * 2 + 1,
                life: lifeSpan,
                maxLife: lifeSpan,
                opacity: 1,
                type: type
            });
        }

        // Función para crear partículas de explosión
        function createExplosionParticle(x, y, explosionSize) {
            var angle = Math.random() * 2 * Math.PI;
            var speed = Math.random() * 2 + 1;
            var lifeSpan = Math.random() * 20 + 20;
            particles.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                size: Math.random() * (explosionSize / 10) + 1,
                life: lifeSpan,
                maxLife: lifeSpan,
                opacity: 1,
                type: 'explosion'
            });
        }

        // Crear explosión
        function createExplosion(x, y, isPlayerExplosion) {
            var sizeMultiplier = isPlayerExplosion ? explosionSizeMultiplier : 1;
            var durationMultiplier = isPlayerExplosion ? explosionDurationMultiplier : 1;
            var maxRadius = canvas.height * 0.005 * sizeMultiplier * 10;
            var duration = 60 * durationMultiplier;
            explosions.push({
                x: x,
                y: y,
                size: maxRadius,
                opacity: 1,
                fadeRate: 1 / duration,
                affectedShips: [],
                affectedHangars: [],
                affectedCazas: [],
                affectedMissiles: []
            });
        }

        // Dibujar elementos en el canvas
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Dibujar partículas
            particles.forEach(function(particle) {
                ctx.globalAlpha = particle.opacity;
                if (particle.type === 'player') {
                    ctx.fillStyle = 'rgba(173,216,230,' + particle.opacity + ')'; // Color azul claro
                } else if (particle.type === 'enemy') {
                    ctx.fillStyle = 'rgba(255,140,0,' + particle.opacity + ')'; // Color naranja
                } else if (particle.type === 'explosion') {
                    // De amarillo brillante a rojo y luego transparente
                    var gradient = ctx.createRadialGradient(particle.x, particle.y, 0, particle.x, particle.y, particle.size);
                    gradient.addColorStop(0, 'rgba(255, 255, 0,' + particle.opacity + ')'); // Amarillo
                    gradient.addColorStop(0.5, 'rgba(255, 140, 0,' + particle.opacity + ')'); // Naranja
                    gradient.addColorStop(1, 'rgba(255, 0, 0,' + particle.opacity + ')'); // Rojo
                    ctx.fillStyle = gradient;
                }
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, 2 * Math.PI);
                ctx.fill();
                ctx.globalAlpha = 1;
            });

            // Dibujar misiles enemigos
            enemyMissiles.forEach(function(missile) {
                // Dibujar misil enemigo
                ctx.save();
                ctx.translate(missile.x, missile.y);
                ctx.rotate(missile.angle);
                ctx.fillStyle = 'red';
                ctx.beginPath();
                ctx.moveTo(0, -3);
                ctx.lineTo(6, 0);
                ctx.lineTo(0, 3);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            });

            // Dibujar misiles del jugador
            playerMissiles.forEach(function(missile) {
                // Dibujar misil del jugador
                ctx.save();
                ctx.translate(missile.x, missile.y);
                ctx.rotate(missile.angle);
                ctx.fillStyle = '#00BFFF';
                ctx.beginPath();
                ctx.moveTo(0, -3);
                ctx.lineTo(6, 0);
                ctx.lineTo(0, 3);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            });

            // Dibujar proyectiles de energía
            energyBullets.forEach(function(bullet) {
                ctx.fillStyle = 'yellow';
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.size, 0, 2 * Math.PI);
                ctx.fill();
            });

            // Dibujar ciudades
            cities.forEach(function(city) {
                if (!city.destroyed) {
                    ctx.fillStyle = city.color;
                    ctx.fillRect(city.x, city.y, city.width, city.height);
                }
            });

            // Dibujar nave base flotante
            if (baseShip && !baseShip.destroyed) {
                ctx.fillStyle = 'gray';
                ctx.fillRect(baseShip.x - baseShip.width / 2, baseShip.y - baseShip.height / 2, baseShip.width, baseShip.height);
                // Dibujar barra de vida debajo de la nave
                var healthBarWidth = baseShip.width;
                var healthBarX = baseShip.x - healthBarWidth / 2;
                var healthBarY = baseShip.y + baseShip.height / 2 + 5;
                ctx.strokeStyle = '#fff';
                ctx.strokeRect(healthBarX, healthBarY, healthBarWidth, 5);
                ctx.fillStyle = 'green';
                ctx.fillRect(healthBarX, healthBarY, healthBarWidth * (baseShipHealth / baseShipMaxHealth), 5);
            }

            // Dibujar naves enemigas tipo naveMisiles
            enemyShips.forEach(function(ship) {
                ctx.fillStyle = 'red';
                ctx.fillRect(ship.x - ship.width / 2, ship.y - ship.height / 2, ship.width, ship.height);
                // Dibujar barra de vida debajo de la nave enemiga
                var healthBarWidth = ship.width;
                var healthBarX = ship.x - healthBarWidth / 2;
                var healthBarY = ship.y + ship.height / 2 + 5;
                ctx.strokeStyle = '#fff';
                ctx.strokeRect(healthBarX, healthBarY, healthBarWidth, 5);
                ctx.fillStyle = 'green';
                ctx.fillRect(healthBarX, healthBarY, healthBarWidth * (ship.health / ship.maxHealth), 5);
            });

            // Dibujar naves enemigas tipo naveHangar
            enemyHangars.forEach(function(hangar) {
                ctx.fillStyle = 'purple';
                ctx.fillRect(hangar.x - hangar.width / 2, hangar.y - hangar.height / 2, hangar.width, hangar.height);
                // Dibujar barra de vida debajo de la nave hangar
                var healthBarWidth = hangar.width;
                var healthBarX = hangar.x - healthBarWidth / 2;
                var healthBarY = hangar.y + hangar.height / 2 + 5;
                ctx.strokeStyle = '#fff';
                ctx.strokeRect(healthBarX, healthBarY, healthBarWidth, 5);
                ctx.fillStyle = 'green';
                ctx.fillRect(healthBarX, healthBarY, healthBarWidth * (hangar.health / hangar.maxHealth), 5);
            });

            // Dibujar naves cazas
            enemyFighters.forEach(function(caza) {
                ctx.fillStyle = 'orange';
                ctx.fillRect(caza.x - caza.width / 2, caza.y - caza.height / 2, caza.width, caza.height);
                // Dibujar barra de vida debajo de la nave caza
                var healthBarWidth = caza.width;
                var healthBarX = caza.x - healthBarWidth / 2;
                var healthBarY = caza.y + caza.height / 2 + 5;
                ctx.strokeStyle = '#fff';
                ctx.strokeRect(healthBarX, healthBarY, healthBarWidth, 5);
                ctx.fillStyle = 'green';
                ctx.fillRect(healthBarX, healthBarY, healthBarWidth * (caza.health / caza.maxHealth), 5);
            });
        }

        // Mostrar menú de mejoras
        function showUpgradeMenu() {
            gamePaused = true;
            canShoot = false;
            document.getElementById('coinsToSpend').innerText = Math.floor(coinsToSpend);
            updateUpgradeMenu();
            document.getElementById('upgradeMenu').style.display = 'block';
        }

        // Event listeners para botones de mejora
        document.getElementById('continueButton').addEventListener('click', function() {
            gamePaused = false;
            canShoot = true;
            document.getElementById('upgradeMenu').style.display = 'none';
            startWave(); // Reiniciar la siguiente oleada
        });

        document.getElementById('upgradeButton').addEventListener('click', function() {
            showUpgradeMenu();
        });

        document.getElementById('upgradeMissileLimit').addEventListener('click', function() {
            if (coinsToSpend >= costMissileLimit) {
                coinsToSpend -= costMissileLimit;
                missileLimit++;
                costMissileLimit *= 1.2; // Ajuste del factor de costo
                updateUpgradeMenu();
                document.getElementById('availableCoins').innerText = Math.floor(coinsToSpend);
            }
        });

        document.getElementById('upgradeMissileSpeed').addEventListener('click', function() {
            if (coinsToSpend >= costMissileSpeed) {
                coinsToSpend -= costMissileSpeed;
                missileSpeedMultiplier += 0.1;
                costMissileSpeed *= 1.2; // Ajuste del factor de costo
                updateUpgradeMenu();
                document.getElementById('availableCoins').innerText = Math.floor(coinsToSpend);
            }
        });

        document.getElementById('upgradeExplosionSize').addEventListener('click', function() {
            if (coinsToSpend >= costExplosionSize) {
                coinsToSpend -= costExplosionSize;
                explosionSizeMultiplier += 0.1;
                costExplosionSize *= 1.2; // Ajuste del factor de costo
                updateUpgradeMenu();
                document.getElementById('availableCoins').innerText = Math.floor(coinsToSpend);
            }
        });

        // Botón para reparar la nave base
        document.getElementById('repairBaseShip').addEventListener('click', function() {
            if (baseShipHealth < baseShipMaxHealth && coinsToSpend >= 5) {
                coinsToSpend -= 5;
                baseShipHealth++;
                updateUpgradeMenu();
                document.getElementById('availableCoins').innerText = Math.floor(coinsToSpend);
            }
        });

        // Botón para aumentar la vida máxima de la nave base
        document.getElementById('upgradeBaseShipHealth').addEventListener('click', function() {
            if (coinsToSpend >= costUpgradeBaseShipHealth) {
                coinsToSpend -= costUpgradeBaseShipHealth;
                baseShipMaxHealth++;
                baseShipHealth = baseShipMaxHealth;
                costUpgradeBaseShipHealth *= 1.5;
                updateUpgradeMenu();
                document.getElementById('availableCoins').innerText = Math.floor(coinsToSpend);
            }
        });

        // Botón para comprar misiles
        document.getElementById('buyMissiles').addEventListener('click', function() {
            if (coinsToSpend >= 5 && baseShipMissiles + 5 <= maxMissiles) {
                coinsToSpend -= 5;
                baseShipMissiles += 5;
                updateUpgradeMenu();
                document.getElementById('availableCoins').innerText = Math.floor(coinsToSpend);
                document.getElementById('baseShipMissiles').innerText = baseShipMissiles;
            }
        });

        // Evento para mejora de daño de misiles
        document.getElementById('upgradeMissileDamage').addEventListener('click', function() {
            if (coinsToSpend >= costMissileDamage) {
                coinsToSpend -= costMissileDamage;
                missileDamage++;
                costMissileDamage *= 1.3;
                updateUpgradeMenu();
                document.getElementById('availableCoins').innerText = Math.floor(coinsToSpend);
            }
        });

        // Actualizar menú de mejoras
        function updateUpgradeMenu() {
            document.getElementById('coinsToSpend').innerText = Math.floor(coinsToSpend);

            document.getElementById('costMissileLimit').innerText = Math.ceil(costMissileLimit);
            document.getElementById('costMissileSpeed').innerText = Math.ceil(costMissileSpeed);
            document.getElementById('costExplosionSize').innerText = Math.ceil(costExplosionSize);
            document.getElementById('costMissileDamage').innerText = Math.ceil(costMissileDamage);

            // Mostrar valores actuales
            document.getElementById('currentMissileLimit').innerText = missileLimit;
            document.getElementById('currentMissileSpeed').innerText = missileSpeedMultiplier.toFixed(2);
            document.getElementById('currentExplosionSize').innerText = explosionSizeMultiplier.toFixed(2);
            document.getElementById('currentMissileDamage').innerText = missileDamage;

            // Actualizar información de la nave base
            document.getElementById('currentBaseShipHealth').innerText = baseShipHealth;
            document.getElementById('maxBaseShipHealth').innerText = baseShipMaxHealth;
            document.getElementById('maxBaseShipHealthDisplay').innerText = baseShipMaxHealth;

            // Actualizar misiles
            document.getElementById('currentMissiles').innerText = baseShipMissiles;
            document.getElementById('maxMissiles').innerText = maxMissiles;

            document.getElementById('costUpgradeBaseShipHealth').innerText = Math.ceil(costUpgradeBaseShipHealth);
        }

        // Función para verificar colisiones
        function checkCollision(obj, missile) {
            return (
                missile.x > obj.x - obj.width / 2 &&
                missile.x < obj.x + obj.width / 2 &&
                missile.y > obj.y - obj.height / 2 &&
                missile.y < obj.y + obj.height / 2
            );
        }

        // Iniciar el juego al cargar la página
        initGame();
    </script>
</body>
</html>
